(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// Params: channelId, showTime, title (variables: {user}, {reward}, {price})

const ChatClient = require("twitch-chat-client").default;

let params;
(window.onpopstate = function () {
    let match,
        pl = /\+/g,
        search = /([^&=]+)=?([^&]*)/g,
        decode = function (s) { return decodeURIComponent(s.replace(pl, " ")); },
        query = window.location.search.substring(1);

    params = {};
    while (match = search.exec(query))
        params[decode(match[1])] = decode(match[2]);
})();

function sleep(miliseconds) {
    return new Promise(res => {
        setTimeout(res, miliseconds)
    });
}

function replaceAll(text, find, replaceWith) {
    let re = new RegExp(find, "g");
    return text.replace(re, replaceWith);
}

window.onload = () => {
    const container = document.getElementById("points-notification-container");
    const image = document.getElementById("points-notification-image");
    const title = document.getElementById("points-notification-title");
    const message = document.getElementById("points-notification-message");
    
    let textStyle = "";
    
    if (params.textColor) {
        textStyle += `color: ${params.textColor};`;
    } else {
        textStyle += "color: white;";
    }
    if (params.textSize) {
        textStyle += `font-size: ${params.textSize};`;
    } else {
        textStyle += "font-size: 18px;";
    }
    if (params.textStyle) {
        textStyle += params.textStyle;
    }

    message.setAttribute("style", textStyle);

    let titleStyle = "";
    if (params.titleColor) {
        titleStyle += `color: ${params.titleColor};`;
    } else {
        titleStyle += "color: white;";
    }
    if (params.titleSize) {
        titleStyle += `font-size: ${params.titleSize};`;
    } else {
        titleStyle += "font-size: 25px;";
    }
    if (params.titleStyle) {
        titleStyle += params.titleStyle;
    }
    title.setAttribute("style", titleStyle);

    if (params.imageStyle) {
        image.setAttribute("style", params.imageStyle);
    }

    let showPrices = [];
    let audioPrices = [];
    let ttsPrices = [];

    if (params.showPrices) {
        let items = params.showPrices.split(",");
        for (item of items) {
            showPrices.push(parseInt(item));
        }
    }

    if (params.audioPrices) {
        let items = params.audioPrices.split(",");
        for (item of items) {
            audioPrices.push(parseInt(item));
        }
    }

    if (params.ttsPrices) {
        let items = params.ttsPrices.split(",");
        for (item of items) {
            ttsPrices.push(parseInt(item));
        }
    }

    if (params.botChannelName) {
        (async () => {
            let chatClient = new ChatClient()

            chatClient.onPrivmsg((_, user, message, msg) => {
                if (msg.tags.get("msg-id") === "highlighted-message") {
                    notifications.push({
                        image: "https://static-cdn.jtvnw.net/automatic-reward-images/highlight-4.png",
                        title: params.highlightTitle ? params.highlightTitle : "Highlight My Message",
                        price: params.highlightPrice ? parseInt(params.highlightPrice) : 500,
                        user: user,
                        text: message,
                    });
                }
            })
            chatClient.onRegister(async () => await chatClient.join(params.botChannelName))
            await chatClient.connect();
        })()
    }

    let ws = undefined;
    let pong = false;
    let interval = false;

    let notifications = [];

    let notificationShowing = false;
    (async () => {
        while (true) {
            if (!notificationShowing && notifications.length > 0) {
                let notif = notifications.pop();
                console.log("Notification showing", notif);
                if (showPrices.length !== 0 && showPrices.indexOf(notif.price) === -1)
                    return;
                console.log("Price check passed");
                notificationShowing = true;
                image.setAttribute("style", `background-image: url("${params.img ? params.img : notif.image}")`);
                title.innerText = params.title ? replaceAll(replaceAll(replaceAll(params.title, "{user}", notif.user), "{reward}", notif.title), "{price}", notif.price) : `${notif.user} spent ${notif.price} on ${notif.title}`;
                message.innerText = notif.text;
                container.setAttribute("class", "");
                if (params.audioUrl && (audioPrices.length === 0 || audioPrices.indexOf(notif.price) !== -1)) {
                    console.log("Playing audio", params.audioUrl);
                    try {
                        audio = new Audio();
                        audio.src = params.audioUrl;
                        audio.volume = params.audioVolume ? parseFloat(params.audioVolume) : 1;
                        audio.play();
                        await new Promise((res) => {
                            audio.onended = res;
                            audio.onerror = (e) => { console.log(e); res() };
                        })
                    } catch (e) {
                        console.log("Audio playback error:", e)
                    }
                }
                if (params.tts && (ttsPrices.length === 0 || ttsPrices.indexOf(notif.price) !== -1)) {
                    console.log("Playing TTS");
                    try {
                        await GoogleTTS.textToSpeech(notif.text, params.ttsLang ? params.ttsLang : "en");
                        console.log("TTS ended");
                    } catch (e) {
                        console.log("TTS error:", e)
                    }
                }
                await sleep(parseInt(params.showTime ? params.showTime : 7500));
                notificationShowing = false;
                container.setAttribute("class", "hide");
            }
            await sleep(1000);
        }
    })();

    function connect() {
        ws = new WebSocket("wss://pubsub-edge.twitch.tv");
        listen();
    }
    function disconnect() {
        if (interval) {
            clearInterval(interval);
            interval = false;
        }
        ws.close();
    }

    function listen() {
        ws.onmessage = (a) => {
            let o = JSON.parse(a.data);
            switch (o.type) {
                case "PING":
                    ws.send(JSON.stringify({
                        "type": "PONG"
                    }));
                    break;
                case "PONG":
                    pong = true;
                    break;
                case "RECONNECT":
                    disconnect();
                    connect();
                    break;
                case "RESPONCE":
                    console.log("PubSub responce ", o.error)
                    break;
                case "MESSAGE":
                    switch (o.data.topic) {
                        case `community-points-channel-v1.${params.channelId}`:
                            let msg = JSON.parse(o.data.message);
                            console.log(msg);
                            switch (msg.type) {
                                case "reward-redeemed":
                                    let reward = msg.data.redemption.reward;
                                    let imageUrl = undefined;

                                    let img = reward.image;
                                    let defimg = reward.default_image;

                                    if (img) {
                                        if (img.url_4x) {
                                            imageUrl = img.url_4x;
                                        } else if (img.url_2x) {
                                            imageUrl = img.url_2x;
                                        } else if (img.url_1x) {
                                            imageUrl = img.url_1x;
                                        }
                                    } else if (defimg) {
                                        if (defimg.url_4x) {
                                            imageUrl = defimg.url_4x;
                                        } else if (defimg.url_2x) {
                                            imageUrl = defimg.url_2x;
                                        } else if (defimg.url_1x) {
                                            imageUrl = defimg.url_1x;
                                        }
                                    }
                                    else {
                                        imageUrl = params.defImg ? params.defImg : "https://static-cdn.jtvnw.net/custom-reward-images/default-4.png"
                                    }
                                    let notif = {
                                        image: imageUrl,
                                        title: reward.title,
                                        price: reward.cost,
                                        user: msg.data.redemption.user.display_name,
                                        text: msg.data.redemption.user_input,
                                    };
                                    console.log("Notification queued", notif);
                                    notifications.push(notif);
                                    break;
                            }
                            break;
                    }
                    break;
            }
        }
        ws.onopen = () => {
            ws.send(JSON.stringify({ "type": "LISTEN", "nonce": "pepega", "data": { "topics": ["community-points-channel-v1." + params.channelId], "auth_token": "" } }));
            interval = setInterval(async () => {
                ws.send(JSON.stringify({
                    "type": "PING"
                }));
                await sleep(5000);
                if (pong) {
                    pong = false;
                }
                else {
                    pong = false;
                    disconnect();
                    connect();
                }
            }, 5 * 60 * 1000)
        }
    }

    connect();
}

},{"twitch-chat-client":235}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var createCacheKey_1 = require("../utils/createCacheKey");
function Cacheable(cls) {
    return /** @class */ (function (_super) {
        tslib_1.__extends(class_1, _super);
        function class_1() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.cache = new Map();
            return _this;
        }
        class_1.prototype.getFromCache = function (cacheKey) {
            this._cleanCache();
            if (this.cache.has(cacheKey)) {
                var entry = this.cache.get(cacheKey);
                if (entry) {
                    return entry.value;
                }
            }
            return undefined;
        };
        class_1.prototype.setCache = function (cacheKey, value, timeInSeconds) {
            this.cache.set(cacheKey, {
                value: value,
                expires: Date.now() + timeInSeconds * 1000
            });
        };
        class_1.prototype.removeFromCache = function (cacheKey, prefix) {
            var _this = this;
            var internalCacheKey;
            if (typeof cacheKey === 'string') {
                internalCacheKey = cacheKey;
                if (!internalCacheKey.endsWith('/')) {
                    internalCacheKey += '/';
                }
            }
            else {
                var propName = cacheKey.shift();
                internalCacheKey = createCacheKey_1.default(propName, cacheKey, prefix);
            }
            if (prefix) {
                this.cache.forEach(function (val, key) {
                    if (key.startsWith(internalCacheKey)) {
                        _this.cache.delete(key);
                    }
                });
            }
            else {
                this.cache.delete(internalCacheKey);
            }
        };
        class_1.prototype._cleanCache = function () {
            var _this = this;
            var now = Date.now();
            this.cache.forEach(function (val, key) {
                if (val.expires < now) {
                    _this.cache.delete(key);
                }
            });
        };
        return class_1;
    }(cls));
}
exports.default = Cacheable;

},{"../utils/createCacheKey":7,"tslib":217}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var createCacheKey_1 = require("../utils/createCacheKey");
function Cached(timeInSeconds, cacheFailures) {
    if (timeInSeconds === void 0) { timeInSeconds = Infinity; }
    if (cacheFailures === void 0) { cacheFailures = false; }
    return function (target, propName, descriptor) {
        var origFn = descriptor.value;
        descriptor.value = function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i] = arguments[_i];
            }
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var cacheKey, cachedValue, result;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            cacheKey = createCacheKey_1.default(propName, params);
                            cachedValue = this.getFromCache(cacheKey);
                            if (cachedValue) {
                                return [2 /*return*/, cachedValue];
                            }
                            return [4 /*yield*/, origFn.apply(this, params)];
                        case 1:
                            result = _a.sent();
                            if (result != null || cacheFailures) {
                                this.setCache(cacheKey, result, timeInSeconds);
                            }
                            return [2 /*return*/, result];
                    }
                });
            });
        };
        return descriptor;
    };
}
exports.default = Cached;

},{"../utils/createCacheKey":7,"tslib":217}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var createCacheKey_1 = require("../utils/createCacheKey");
function CachedGetter(timeInSeconds) {
    if (timeInSeconds === void 0) { timeInSeconds = Infinity; }
    return function (target, propName, descriptor) {
        if (descriptor.get) {
            var origFn_1 = descriptor.get;
            descriptor.get = function () {
                var params = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    params[_i] = arguments[_i];
                }
                var cacheKey = createCacheKey_1.default(propName, params);
                var cachedValue = this.getFromCache(cacheKey);
                if (cachedValue) {
                    return cachedValue;
                }
                var result = origFn_1.apply(this, params);
                this.setCache(cacheKey, result, timeInSeconds);
                return result;
            };
        }
        return descriptor;
    };
}
exports.default = CachedGetter;

},{"../utils/createCacheKey":7}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
function ClearsCache(cacheName, numberOfArguments) {
    return function (target, propName, descriptor) {
        var origFn = descriptor.value;
        descriptor.value = function () {
            var params = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                params[_i] = arguments[_i];
            }
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var result, args;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, origFn.apply(this, params)];
                        case 1:
                            result = _a.sent();
                            args = numberOfArguments === undefined ? params.slice() : params.slice(0, numberOfArguments);
                            this.removeFromCache(tslib_1.__spread([cacheName], args), true);
                            return [2 /*return*/, result];
                    }
                });
            });
        };
        return descriptor;
    };
}
exports.default = ClearsCache;

},{"tslib":217}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Cacheable_1 = require("./decorators/Cacheable");
exports.Cacheable = Cacheable_1.default;
var Cached_1 = require("./decorators/Cached");
exports.Cached = Cached_1.default;
var CachedGetter_1 = require("./decorators/CachedGetter");
exports.CachedGetter = CachedGetter_1.default;
var ClearsCache_1 = require("./decorators/ClearsCache");
exports.ClearsCache = ClearsCache_1.default;
var createCacheKey_1 = require("./utils/createCacheKey");
exports.createCacheKey = createCacheKey_1.default;

},{"./decorators/Cacheable":2,"./decorators/Cached":3,"./decorators/CachedGetter":4,"./decorators/ClearsCache":5,"./utils/createCacheKey":7}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
function createSingleCacheKey(param) {
    // noinspection FallThroughInSwitchStatementJS
    switch (typeof param) {
        case 'undefined': {
            return '';
        }
        case 'object': {
            if (param === null) {
                return '';
            }
            if ('cacheKey' in param) {
                return param.cacheKey;
            }
            var objKey = JSON.stringify(param);
            if (objKey !== '{}') {
                return objKey;
            }
        }
        // fallthrough
        default: {
            return param.toString();
        }
    }
}
function createCacheKey(propName, params, prefix) {
    return tslib_1.__spread([propName], params.map(createSingleCacheKey)).join('/') + (prefix ? '/' : '');
}
exports.default = createCacheKey;

},{"tslib":217}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var events_1 = require("events");
var Connection = /** @class */ (function (_super) {
    tslib_1.__extends(Connection, _super);
    function Connection(_a) {
        var hostName = _a.hostName, port = _a.port, secure = _a.secure, lineBased = _a.lineBased;
        var _this = _super.call(this) || this;
        _this._currentLine = '';
        _this._connecting = false;
        _this._connected = false;
        _this._manualDisconnect = false;
        _this._secure = Boolean(secure);
        _this._lineBased = Boolean(lineBased);
        if (port) {
            _this._host = hostName;
            _this._port = port;
        }
        else {
            var splitHost = hostName.split(':');
            if (splitHost.length > 2) {
                throw new Error('malformed hostName');
            }
            var host = splitHost[0], splitPort = splitHost[1];
            _this._host = host;
            if (splitPort) {
                _this._port = Number(splitPort);
            }
        }
        return _this;
    }
    Connection.prototype.connect = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.doConnect()];
            });
        });
    };
    Connection.prototype.disconnect = function (manually) {
        if (manually === void 0) { manually = true; }
        if (this.hasSocket && manually) {
            this._manualDisconnect = true;
        }
    };
    Connection.prototype.destroy = function () {
        this.removeAllListeners();
    };
    Connection.prototype.sendLine = function (line) {
        if (this._connected) {
            line = line.replace(/[\0\r\n]/g, '');
            this.sendRaw(line + "\r\n");
        }
    };
    Connection.prototype.receiveRaw = function (data) {
        if (!this._lineBased) {
            this.emit('receive', data);
            return;
        }
        var receivedLines = data.split('\r\n');
        this._currentLine += receivedLines.shift() || '';
        if (receivedLines.length) {
            this.emit('receive', this._currentLine);
            this._currentLine = receivedLines.pop() || '';
            for (var _i = 0, receivedLines_1 = receivedLines; _i < receivedLines_1.length; _i++) {
                var line = receivedLines_1[_i];
                this.emit('receive', line);
            }
        }
    };
    Object.defineProperty(Connection.prototype, "isConnecting", {
        get: function () {
            return this._connecting;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Connection.prototype, "isConnected", {
        get: function () {
            return this._connected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Connection.prototype, "host", {
        get: function () {
            return this._host;
        },
        enumerable: true,
        configurable: true
    });
    Connection.prototype._handleDisconnect = function (error) {
        this.emit('disconnect', this._manualDisconnect, error);
        if (this._manualDisconnect) {
            this._manualDisconnect = false;
        }
        this.destroy();
    };
    return Connection;
}(events_1.EventEmitter));
exports.default = Connection;

},{"events":328,"tslib":217}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Connection_1 = require("./Connection");
var net_1 = require("net");
var tls = require("tls");
var DirectConnection = /** @class */ (function (_super) {
    tslib_1.__extends(DirectConnection, _super);
    function DirectConnection() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(DirectConnection.prototype, "port", {
        get: function () {
            return this._port || (this._secure ? 6697 : 6667);
        },
        enumerable: true,
        configurable: true
    });
    DirectConnection.prototype.doConnect = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        _this._connecting = true;
                        var connectionErrorListener = function (err) {
                            _this._connected = false;
                            _this._connecting = false;
                            _this._handleDisconnect(err);
                            reject(err);
                        };
                        var connectionListener = function () {
                            _this._connecting = false;
                            _this._connected = true;
                            _this.emit('connect');
                            resolve();
                        };
                        if (_this._secure) {
                            _this._socket = tls.connect(_this.port, _this._host, {}, connectionListener);
                        }
                        else {
                            _this._socket = new net_1.Socket();
                            _this._socket.connect(_this.port, _this._host, connectionListener);
                        }
                        _this._socket.on('error', connectionErrorListener);
                        _this._socket.on('data', function (data) {
                            _this.receiveRaw(data.toString());
                        });
                        _this._socket.on('close', function () {
                            _this._connected = false;
                            _this._connecting = false;
                            _this._handleDisconnect();
                        });
                    })];
            });
        });
    };
    Object.defineProperty(DirectConnection.prototype, "hasSocket", {
        get: function () {
            return !!this._socket;
        },
        enumerable: true,
        configurable: true
    });
    DirectConnection.prototype.destroy = function () {
        if (this._socket) {
            this._socket.destroy();
            this._socket = undefined;
        }
        _super.prototype.destroy.call(this);
    };
    DirectConnection.prototype.sendRaw = function (line) {
        if (this._socket) {
            this._socket.write(line);
        }
    };
    return DirectConnection;
}(Connection_1.default));
exports.default = DirectConnection;

},{"./Connection":8,"net":326,"tls":326,"tslib":217}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Connection_1 = require("./Connection");
var WebSocket = require("universal-websocket-client");
var WebSocketConnection = /** @class */ (function (_super) {
    tslib_1.__extends(WebSocketConnection, _super);
    function WebSocketConnection() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(WebSocketConnection.prototype, "port", {
        get: function () {
            return this._port || (this._secure ? 443 : 80);
        },
        enumerable: true,
        configurable: true
    });
    WebSocketConnection.prototype.doConnect = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        _this._connecting = true;
                        var url = "ws" + (_this._secure ? 's' : '') + "://" + _this._host + ":" + _this.port;
                        _this._socket = new WebSocket(url);
                        _this._socket.onopen = function () {
                            _this._connected = true;
                            _this._connecting = false;
                            _this.emit('connect');
                            resolve();
                        };
                        _this._socket.onmessage = function (_a) {
                            var data = _a.data;
                            _this.receiveRaw(data.toString());
                        };
                        // The following empty error callback needs to exist so connection errors are passed down to `onclose` down below - otherwise the process just crashes instead
                        _this._socket.onerror = function () { };
                        _this._socket.onclose = function (_a) {
                            var wasClean = _a.wasClean, code = _a.code, reason = _a.reason;
                            _this._connected = false;
                            _this._connecting = false;
                            if (wasClean) {
                                _this._handleDisconnect();
                            }
                            else {
                                var err = new Error("[" + code + "] " + reason);
                                _this._handleDisconnect(err);
                                reject(err);
                            }
                        };
                    })];
            });
        });
    };
    Object.defineProperty(WebSocketConnection.prototype, "hasSocket", {
        get: function () {
            return !!this._socket;
        },
        enumerable: true,
        configurable: true
    });
    WebSocketConnection.prototype.destroy = function () {
        if (this._socket) {
            this._socket.close();
            this._socket = undefined;
        }
        _super.prototype.destroy.call(this);
    };
    WebSocketConnection.prototype.sendRaw = function (line) {
        if (this._socket) {
            this._socket.send(line);
        }
    };
    return WebSocketConnection;
}(Connection_1.default));
exports.default = WebSocketConnection;

},{"./Connection":8,"tslib":217,"universal-websocket-client":323}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Connection_1 = require("./Connection");
exports.Connection = Connection_1.default;
var DirectConnection_1 = require("./DirectConnection");
exports.DirectConnection = DirectConnection_1.default;
var WebSocketConnection_1 = require("./WebSocketConnection");
exports.WebSocketConnection = WebSocketConnection_1.default;

},{"./Connection":8,"./DirectConnection":9,"./WebSocketConnection":10}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LogLevel_1 = require("./LogLevel");
var isNode = require("detect-node");
var BaseLogger = /** @class */ (function () {
    function BaseLogger(_a) {
        var name = _a.name, _b = _a.minLevel, minLevel = _b === void 0 ? LogLevel_1.default.WARNING : _b, _c = _a.emoji, emoji = _c === void 0 ? false : _c, _d = _a.colors, colors = _d === void 0 ? true : _d, _e = _a.timestamps, timestamps = _e === void 0 ? isNode : _e;
        this._name = name;
        this._minLevel = LogLevel_1.resolveLogLevel(minLevel);
        this._emoji = emoji;
        this._colors = colors;
        this._timestamps = timestamps;
    }
    // region convenience methods
    BaseLogger.prototype.crit = function (message) {
        this.log(LogLevel_1.default.CRITICAL, message);
    };
    BaseLogger.prototype.critical = function (message) {
        this.log(LogLevel_1.default.CRITICAL, message);
    };
    BaseLogger.prototype.err = function (message) {
        this.log(LogLevel_1.default.ERROR, message);
    };
    BaseLogger.prototype.error = function (message) {
        this.log(LogLevel_1.default.ERROR, message);
    };
    BaseLogger.prototype.warn = function (message) {
        this.log(LogLevel_1.default.WARNING, message);
    };
    BaseLogger.prototype.warning = function (message) {
        this.log(LogLevel_1.default.WARNING, message);
    };
    BaseLogger.prototype.info = function (message) {
        this.log(LogLevel_1.default.INFO, message);
    };
    BaseLogger.prototype.debug = function (message) {
        this.log(LogLevel_1.default.DEBUG1, message);
    };
    BaseLogger.prototype.debug1 = function (message) {
        this.log(LogLevel_1.default.DEBUG1, message);
    };
    BaseLogger.prototype.debug2 = function (message) {
        this.log(LogLevel_1.default.DEBUG2, message);
    };
    BaseLogger.prototype.debug3 = function (message) {
        this.log(LogLevel_1.default.DEBUG3, message);
    };
    BaseLogger.prototype.trace = function (message) {
        this.log(LogLevel_1.default.TRACE, message);
    };
    return BaseLogger;
}());
exports.default = BaseLogger;

},{"./LogLevel":14,"detect-node":53}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var LogLevel_1 = require("./LogLevel");
var BaseLogger_1 = require("./BaseLogger");
var BrowserLogger = /** @class */ (function (_super) {
    tslib_1.__extends(BrowserLogger, _super);
    function BrowserLogger() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BrowserLogger.prototype.log = function (level, message) {
        if (level > this._minLevel) {
            return;
        }
        var logFn = LogLevel_1.LogLevelToConsoleFunction[level];
        var formattedMessage = "[" + this._name + "] " + message;
        if (this._timestamps) {
            formattedMessage = "[" + new Date().toISOString() + "] " + message;
        }
        logFn(formattedMessage);
    };
    return BrowserLogger;
}(BaseLogger_1.default));
exports.default = BrowserLogger;

},{"./BaseLogger":12,"./LogLevel":14,"tslib":217}],14:[function(require,module,exports){
"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
var isNode = require("detect-node");
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["CRITICAL"] = 0] = "CRITICAL";
    LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
    LogLevel[LogLevel["WARNING"] = 2] = "WARNING";
    LogLevel[LogLevel["INFO"] = 3] = "INFO";
    LogLevel[LogLevel["DEBUG1"] = 4] = "DEBUG1";
    LogLevel[LogLevel["DEBUG2"] = 5] = "DEBUG2";
    LogLevel[LogLevel["DEBUG3"] = 6] = "DEBUG3";
    LogLevel[LogLevel["TRACE"] = 7] = "TRACE";
})(LogLevel || (LogLevel = {}));
exports.default = LogLevel;
function resolveLogLevel(level) {
    if (typeof level === 'number') {
        return level;
    }
    var strLevel = level.toUpperCase();
    if (!Object.prototype.hasOwnProperty.call(LogLevel, strLevel)) {
        throw new Error("Unknown log level string: " + strLevel);
    }
    return LogLevel[strLevel];
}
exports.resolveLogLevel = resolveLogLevel;
// Node 8+ defines console.debug as noop, and earlier versions don't define it at all
var debugFunction = isNode ? console.log.bind(console) : console.debug.bind(console);
// tslint:disable-next-line:no-any
exports.LogLevelToConsoleFunction = (_a = {},
    _a[LogLevel.CRITICAL] = console.error.bind(console),
    _a[LogLevel.ERROR] = console.error.bind(console),
    _a[LogLevel.WARNING] = console.warn.bind(console),
    _a[LogLevel.INFO] = console.info.bind(console),
    _a[LogLevel.DEBUG1] = debugFunction.bind(console),
    _a[LogLevel.DEBUG2] = debugFunction.bind(console),
    _a[LogLevel.DEBUG3] = debugFunction.bind(console),
    _a[LogLevel.TRACE] = console.trace.bind(console),
    _a);

},{"detect-node":53}],15:[function(require,module,exports){
"use strict";
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var LogLevel_1 = require("./LogLevel");
var chalk = require("chalk");
var BaseLogger_1 = require("./BaseLogger");
exports.LogLevelToEmoji = (_a = {},
    _a[LogLevel_1.default.CRITICAL] = "\uD83D\uDED1",
    _a[LogLevel_1.default.ERROR] = "\u274C",
    // these following two need extra spaces at the end because somehow they consume less space in a terminal than they should...
    _a[LogLevel_1.default.WARNING] = "\u26A0\uFE0F ",
    _a[LogLevel_1.default.INFO] = "\u2139\uFE0F ",
    _a[LogLevel_1.default.DEBUG1] = "\uD83D\uDC1E",
    _a[LogLevel_1.default.DEBUG2] = "\uD83D\uDC1C",
    _a[LogLevel_1.default.DEBUG3] = "\uD83D\uDC1B",
    _a[LogLevel_1.default.TRACE] = "\uD83D\uDC3E",
    _a);
exports.LogLevelToColor = (_b = {},
    _b[LogLevel_1.default.CRITICAL] = chalk.red,
    _b[LogLevel_1.default.ERROR] = chalk.redBright,
    _b[LogLevel_1.default.WARNING] = chalk.yellow,
    _b[LogLevel_1.default.INFO] = chalk.blue,
    _b[LogLevel_1.default.DEBUG1] = chalk.magenta,
    _b[LogLevel_1.default.DEBUG2] = chalk.magenta,
    _b[LogLevel_1.default.DEBUG3] = chalk.magenta,
    _b[LogLevel_1.default.TRACE] = chalk.reset,
    _b);
exports.LogLevelToBackgroundColor = (_c = {},
    _c[LogLevel_1.default.CRITICAL] = chalk.bgRed.white,
    _c[LogLevel_1.default.ERROR] = chalk.bgRedBright.white,
    _c[LogLevel_1.default.WARNING] = chalk.bgYellow.black,
    _c[LogLevel_1.default.INFO] = chalk.bgBlue.white,
    _c[LogLevel_1.default.DEBUG1] = chalk.bgMagenta.black,
    _c[LogLevel_1.default.DEBUG2] = chalk.bgMagenta.black,
    _c[LogLevel_1.default.DEBUG3] = chalk.bgMagenta.black,
    _c[LogLevel_1.default.TRACE] = chalk.inverse,
    _c);
var NodeLogger = /** @class */ (function (_super) {
    tslib_1.__extends(NodeLogger, _super);
    function NodeLogger() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NodeLogger.prototype.log = function (level, message) {
        if (level > this._minLevel) {
            return;
        }
        var logFn = LogLevel_1.LogLevelToConsoleFunction[level];
        var builtMessage = '';
        if (this._timestamps) {
            builtMessage += "[" + new Date().toISOString() + "] ";
        }
        if (this._emoji) {
            var emoji = exports.LogLevelToEmoji[level];
            builtMessage += emoji + " ";
        }
        if (this._colors) {
            builtMessage += exports.LogLevelToBackgroundColor[level](this._name) + " " + exports.LogLevelToBackgroundColor[level](LogLevel_1.default[level]) + " " + exports.LogLevelToColor[level](message);
        }
        else {
            builtMessage += "[" + this._name + ":" + LogLevel_1.default[level].toLowerCase() + "] " + message;
        }
        logFn(builtMessage);
    };
    return NodeLogger;
}(BaseLogger_1.default));
exports.default = NodeLogger;

},{"./BaseLogger":12,"./LogLevel":14,"chalk":43,"tslib":217}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var isNode = require("detect-node");
var Logger = isNode ? require('./NodeLogger').default : require('./BrowserLogger').default;
exports.default = Logger;
var LogLevel_1 = require("./LogLevel");
exports.LogLevel = LogLevel_1.default;

},{"./BrowserLogger":13,"./LogLevel":14,"./NodeLogger":15,"detect-node":53}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/** @private */
var CustomError = /** @class */ (function (_super) {
    tslib_1.__extends(CustomError, _super);
    function CustomError() {
        var _newTarget = this.constructor;
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        var _this = _super.apply(this, tslib_1.__spread(params)) || this;
        // restore prototype chain
        var actualProto = _newTarget.prototype;
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(_this, actualProto);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            _this.__proto__ = actualProto;
        }
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, _newTarget.constructor);
        }
        return _this;
    }
    Object.defineProperty(CustomError.prototype, "name", {
        get: function () {
            return this.constructor.name;
        },
        enumerable: true,
        configurable: true
    });
    return CustomError;
}(Error));
exports.default = CustomError;

},{"tslib":217}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var allSettled = require("promise.allsettled");
var RetryAfterError_1 = require("./RetryAfterError");
var logger_1 = require("@d-fischer/logger");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var ResponseBasedRateLimiter = /** @class */ (function () {
    function ResponseBasedRateLimiter(logLevel) {
        this._queue = [];
        this._batchRunning = false;
        this._logger = new logger_1.default({ name: 'rate-limiter', minLevel: logLevel, emoji: true });
    }
    ResponseBasedRateLimiter.prototype.request = function (req) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var reqSpec = {
                            req: req,
                            resolve: resolve,
                            reject: reject
                        };
                        if (_this._batchRunning || _this._nextBatchTimer) {
                            _this._queue.push(reqSpec);
                        }
                        else {
                            _this._runRequestBatch([reqSpec]);
                        }
                    })];
            });
        });
    };
    ResponseBasedRateLimiter.prototype._runRequestBatch = function (reqSpecs) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var promises, settledPromises, rejectedPromises, now, retryAt, retryAfter, params, delay;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._batchRunning = true;
                        if (this._parameters) {
                            this._logger.debug1("remaining requests: " + this._parameters.remaining);
                        }
                        this._logger.debug2("doing " + reqSpecs.length + " requests, new queue length is " + this._queue.length);
                        promises = reqSpecs.map(function (reqSpec) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var req, resolve, reject, result, retry, params, e_1;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        req = reqSpec.req, resolve = reqSpec.resolve, reject = reqSpec.reject;
                                        _a.label = 1;
                                    case 1:
                                        _a.trys.push([1, 3, , 4]);
                                        return [4 /*yield*/, this.doRequest(req)];
                                    case 2:
                                        result = _a.sent();
                                        retry = this.needsToRetryAfter(result);
                                        if (retry !== null) {
                                            this._queue.unshift(reqSpec);
                                            this._logger.info("Retrying after " + retry + " ms");
                                            throw new RetryAfterError_1.default(retry);
                                        }
                                        params = this.getParametersFromResponse(result);
                                        resolve(result);
                                        return [2 /*return*/, params];
                                    case 3:
                                        e_1 = _a.sent();
                                        if (e_1 instanceof RetryAfterError_1.default) {
                                            throw e_1;
                                        }
                                        reject(e_1);
                                        return [2 /*return*/, undefined];
                                    case 4: return [2 /*return*/];
                                }
                            });
                        }); });
                        return [4 /*yield*/, allSettled(promises)];
                    case 1:
                        settledPromises = _a.sent();
                        rejectedPromises = settledPromises.filter(function (p) { return p.status === 'rejected'; });
                        now = Date.now();
                        if (rejectedPromises.length) {
                            retryAt = Math.max.apply(Math, tslib_1.__spread([now], rejectedPromises.map(function (p) { return p.reason.retryAt; })));
                            retryAfter = retryAt - now;
                            this._logger.warn("waiting for " + retryAfter + " ms because the rate limit was exceeded");
                            this._nextBatchTimer = setTimeout(function () {
                                _this._parameters = undefined;
                                _this._runNextBatch();
                            }, retryAfter);
                        }
                        else {
                            params = settledPromises
                                .map(function (p) { return p.value; })
                                .filter(function (v) { return v !== undefined; })
                                .reduce(function (carry, v) {
                                if (!carry) {
                                    return v;
                                }
                                // return v.resetsAt > carry.resetsAt ? v : carry;
                                return v.remaining < carry.remaining ? v : carry;
                            }, undefined);
                            this._batchRunning = false;
                            if (params) {
                                this._parameters = params;
                                if (params.resetsAt < now || params.remaining > 0) {
                                    this._runNextBatch();
                                }
                                else {
                                    delay = params.resetsAt - now;
                                    this._logger.warn("Waiting for " + delay + " ms because the rate limit was reached");
                                    this._nextBatchTimer = setTimeout(function () {
                                        _this._parameters = undefined;
                                        _this._runNextBatch();
                                    }, delay);
                                }
                            }
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    ResponseBasedRateLimiter.prototype._runNextBatch = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var amount, reqSpecs;
            return tslib_1.__generator(this, function (_a) {
                if (this._nextBatchTimer) {
                    clearTimeout(this._nextBatchTimer);
                    this._nextBatchTimer = undefined;
                }
                amount = this._parameters ? Math.min(this._parameters.remaining, this._parameters.limit / 10) : 1;
                reqSpecs = this._queue.splice(0, amount);
                if (reqSpecs.length) {
                    this._runRequestBatch(reqSpecs);
                }
                return [2 /*return*/];
            });
        });
    };
    return ResponseBasedRateLimiter;
}());
exports.default = ResponseBasedRateLimiter;

},{"./RetryAfterError":19,"@d-fischer/logger":16,"promise.allsettled":207,"tslib":217}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var CustomError_1 = require("./CustomError");
var RetryAfterError = /** @class */ (function (_super) {
    tslib_1.__extends(RetryAfterError, _super);
    function RetryAfterError(after) {
        var _this = _super.call(this, "Need to retry after " + after + " ms") || this;
        _this._retryAt = Date.now() + after;
        return _this;
    }
    Object.defineProperty(RetryAfterError.prototype, "retryAt", {
        get: function () {
            return this._retryAt;
        },
        enumerable: true,
        configurable: true
    });
    return RetryAfterError;
}(CustomError_1.default));
exports.default = RetryAfterError;

},{"./CustomError":17,"tslib":217}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ResponseBasedRateLimiter_1 = require("./ResponseBasedRateLimiter");
exports.ResponseBasedRateLimiter = ResponseBasedRateLimiter_1.default;
var RetryAfterError_1 = require("./RetryAfterError");
exports.RetryAfterError = RetryAfterError_1.default;

},{"./ResponseBasedRateLimiter":18,"./RetryAfterError":19}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function NonEnumerable(target, key) {
    // first property defined in prototype, that's why we use getters/setters
    // (otherwise assignment in object will override property in prototype)
    Object.defineProperty(target, key, {
        get: function () {
            return;
        },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        set: function (val) {
            // here we have a reference to the instance and can set property directly to it
            Object.defineProperty(this, key, {
                value: val,
                writable: true,
                enumerable: false
            });
        },
        enumerable: false
    });
}
exports.default = NonEnumerable;

},{}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
function flatten(arr) {
    var _a;
    return (_a = []).concat.apply(_a, tslib_1.__spread(arr));
}
exports.default = flatten;

},{"tslib":217}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
function resolveConfigValue(value) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        return tslib_1.__generator(this, function (_a) {
            if (typeof value === 'function') {
                return [2 /*return*/, value()];
            }
            return [2 /*return*/, value];
        });
    });
}
exports.default = resolveConfigValue;

},{"tslib":217}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var matched = function (x) { return ({
    otherwise: function () { return x; },
    on: function () { return matched(x); }
}); };
var match = function (x) { return ({
    on: function (predicate, fn) { return (predicate(x) ? matched(fn(x)) : match(x)); },
    otherwise: function (fn) { return fn(x); }
}); };
exports.eq = function (x) { return function (y) { return x === y; }; };
match.eq = exports.eq;
exports.default = match;

},{}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
function arrayToObject(arr, fn) {
    return Object.assign.apply(Object, tslib_1.__spread([{}], arr.map(fn)));
}
exports.default = arrayToObject;

},{"tslib":217}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var arrayToObject_1 = require("./arrayToObject");
function entriesToObject(obj) {
    return arrayToObject_1.default(obj, function (_a) {
        var _b;
        var _c = tslib_1.__read(_a, 2), key = _c[0], val = _c[1];
        return (_b = {}, _b[key] = val, _b);
    });
}
exports.default = entriesToObject;

},{"./arrayToObject":25,"tslib":217}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
function forEachObjectEntry(obj, fn) {
    Object.entries(obj).forEach(function (_a) {
        var _b = tslib_1.__read(_a, 2), key = _b[0], value = _b[1];
        return fn(value, key);
    });
}
exports.default = forEachObjectEntry;

},{"tslib":217}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var arrayToObject_1 = require("./arrayToObject");
function indexBy(arr, keyFn) {
    if (typeof keyFn !== 'function') {
        var key_1 = keyFn;
        keyFn = (function (value) { return value[key_1].toString(); });
    }
    return arrayToObject_1.default(arr, function (val) {
        var _a;
        return (_a = {}, _a[keyFn(val)] = val, _a);
    });
}
exports.default = indexBy;

},{"./arrayToObject":25}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
function mapObject(obj, fn) {
    var mapped = Object.entries(obj).map(
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    function (_a) {
        var _b;
        var _c = tslib_1.__read(_a, 2), key = _c[0], value = _c[1];
        return (_b = {}, _b[key] = fn(value, key), _b);
    });
    return Object.assign.apply(Object, tslib_1.__spread([{}], mapped));
}
exports.default = mapObject;

},{"tslib":217}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var pick_1 = require("./pick");
var omit = function (obj, keys) {
    return pick_1.default(obj, Object.keys(obj).filter(function (key) { return !keys.includes(key); }));
};
exports.default = omit;

},{"./pick":31}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var pick = function (obj, keys) {
    return Object.assign.apply(Object, tslib_1.__spread([{}], Object.entries(obj)
        .filter(function (_a) {
        var _b = tslib_1.__read(_a, 1), key = _b[0];
        return keys.includes(key);
    })
        .map(function (_a) {
        var _b;
        var _c = tslib_1.__read(_a, 2), key = _c[0], value = _c[1];
        return (_b = {}, _b[key] = value, _b);
    })));
};
exports.default = pick;

},{"tslib":217}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function padLeft(str, length, padding) {
    if (typeof str === 'number') {
        str = str.toString();
    }
    length = length - str.length;
    if (length <= 0) {
        return str;
    }
    if (padding === undefined) {
        padding = ' ';
    }
    var paddingStr = '';
    do {
        /* eslint-disable no-bitwise */
        if ((length & 1) === 1) {
            paddingStr += padding;
        }
        length >>= 1;
        if (length) {
            padding += padding;
        }
        /* eslint-enable no-bitwise */
    } while (length);
    return paddingStr + str;
}
exports.default = padLeft;

},{}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
function splitWithLimit(str, delim, count) {
    var parts = str.split(delim);
    if (parts.length <= count) {
        return parts;
    }
    return tslib_1.__spread(parts.slice(0, count - 1), [parts.slice(count - 1).join(delim)]);
}
exports.default = splitWithLimit;

},{"tslib":217}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
function utf8Length(str) {
    return tslib_1.__spread(str).length;
}
exports.default = utf8Length;

},{"tslib":217}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
function utf8Substring(str, start, end) {
    return tslib_1.__spread(str).slice(start, end).join('');
}
exports.default = utf8Substring;

},{"tslib":217}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var NonEnumerable_1 = require("./decorators/NonEnumerable");
exports.NonEnumerable = NonEnumerable_1.default;
var flatten_1 = require("./functions/array/flatten");
exports.flatten = flatten_1.default;
var resolveConfigValue_1 = require("./functions/config/resolveConfigValue");
exports.resolveConfigValue = resolveConfigValue_1.default;
var match_1 = require("./functions/match/match");
exports.match = match_1.default;
exports.eq = match_1.eq;
var arrayToObject_1 = require("./functions/object/arrayToObject");
exports.arrayToObject = arrayToObject_1.default;
var entriesToObject_1 = require("./functions/object/entriesToObject");
exports.entriesToObject = entriesToObject_1.default;
var forEachObjectEntry_1 = require("./functions/object/forEachObjectEntry");
exports.forEachObjectEntry = forEachObjectEntry_1.default;
var indexBy_1 = require("./functions/object/indexBy");
exports.indexBy = indexBy_1.default;
var mapObject_1 = require("./functions/object/mapObject");
exports.mapObject = mapObject_1.default;
var omit_1 = require("./functions/object/omit");
exports.omit = omit_1.default;
var pick_1 = require("./functions/object/pick");
exports.pick = pick_1.default;
var padLeft_1 = require("./functions/string/padLeft");
exports.padLeft = padLeft_1.default;
var splitWithLimit_1 = require("./functions/string/splitWithLimit");
exports.splitWithLimit = splitWithLimit_1.default;
var utf8Length_1 = require("./functions/string/utf8Length");
exports.utf8Length = utf8Length_1.default;
var utf8Substring_1 = require("./functions/string/utf8Substring");
exports.utf8Substring = utf8Substring_1.default;

},{"./decorators/NonEnumerable":21,"./functions/array/flatten":22,"./functions/config/resolveConfigValue":23,"./functions/match/match":24,"./functions/object/arrayToObject":25,"./functions/object/entriesToObject":26,"./functions/object/forEachObjectEntry":27,"./functions/object/indexBy":28,"./functions/object/mapObject":29,"./functions/object/omit":30,"./functions/object/pick":31,"./functions/string/padLeft":32,"./functions/string/splitWithLimit":33,"./functions/string/utf8Length":34,"./functions/string/utf8Substring":35}],37:[function(require,module,exports){
"use strict";
/******************************************************************************
 * The MIT License (MIT)                                                      *
 *                                                                            *
 * Copyright (c) 2016 Simon "Tenry" Burchert                                  *
 *                                                                            *
 * Permission is hereby granted, free of charge, to any person obtaining a    *
 * copy of this software and associated documentation files (the "Software"), *
 * to deal in the Software without restriction, including without limitation  *
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,   *
 * and/or sell copies of the Software, and to permit persons to whom the      *
 * Software is furnished to do so, subject to the following conditions:       *
 *                                                                            *
 * The above copyright notice and this permission notice shall be included in *
 * all copies or substantial portions of the Software.                        *
 *                                                                            *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR *
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   *
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    *
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER *
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    *
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        *
 * EALINGS IN THE SOFTWARE.                                                   *
 ******************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this.eventListeners = new Map();
    }
    EventEmitter.prototype.on = function (event, listener) {
        if (!this.eventListeners.has(event)) {
            this.eventListeners.set(event, [listener]);
        }
        else {
            this.eventListeners.get(event).push(listener);
        }
        return new Listener(this, event, listener);
    };
    EventEmitter.prototype.addListener = function (event, listener) {
        return this.on(event, listener);
    };
    EventEmitter.prototype.removeListener = function () {
        if (arguments.length == 0) {
            this.eventListeners.clear();
        }
        else if (arguments.length == 1 && typeof arguments[0] == 'object') {
            var id = arguments[0];
            this.removeListener(id.event, id.listener);
        }
        else if (arguments.length >= 1) {
            var event = arguments[0];
            var listener = arguments[1];
            if (this.eventListeners.has(event)) {
                var listeners = this.eventListeners.get(event);
                var idx;
                while (!listener || (idx = listeners.indexOf(listener)) != -1) {
                    listeners.splice(idx, 1);
                }
            }
        }
    };
    /**
     * Emit event. Calls all bound listeners with args.
     */
    EventEmitter.prototype.emit = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.eventListeners.has(event)) {
            for (var _a = 0, _b = this.eventListeners.get(event); _a < _b.length; _a++) {
                var listener = _b[_a];
                listener.apply(void 0, args);
            }
        }
    };
    /**
     * @typeparam T The event handler signature.
     */
    EventEmitter.prototype.registerEvent = function () {
        var _this = this;
        var eventBinder = function (handler) {
            return _this.addListener(eventBinder, handler);
        };
        return eventBinder;
    };
    return EventEmitter;
}());
exports.EventEmitter = EventEmitter;
var Listener = /** @class */ (function () {
    function Listener(owner, event, listener) {
        this.owner = owner;
        this.event = event;
        this.listener = listener;
    }
    Listener.prototype.unbind = function () {
        this.owner.removeListener(this);
    };
    return Listener;
}());
exports.Listener = Listener;

},{}],38:[function(require,module,exports){
'use strict';

const wrapAnsi16 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => (...args) => {
	const code = fn(...args);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => (...args) => {
	const rgb = fn(...args);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

const ansi2ansi = n => n;
const rgb2rgb = (r, g, b) => [r, g, b];

const setLazyProperty = (object, property, get) => {
	Object.defineProperty(object, property, {
		get: () => {
			const value = get();

			Object.defineProperty(object, property, {
				value,
				enumerable: true,
				configurable: true
			});

			return value;
		},
		enumerable: true,
		configurable: true
	});
};

/** @type {typeof import('color-convert')} */
let colorConvert;
const makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
	if (colorConvert === undefined) {
		colorConvert = require('color-convert');
	}

	const offset = isBackground ? 10 : 0;
	const styles = {};

	for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
		const name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;
		if (sourceSpace === targetSpace) {
			styles[name] = wrap(identity, offset);
		} else if (typeof suite === 'object') {
			styles[name] = wrap(suite[targetSpace], offset);
		}
	}

	return styles;
};

function assembleStyles() {
	const codes = new Map();
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],

			// Bright color
			blackBright: [90, 39],
			redBright: [91, 39],
			greenBright: [92, 39],
			yellowBright: [93, 39],
			blueBright: [94, 39],
			magentaBright: [95, 39],
			cyanBright: [96, 39],
			whiteBright: [97, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49],

			// Bright color
			bgBlackBright: [100, 49],
			bgRedBright: [101, 49],
			bgGreenBright: [102, 49],
			bgYellowBright: [103, 49],
			bgBlueBright: [104, 49],
			bgMagentaBright: [105, 49],
			bgCyanBright: [106, 49],
			bgWhiteBright: [107, 49]
		}
	};

	// Alias bright black as gray (and grey)
	styles.color.gray = styles.color.blackBright;
	styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
	styles.color.grey = styles.color.blackBright;
	styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;

	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	}

	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false
	});

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	setLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));
	setLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));
	setLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));
	setLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));

	return styles;
}

// Make the export immutable
Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});

},{"color-convert":48}],39:[function(require,module,exports){
'use strict';

var ArraySpeciesCreate = require('es-abstract/2019/ArraySpeciesCreate');
var Call = require('es-abstract/2019/Call');
var CreateDataPropertyOrThrow = require('es-abstract/2019/CreateDataPropertyOrThrow');
var Get = require('es-abstract/2019/Get');
var HasProperty = require('es-abstract/2019/HasProperty');
var IsCallable = require('es-abstract/2019/IsCallable');
var ToUint32 = require('es-abstract/2019/ToUint32');
var ToObject = require('es-abstract/2019/ToObject');
var ToString = require('es-abstract/2019/ToString');
var callBound = require('es-abstract/helpers/callBound');
var isString = require('is-string');

// Check failure of by-index access of string characters (IE < 9) and failure of `0 in boxedString` (Rhino)
var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var strSplit = callBound('String.prototype.split');

module.exports = function map(callbackfn) {
	var O = ToObject(this);
	var self = splitString && isString(O) ? strSplit(O, '') : O;
	var len = ToUint32(self.length);

	// If no callback function or if callback is not a callable function
	if (!IsCallable(callbackfn)) {
		throw new TypeError('Array.prototype.map callback must be a function');
	}

	var T;
	if (arguments.length > 1) {
		T = arguments[1];
	}

	var A = ArraySpeciesCreate(O, len);
	var k = 0;
	while (k < len) {
		var Pk = ToString(k);
		var kPresent = HasProperty(O, Pk);
		if (kPresent) {
			var kValue = Get(O, Pk);
			var mappedValue = Call(callbackfn, T, [kValue, k, O]);
			CreateDataPropertyOrThrow(A, Pk, mappedValue);
		}
		k += 1;
	}

	return A;
};

},{"es-abstract/2019/ArraySpeciesCreate":54,"es-abstract/2019/Call":55,"es-abstract/2019/CreateDataPropertyOrThrow":57,"es-abstract/2019/Get":59,"es-abstract/2019/HasProperty":60,"es-abstract/2019/IsCallable":62,"es-abstract/2019/ToObject":75,"es-abstract/2019/ToString":78,"es-abstract/2019/ToUint32":79,"es-abstract/helpers/callBound":87,"is-string":198}],40:[function(require,module,exports){
'use strict';

var define = require('define-properties');
var RequireObjectCoercible = require('es-abstract/2019/RequireObjectCoercible');
var callBound = require('es-abstract/helpers/callBound');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var polyfill = getPolyfill();
var shim = require('./shim');

var $slice = callBound('Array.prototype.slice');

// eslint-disable-next-line no-unused-vars
var boundMapShim = function map(array, callbackfn) {
	RequireObjectCoercible(array);
	return polyfill.apply(array, $slice(arguments, 1));
};
define(boundMapShim, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = boundMapShim;

},{"./implementation":39,"./polyfill":41,"./shim":42,"define-properties":51,"es-abstract/2019/RequireObjectCoercible":71,"es-abstract/helpers/callBound":87}],41:[function(require,module,exports){
'use strict';

var arrayMethodBoxesProperly = require('es-array-method-boxes-properly');

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	var method = Array.prototype.map;
	return arrayMethodBoxesProperly(method) ? method : implementation;
};

},{"./implementation":39,"es-array-method-boxes-properly":93}],42:[function(require,module,exports){
'use strict';

var define = require('define-properties');
var getPolyfill = require('./polyfill');

module.exports = function shimArrayPrototypeMap() {
	var polyfill = getPolyfill();
	define(
		Array.prototype,
		{ map: polyfill },
		{ map: function () { return Array.prototype.map !== polyfill; } }
	);
	return polyfill;
};

},{"./polyfill":41,"define-properties":51}],43:[function(require,module,exports){
'use strict';
const ansiStyles = require('ansi-styles');
const {stdout: stdoutColor, stderr: stderrColor} = require('supports-color');
const {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
} = require('./util');

// `supportsColor.level`  `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m'
];

const styles = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level > 3 || options.level < 0) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

class ChalkClass {
	constructor(options) {
		return chalkFactory(options);
	}
}

const chalkFactory = options => {
	const chalk = {};
	applyOptions(chalk, options);

	chalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);

	Object.setPrototypeOf(chalk, Chalk.prototype);
	Object.setPrototypeOf(chalk.template, chalk);

	chalk.template.constructor = () => {
		throw new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
	};

	chalk.template.Instance = ChalkClass;

	return chalk.template;
};

function Chalk(options) {
	return chalkFactory(options);
}

for (const [styleName, style] of Object.entries(ansiStyles)) {
	styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		}
	};
}

styles.visible = {
	get() {
		const builder = createBuilder(this, this._styler, true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	}
};

const usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];

for (const model of usedModels) {
	styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

for (const model of usedModels) {
	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
				return createBuilder(this, styler, this._isEmpty);
			};
		}
	};
}

const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this._generator.level;
		},
		set(level) {
			this._generator.level = level;
		}
	}
});

const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent
	};
};

const createBuilder = (self, _styler, _isEmpty) => {
	const builder = (...arguments_) => {
		// Single argument is hot path, implicit coercion is faster than anything
		// eslint-disable-next-line no-implicit-coercion
		return applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));
	};

	// `__proto__` is used because we must return a function, but there is
	// no way to create a function with a different prototype
	builder.__proto__ = proto; // eslint-disable-line no-proto

	builder._generator = self;
	builder._styler = _styler;
	builder._isEmpty = _isEmpty;

	return builder;
};

const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self._isEmpty ? '' : string;
	}

	let styler = self._styler;

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.indexOf('\u001B') !== -1) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = stringReplaceAll(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

let template;
const chalkTag = (chalk, ...strings) => {
	const [firstString] = strings;

	if (!Array.isArray(firstString)) {
		// If chalk() was called by itself or with a string,
		// return the string itself as a string.
		return strings.join(' ');
	}

	const arguments_ = strings.slice(1);
	const parts = [firstString.raw[0]];

	for (let i = 1; i < firstString.length; i++) {
		parts.push(
			String(arguments_[i - 1]).replace(/[{}\\]/g, '\\$&'),
			String(firstString.raw[i])
		);
	}

	if (template === undefined) {
		template = require('./templates');
	}

	return template(chalk, parts.join(''));
};

Object.defineProperties(Chalk.prototype, styles);

const chalk = Chalk(); // eslint-disable-line new-cap
chalk.supportsColor = stdoutColor;
chalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap
chalk.stderr.supportsColor = stderrColor;

// For TypeScript
chalk.Level = {
	None: 0,
	Basic: 1,
	Ansi256: 2,
	TrueColor: 3,
	0: 'None',
	1: 'Basic',
	2: 'Ansi256',
	3: 'TrueColor'
};

module.exports = chalk;

},{"./templates":44,"./util":45,"ansi-styles":38,"supports-color":216}],44:[function(require,module,exports){
'use strict';
const TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
const ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.)|([^\\])/gi;

const ESCAPES = new Map([
	['n', '\n'],
	['r', '\r'],
	['t', '\t'],
	['b', '\b'],
	['f', '\f'],
	['v', '\v'],
	['0', '\0'],
	['\\', '\\'],
	['e', '\u001B'],
	['a', '\u0007']
]);

function unescape(c) {
	const u = c[0] === 'u';
	const bracket = c[1] === '{';

	if ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {
		return String.fromCharCode(parseInt(c.slice(1), 16));
	}

	if (u && bracket) {
		return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
	}

	return ESCAPES.get(c) || c;
}

function parseArguments(name, arguments_) {
	const results = [];
	const chunks = arguments_.trim().split(/\s*,\s*/g);
	let matches;

	for (const chunk of chunks) {
		const number = Number(chunk);
		if (!Number.isNaN(number)) {
			results.push(number);
		} else if ((matches = chunk.match(STRING_REGEX))) {
			results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
		} else {
			throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
		}
	}

	return results;
}

function parseStyle(style) {
	STYLE_REGEX.lastIndex = 0;

	const results = [];
	let matches;

	while ((matches = STYLE_REGEX.exec(style)) !== null) {
		const name = matches[1];

		if (matches[2]) {
			const args = parseArguments(name, matches[2]);
			results.push([name].concat(args));
		} else {
			results.push([name]);
		}
	}

	return results;
}

function buildStyle(chalk, styles) {
	const enabled = {};

	for (const layer of styles) {
		for (const style of layer.styles) {
			enabled[style[0]] = layer.inverse ? null : style.slice(1);
		}
	}

	let current = chalk;
	for (const [styleName, styles] of Object.entries(enabled)) {
		if (!Array.isArray(styles)) {
			continue;
		}

		if (!(styleName in current)) {
			throw new Error(`Unknown Chalk style: ${styleName}`);
		}

		current = styles.length > 0 ? current[styleName](...styles) : current[styleName];
	}

	return current;
}

module.exports = (chalk, temporary) => {
	const styles = [];
	const chunks = [];
	let chunk = [];

	// eslint-disable-next-line max-params
	temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
		if (escapeCharacter) {
			chunk.push(unescape(escapeCharacter));
		} else if (style) {
			const string = chunk.join('');
			chunk = [];
			chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
			styles.push({inverse, styles: parseStyle(style)});
		} else if (close) {
			if (styles.length === 0) {
				throw new Error('Found extraneous } in Chalk template literal');
			}

			chunks.push(buildStyle(chalk, styles)(chunk.join('')));
			chunk = [];
			styles.pop();
		} else {
			chunk.push(character);
		}
	});

	chunks.push(chunk.join(''));

	if (styles.length > 0) {
		const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`;
		throw new Error(errMsg);
	}

	return chunks.join('');
};

},{}],45:[function(require,module,exports){
'use strict';

const stringReplaceAll = (string, substring, replacer) => {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}

	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

const stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\r';
		returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
		endIndex = index + 1;
		index = string.indexOf('\n', endIndex);
	} while (index !== -1);

	returnValue += string.substr(endIndex);
	return returnValue;
};

module.exports = {
	stringReplaceAll,
	stringEncaseCRLFWithFirstIndex
};

},{}],46:[function(require,module,exports){
(function (Buffer){
var clone = (function() {
'use strict';

function _instanceof(obj, type) {
  return type != null && obj instanceof type;
}

var nativeMap;
try {
  nativeMap = Map;
} catch(_) {
  // maybe a reference error because no `Map`. Give it a dummy value that no
  // value will ever be an instanceof.
  nativeMap = function() {};
}

var nativeSet;
try {
  nativeSet = Set;
} catch(_) {
  nativeSet = function() {};
}

var nativePromise;
try {
  nativePromise = Promise;
} catch(_) {
  nativePromise = function() {};
}

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
 *    should be cloned as well. Non-enumerable properties on the prototype
 *    chain will be ignored. (optional - false by default)
*/
function clone(parent, circular, depth, prototype, includeNonEnumerable) {
  if (typeof circular === 'object') {
    depth = circular.depth;
    prototype = circular.prototype;
    includeNonEnumerable = circular.includeNonEnumerable;
    circular = circular.circular;
  }
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth === 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (_instanceof(parent, nativeMap)) {
      child = new nativeMap();
    } else if (_instanceof(parent, nativeSet)) {
      child = new nativeSet();
    } else if (_instanceof(parent, nativePromise)) {
      child = new nativePromise(function (resolve, reject) {
        parent.then(function(value) {
          resolve(_clone(value, depth - 1));
        }, function(err) {
          reject(_clone(err, depth - 1));
        });
      });
    } else if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      if (Buffer.allocUnsafe) {
        // Node.js >= 4.5.0
        child = Buffer.allocUnsafe(parent.length);
      } else {
        // Older Node.js versions
        child = new Buffer(parent.length);
      }
      parent.copy(child);
      return child;
    } else if (_instanceof(parent, Error)) {
      child = Object.create(parent);
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    if (_instanceof(parent, nativeMap)) {
      parent.forEach(function(value, key) {
        var keyChild = _clone(key, depth - 1);
        var valueChild = _clone(value, depth - 1);
        child.set(keyChild, valueChild);
      });
    }
    if (_instanceof(parent, nativeSet)) {
      parent.forEach(function(value) {
        var entryChild = _clone(value, depth - 1);
        child.add(entryChild);
      });
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }

      if (attrs && attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(parent);
      for (var i = 0; i < symbols.length; i++) {
        // Don't need to worry about cloning a symbol because it is a primitive,
        // like a number or string.
        var symbol = symbols[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
          continue;
        }
        child[symbol] = _clone(parent[symbol], depth - 1);
        if (!descriptor.enumerable) {
          Object.defineProperty(child, symbol, {
            enumerable: false
          });
        }
      }
    }

    if (includeNonEnumerable) {
      var allPropertyNames = Object.getOwnPropertyNames(parent);
      for (var i = 0; i < allPropertyNames.length; i++) {
        var propertyName = allPropertyNames[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
        if (descriptor && descriptor.enumerable) {
          continue;
        }
        child[propertyName] = _clone(parent[propertyName], depth - 1);
        Object.defineProperty(child, propertyName, {
          enumerable: false
        });
      }
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

// private utility functions

function __objToStr(o) {
  return Object.prototype.toString.call(o);
}
clone.__objToStr = __objToStr;

function __isDate(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Date]';
}
clone.__isDate = __isDate;

function __isArray(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Array]';
}
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
}
clone.__isRegExp = __isRegExp;

function __getRegExpFlags(re) {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
}
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();

if (typeof module === 'object' && module.exports) {
  module.exports = clone;
}

}).call(this,require("buffer").Buffer)
},{"buffer":327}],47:[function(require,module,exports){
/* MIT license */
/* eslint-disable no-mixed-operators */
const cssKeywords = require('color-name');

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

const reverseKeywords = {};
for (const key of Object.keys(cssKeywords)) {
	reverseKeywords[cssKeywords[key]] = key;
}

const convert = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

module.exports = convert;

// Hide .channels and .labels properties
for (const model of Object.keys(convert)) {
	if (!('channels' in convert[model])) {
		throw new Error('missing channels property: ' + model);
	}

	if (!('labels' in convert[model])) {
		throw new Error('missing channel labels property: ' + model);
	}

	if (convert[model].labels.length !== convert[model].channels) {
		throw new Error('channel and label counts mismatch: ' + model);
	}

	const {channels, labels} = convert[model];
	delete convert[model].channels;
	delete convert[model].labels;
	Object.defineProperty(convert[model], 'channels', {value: channels});
	Object.defineProperty(convert[model], 'labels', {value: labels});
}

convert.rgb.hsl = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const min = Math.min(r, g, b);
	const max = Math.max(r, g, b);
	const delta = max - min;
	let h;
	let s;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	const l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	let rdif;
	let gdif;
	let bdif;
	let h;
	let s;

	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const v = Math.max(r, g, b);
	const diff = v - Math.min(r, g, b);
	const diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = 0;
		s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}

		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	const r = rgb[0];
	const g = rgb[1];
	let b = rgb[2];
	const h = convert.rgb.hsl(rgb)[0];
	const w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;

	const k = Math.min(1 - r, 1 - g, 1 - b);
	const c = (1 - r - k) / (1 - k) || 0;
	const m = (1 - g - k) / (1 - k) || 0;
	const y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

function comparativeDistance(x, y) {
	/*
		See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
	*/
	return (
		((x[0] - y[0]) ** 2) +
		((x[1] - y[1]) ** 2) +
		((x[2] - y[2]) ** 2)
	);
}

convert.rgb.keyword = function (rgb) {
	const reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	let currentClosestDistance = Infinity;
	let currentClosestKeyword;

	for (const keyword of Object.keys(cssKeywords)) {
		const value = cssKeywords[keyword];

		// Compute comparative distance
		const distance = comparativeDistance(rgb, value);

		// Check if its less, if so set as closest
		if (distance < currentClosestDistance) {
			currentClosestDistance = distance;
			currentClosestKeyword = keyword;
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	let r = rgb[0] / 255;
	let g = rgb[1] / 255;
	let b = rgb[2] / 255;

	// Assume sRGB
	r = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);
	g = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);
	b = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);

	const x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	const y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	const z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	const xyz = convert.rgb.xyz(rgb);
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	const h = hsl[0] / 360;
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;
	let t2;
	let t3;
	let val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	const t1 = 2 * l - t2;

	const rgb = [0, 0, 0];
	for (let i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}

		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	const h = hsl[0];
	let s = hsl[1] / 100;
	let l = hsl[2] / 100;
	let smin = s;
	const lmin = Math.max(l, 0.01);

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	const v = (l + s) / 2;
	const sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	const h = hsv[0] / 60;
	const s = hsv[1] / 100;
	let v = hsv[2] / 100;
	const hi = Math.floor(h) % 6;

	const f = h - Math.floor(h);
	const p = 255 * v * (1 - s);
	const q = 255 * v * (1 - (s * f));
	const t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	const h = hsv[0];
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;
	const vmin = Math.max(v, 0.01);
	let sl;
	let l;

	l = (2 - s) * v;
	const lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	const h = hwb[0] / 360;
	let wh = hwb[1] / 100;
	let bl = hwb[2] / 100;
	const ratio = wh + bl;
	let f;

	// Wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	const i = Math.floor(6 * h);
	const v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	const n = wh + f * (v - wh); // Linear interpolation

	let r;
	let g;
	let b;
	/* eslint-disable max-statements-per-line,no-multi-spaces */
	switch (i) {
		default:
		case 6:
		case 0: r = v;  g = n;  b = wh; break;
		case 1: r = n;  g = v;  b = wh; break;
		case 2: r = wh; g = v;  b = n; break;
		case 3: r = wh; g = n;  b = v; break;
		case 4: r = n;  g = wh; b = v; break;
		case 5: r = v;  g = wh; b = n; break;
	}
	/* eslint-enable max-statements-per-line,no-multi-spaces */

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	const c = cmyk[0] / 100;
	const m = cmyk[1] / 100;
	const y = cmyk[2] / 100;
	const k = cmyk[3] / 100;

	const r = 1 - Math.min(1, c * (1 - k) + k);
	const g = 1 - Math.min(1, m * (1 - k) + k);
	const b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	const x = xyz[0] / 100;
	const y = xyz[1] / 100;
	const z = xyz[2] / 100;
	let r;
	let g;
	let b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// Assume sRGB
	r = r > 0.0031308
		? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	let x = xyz[0];
	let y = xyz[1];
	let z = xyz[2];

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);

	const l = (116 * y) - 16;
	const a = 500 * (x - y);
	const b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let x;
	let y;
	let z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	const y2 = y ** 3;
	const x2 = x ** 3;
	const z2 = z ** 3;
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	const l = lab[0];
	const a = lab[1];
	const b = lab[2];
	let h;

	const hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	const c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	const l = lch[0];
	const c = lch[1];
	const h = lch[2];

	const hr = h / 360 * 2 * Math.PI;
	const a = c * Math.cos(hr);
	const b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args, saturation = null) {
	const [r, g, b] = args;
	let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	let ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// Optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	const r = args[0];
	const g = args[1];
	const b = args[2];

	// We use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	const ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	let color = args % 10;

	// Handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	const mult = (~~(args > 50) + 1) * 0.5;
	const r = ((color & 1) * mult) * 255;
	const g = (((color >> 1) & 1) * mult) * 255;
	const b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// Handle greyscale
	if (args >= 232) {
		const c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	let rem;
	const r = Math.floor(args / 36) / 5 * 255;
	const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	const b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	const integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	let colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(char => {
			return char + char;
		}).join('');
	}

	const integer = parseInt(colorString, 16);
	const r = (integer >> 16) & 0xFF;
	const g = (integer >> 8) & 0xFF;
	const b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	const r = rgb[0] / 255;
	const g = rgb[1] / 255;
	const b = rgb[2] / 255;
	const max = Math.max(Math.max(r, g), b);
	const min = Math.min(Math.min(r, g), b);
	const chroma = (max - min);
	let grayscale;
	let hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	const s = hsl[1] / 100;
	const l = hsl[2] / 100;

	const c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));

	let f = 0;
	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	const s = hsv[1] / 100;
	const v = hsv[2] / 100;

	const c = s * v;
	let f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	const h = hcg[0] / 360;
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	const pure = [0, 0, 0];
	const hi = (h % 1) * 6;
	const v = hi % 1;
	const w = 1 - v;
	let mg = 0;

	/* eslint-disable max-statements-per-line */
	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}
	/* eslint-enable max-statements-per-line */

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const v = c + g * (1.0 - c);
	let f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;

	const l = g * (1.0 - c) + 0.5 * c;
	let s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	const c = hcg[1] / 100;
	const g = hcg[2] / 100;
	const v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	const w = hwb[1] / 100;
	const b = hwb[2] / 100;
	const v = 1 - b;
	const c = v - w;
	let g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hsv = convert.gray.hsl;

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	const val = Math.round(gray[0] / 100 * 255) & 0xFF;
	const integer = (val << 16) + (val << 8) + val;

	const string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};

},{"color-name":50}],48:[function(require,module,exports){
const conversions = require('./conversions');
const route = require('./route');

const convert = {};

const models = Object.keys(conversions);

function wrapRaw(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];
		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		return fn(args);
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	const wrappedFn = function (...args) {
		const arg0 = args[0];

		if (arg0 === undefined || arg0 === null) {
			return arg0;
		}

		if (arg0.length > 1) {
			args = arg0;
		}

		const result = fn(args);

		// We're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (let len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// Preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(fromModel => {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	const routes = route(fromModel);
	const routeModels = Object.keys(routes);

	routeModels.forEach(toModel => {
		const fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;

},{"./conversions":47,"./route":49}],49:[function(require,module,exports){
const conversions = require('./conversions');

/*
	This function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	const graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	const models = Object.keys(conversions);

	for (let len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	const graph = buildGraph();
	const queue = [fromModel]; // Unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		const current = queue.pop();
		const adjacents = Object.keys(conversions[current]);

		for (let len = adjacents.length, i = 0; i < len; i++) {
			const adjacent = adjacents[i];
			const node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	const path = [graph[toModel].parent, toModel];
	let fn = conversions[graph[toModel].parent][toModel];

	let cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	const graph = deriveBFS(fromModel);
	const conversion = {};

	const models = Object.keys(graph);
	for (let len = models.length, i = 0; i < len; i++) {
		const toModel = models[i];
		const node = graph[toModel];

		if (node.parent === null) {
			// No possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};


},{"./conversions":47}],50:[function(require,module,exports){
'use strict'

module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

},{}],51:[function(require,module,exports){
'use strict';

var keys = require('object-keys');
var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';

var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		origDefineProperty(obj, 'x', { enumerable: false, value: obj });
		// eslint-disable-next-line no-unused-vars, no-restricted-syntax
		for (var _ in obj) { // jscs:ignore disallowUnusedVariables
			return false;
		}
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		origDefineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = concat.call(props, Object.getOwnPropertySymbols(map));
	}
	for (var i = 0; i < props.length; i += 1) {
		defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
	}
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;

},{"object-keys":204}],52:[function(require,module,exports){
(function (process){
var isWindows = typeof process != 'undefined' && 'win32' === process.platform
var EOL = isWindows ? '\r\n' : '\n'

var hits = {};

function deprecate(methodName, message) {
  if(deprecate.silence || hits[methodName]) return;
  hits[methodName] = true;

  var _deprecate = typeof process === 'undefined' ? browserDeprecate : nodeDeprecate;
  _deprecate(methodName, message);
}

function nodeDeprecate(methodName, message) {
  deprecate.stream.write(EOL);
  if(deprecate.color) {
    deprecate.stream.write(deprecate.color);
  }
  deprecate.stream.write('Warning: ' + methodName + ' has been deprecated.');
  deprecate.stream.write(EOL);
  for(var i = 1; i < arguments.length; i++) {
    deprecate.stream.write(arguments[i]);
    deprecate.stream.write(EOL);
  }
  if(deprecate.color) {
    deprecate.stream.write('\x1b[0m');
  }
  deprecate.stream.write(EOL);
  deprecate.stream.write(EOL);
};

function browserDeprecate(methodName, message) {
  console.warn(methodName, ' has been deprecated.');
  for(var i = 1; i < arguments.length; i++) {
    console.log(arguments[i]);
  }
}

if (typeof process !== 'undefined' && typeof process.stderr !== 'undefined') {
  deprecate.stream = process.stderr;
  deprecate.color = deprecate.stream.isTTY && '\x1b[31;1m';
}
deprecate.silence = false;

module.exports = deprecate;

}).call(this,require('_process'))
},{"_process":330}],53:[function(require,module,exports){
module.exports = false;


},{}],54:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $Array = GetIntrinsic('%Array%');
var $species = GetIntrinsic('%Symbol.species%', true);
var $TypeError = GetIntrinsic('%TypeError%');

var Get = require('./Get');
var IsArray = require('./IsArray');
var IsConstructor = require('./IsConstructor');
var IsInteger = require('./IsInteger');
var Type = require('./Type');

// https://ecma-international.org/ecma-262/6.0/#sec-arrayspeciescreate

module.exports = function ArraySpeciesCreate(originalArray, length) {
	if (!IsInteger(length) || length < 0) {
		throw new $TypeError('Assertion failed: length must be an integer >= 0');
	}
	var len = length === 0 ? 0 : length;
	var C;
	var isArray = IsArray(originalArray);
	if (isArray) {
		C = Get(originalArray, 'constructor');
		// TODO: figure out how to make a cross-realm normal Array, a same-realm Array
		// if (IsConstructor(C)) {
		// 	if C is another realm's Array, C = undefined
		// 	Object.getPrototypeOf(Object.getPrototypeOf(Object.getPrototypeOf(Array))) === null ?
		// }
		if ($species && Type(C) === 'Object') {
			C = Get(C, $species);
			if (C === null) {
				C = void 0;
			}
		}
	}
	if (typeof C === 'undefined') {
		return $Array(len);
	}
	if (!IsConstructor(C)) {
		throw new $TypeError('C must be a constructor');
	}
	return new C(len); // Construct(C, len);
};


},{"../GetIntrinsic":83,"./Get":59,"./IsArray":61,"./IsConstructor":63,"./IsInteger":66,"./Type":80}],55:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $TypeError = GetIntrinsic('%TypeError%');

var inspect = require('object-inspect');

var IsCallable = require('./IsCallable');

// https://www.ecma-international.org/ecma-262/6.0/#sec-call

module.exports = function Call(F, V) {
	var args = arguments.length > 2 ? arguments[2] : [];
	if (!IsCallable(F)) {
		throw new $TypeError(inspect(F) + ' is not a function');
	}
	return F.apply(V, args);
};

},{"../GetIntrinsic":83,"./IsCallable":62,"object-inspect":202}],56:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $TypeError = GetIntrinsic('%TypeError%');

var DefineOwnProperty = require('../helpers/DefineOwnProperty');

var FromPropertyDescriptor = require('./FromPropertyDescriptor');
var OrdinaryGetOwnProperty = require('./OrdinaryGetOwnProperty');
var IsDataDescriptor = require('./IsDataDescriptor');
var IsExtensible = require('./IsExtensible');
var IsPropertyKey = require('./IsPropertyKey');
var SameValue = require('./SameValue');
var Type = require('./Type');

// https://www.ecma-international.org/ecma-262/6.0/#sec-createdataproperty

module.exports = function CreateDataProperty(O, P, V) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
	}
	var oldDesc = OrdinaryGetOwnProperty(O, P);
	var extensible = oldDesc || IsExtensible(O);
	var immutable = oldDesc && (!oldDesc.writable || !oldDesc.configurable);
	if (immutable || !extensible) {
		return false;
	}
	return DefineOwnProperty(
		IsDataDescriptor,
		SameValue,
		FromPropertyDescriptor,
		O,
		P,
		{
			'[[Configurable]]': true,
			'[[Enumerable]]': true,
			'[[Value]]': V,
			'[[Writable]]': true
		}
	);
};

},{"../GetIntrinsic":83,"../helpers/DefineOwnProperty":84,"./FromPropertyDescriptor":58,"./IsDataDescriptor":64,"./IsExtensible":65,"./IsPropertyKey":67,"./OrdinaryGetOwnProperty":69,"./SameValue":72,"./Type":80}],57:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $TypeError = GetIntrinsic('%TypeError%');

var CreateDataProperty = require('./CreateDataProperty');
var IsPropertyKey = require('./IsPropertyKey');
var Type = require('./Type');

// // https://ecma-international.org/ecma-262/6.0/#sec-createdatapropertyorthrow

module.exports = function CreateDataPropertyOrThrow(O, P, V) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true');
	}
	var success = CreateDataProperty(O, P, V);
	if (!success) {
		throw new $TypeError('unable to create data property');
	}
	return success;
};

},{"../GetIntrinsic":83,"./CreateDataProperty":56,"./IsPropertyKey":67,"./Type":80}],58:[function(require,module,exports){
'use strict';

var assertRecord = require('../helpers/assertRecord');

var Type = require('./Type');

// https://www.ecma-international.org/ecma-262/6.0/#sec-frompropertydescriptor

module.exports = function FromPropertyDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return Desc;
	}

	assertRecord(Type, 'Property Descriptor', 'Desc', Desc);

	var obj = {};
	if ('[[Value]]' in Desc) {
		obj.value = Desc['[[Value]]'];
	}
	if ('[[Writable]]' in Desc) {
		obj.writable = Desc['[[Writable]]'];
	}
	if ('[[Get]]' in Desc) {
		obj.get = Desc['[[Get]]'];
	}
	if ('[[Set]]' in Desc) {
		obj.set = Desc['[[Set]]'];
	}
	if ('[[Enumerable]]' in Desc) {
		obj.enumerable = Desc['[[Enumerable]]'];
	}
	if ('[[Configurable]]' in Desc) {
		obj.configurable = Desc['[[Configurable]]'];
	}
	return obj;
};

},{"../helpers/assertRecord":85,"./Type":80}],59:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $TypeError = GetIntrinsic('%TypeError%');

var inspect = require('object-inspect');

var IsPropertyKey = require('./IsPropertyKey');
var Type = require('./Type');

/**
 * 7.3.1 Get (O, P) - https://ecma-international.org/ecma-262/6.0/#sec-get-o-p
 * 1. Assert: Type(O) is Object.
 * 2. Assert: IsPropertyKey(P) is true.
 * 3. Return O.[[Get]](P, O).
 */

module.exports = function Get(O, P) {
	// 7.3.1.1
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: Type(O) is not Object');
	}
	// 7.3.1.2
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: IsPropertyKey(P) is not true, got ' + inspect(P));
	}
	// 7.3.1.3
	return O[P];
};

},{"../GetIntrinsic":83,"./IsPropertyKey":67,"./Type":80,"object-inspect":202}],60:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $TypeError = GetIntrinsic('%TypeError%');

var IsPropertyKey = require('./IsPropertyKey');
var Type = require('./Type');

// https://ecma-international.org/ecma-262/6.0/#sec-hasproperty

module.exports = function HasProperty(O, P) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: `O` must be an Object');
	}
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: `P` must be a Property Key');
	}
	return P in O;
};

},{"../GetIntrinsic":83,"./IsPropertyKey":67,"./Type":80}],61:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $Array = GetIntrinsic('%Array%');

// eslint-disable-next-line global-require
var toStr = !$Array.isArray && require('../helpers/callBound')('Object.prototype.toString');

// https://www.ecma-international.org/ecma-262/6.0/#sec-isarray

module.exports = $Array.isArray || function IsArray(argument) {
	return toStr(argument) === '[object Array]';
};

},{"../GetIntrinsic":83,"../helpers/callBound":87}],62:[function(require,module,exports){
'use strict';

// http://www.ecma-international.org/ecma-262/5.1/#sec-9.11

module.exports = require('is-callable');

},{"is-callable":193}],63:[function(require,module,exports){
'use strict';

// https://www.ecma-international.org/ecma-262/6.0/#sec-isconstructor

module.exports = function IsConstructor(argument) {
	return typeof argument === 'function' && !!argument.prototype; // unfortunately there's no way to truly check this without try/catch `new argument`
};

},{}],64:[function(require,module,exports){
'use strict';

var has = require('has');

var assertRecord = require('../helpers/assertRecord');

var Type = require('./Type');

// https://www.ecma-international.org/ecma-262/6.0/#sec-isdatadescriptor

module.exports = function IsDataDescriptor(Desc) {
	if (typeof Desc === 'undefined') {
		return false;
	}

	assertRecord(Type, 'Property Descriptor', 'Desc', Desc);

	if (!has(Desc, '[[Value]]') && !has(Desc, '[[Writable]]')) {
		return false;
	}

	return true;
};

},{"../helpers/assertRecord":85,"./Type":80,"has":104}],65:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $Object = GetIntrinsic('%Object%');

var isPrimitive = require('../helpers/isPrimitive');

var $preventExtensions = $Object.preventExtensions;
var $isExtensible = $Object.isExtensible;

// https://www.ecma-international.org/ecma-262/6.0/#sec-isextensible-o

module.exports = $preventExtensions
	? function IsExtensible(obj) {
		return !isPrimitive(obj) && $isExtensible(obj);
	}
	: function IsExtensible(obj) {
		return !isPrimitive(obj);
	};

},{"../GetIntrinsic":83,"../helpers/isPrimitive":91}],66:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $Math = GetIntrinsic('%Math%');

var $floor = $Math.floor;
var $abs = $Math.abs;

var $isNaN = require('../helpers/isNaN');
var $isFinite = require('../helpers/isFinite');

// https://www.ecma-international.org/ecma-262/6.0/#sec-isinteger

module.exports = function IsInteger(argument) {
	if (typeof argument !== 'number' || $isNaN(argument) || !$isFinite(argument)) {
		return false;
	}
	var abs = $abs(argument);
	return $floor(abs) === abs;
};

},{"../GetIntrinsic":83,"../helpers/isFinite":89,"../helpers/isNaN":90}],67:[function(require,module,exports){
'use strict';

// https://www.ecma-international.org/ecma-262/6.0/#sec-ispropertykey

module.exports = function IsPropertyKey(argument) {
	return typeof argument === 'string' || typeof argument === 'symbol';
};

},{}],68:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $match = GetIntrinsic('%Symbol.match%', true);

var hasRegExpMatcher = require('is-regex');

var ToBoolean = require('./ToBoolean');

// https://ecma-international.org/ecma-262/6.0/#sec-isregexp

module.exports = function IsRegExp(argument) {
	if (!argument || typeof argument !== 'object') {
		return false;
	}
	if ($match) {
		var isRegExp = argument[$match];
		if (typeof isRegExp !== 'undefined') {
			return ToBoolean(isRegExp);
		}
	}
	return hasRegExpMatcher(argument);
};

},{"../GetIntrinsic":83,"./ToBoolean":73,"is-regex":196}],69:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $gOPD = require('../helpers/getOwnPropertyDescriptor');
var $TypeError = GetIntrinsic('%TypeError%');

var callBound = require('../helpers/callBound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

var has = require('has');

var IsArray = require('./IsArray');
var IsPropertyKey = require('./IsPropertyKey');
var IsRegExp = require('./IsRegExp');
var ToPropertyDescriptor = require('./ToPropertyDescriptor');
var Type = require('./Type');

// https://www.ecma-international.org/ecma-262/6.0/#sec-ordinarygetownproperty

module.exports = function OrdinaryGetOwnProperty(O, P) {
	if (Type(O) !== 'Object') {
		throw new $TypeError('Assertion failed: O must be an Object');
	}
	if (!IsPropertyKey(P)) {
		throw new $TypeError('Assertion failed: P must be a Property Key');
	}
	if (!has(O, P)) {
		return void 0;
	}
	if (!$gOPD) {
		// ES3 / IE 8 fallback
		var arrayLength = IsArray(O) && P === 'length';
		var regexLastIndex = IsRegExp(O) && P === 'lastIndex';
		return {
			'[[Configurable]]': !(arrayLength || regexLastIndex),
			'[[Enumerable]]': $isEnumerable(O, P),
			'[[Value]]': O[P],
			'[[Writable]]': true
		};
	}
	return ToPropertyDescriptor($gOPD(O, P));
};

},{"../GetIntrinsic":83,"../helpers/callBound":87,"../helpers/getOwnPropertyDescriptor":88,"./IsArray":61,"./IsPropertyKey":67,"./IsRegExp":68,"./ToPropertyDescriptor":77,"./Type":80,"has":104}],70:[function(require,module,exports){
'use strict';

var callBound = require('../helpers/callBound');

var $PromiseResolve = callBound('Promise.resolve', true);

// https://ecma-international.org/ecma-262/9.0/#sec-promise-resolve

module.exports = function PromiseResolve(C, x) {
	if (!$PromiseResolve) {
		throw new SyntaxError('This environment does not support Promises.');
	}
	return $PromiseResolve(C, x);
};


},{"../helpers/callBound":87}],71:[function(require,module,exports){
'use strict';

module.exports = require('../5/CheckObjectCoercible');

},{"../5/CheckObjectCoercible":81}],72:[function(require,module,exports){
'use strict';

var $isNaN = require('../helpers/isNaN');

// http://www.ecma-international.org/ecma-262/5.1/#sec-9.12

module.exports = function SameValue(x, y) {
	if (x === y) { // 0 === -0, but they are not identical.
		if (x === 0) { return 1 / x === 1 / y; }
		return true;
	}
	return $isNaN(x) && $isNaN(y);
};

},{"../helpers/isNaN":90}],73:[function(require,module,exports){
'use strict';

// http://www.ecma-international.org/ecma-262/5.1/#sec-9.2

module.exports = function ToBoolean(value) { return !!value; };

},{}],74:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $TypeError = GetIntrinsic('%TypeError%');
var $Number = GetIntrinsic('%Number%');
var $RegExp = GetIntrinsic('%RegExp%');
var $parseInteger = GetIntrinsic('%parseInt%');

var callBound = require('../helpers/callBound');
var regexTester = require('../helpers/regexTester');
var isPrimitive = require('../helpers/isPrimitive');

var $strSlice = callBound('String.prototype.slice');
var isBinary = regexTester(/^0b[01]+$/i);
var isOctal = regexTester(/^0o[0-7]+$/i);
var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new $RegExp('[' + nonWS + ']', 'g');
var hasNonWS = regexTester(nonWSregex);

// whitespace from: https://es5.github.io/#x15.5.4.20
// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
var ws = [
	'\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
	'\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
	'\u2029\uFEFF'
].join('');
var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
var $replace = callBound('String.prototype.replace');
var $trim = function (value) {
	return $replace(value, trimRegex, '');
};

var ToPrimitive = require('./ToPrimitive');

// https://www.ecma-international.org/ecma-262/6.0/#sec-tonumber

module.exports = function ToNumber(argument) {
	var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
	if (typeof value === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a number');
	}
	if (typeof value === 'string') {
		if (isBinary(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 2));
		} else if (isOctal(value)) {
			return ToNumber($parseInteger($strSlice(value, 2), 8));
		} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
			return NaN;
		} else {
			var trimmed = $trim(value);
			if (trimmed !== value) {
				return ToNumber(trimmed);
			}
		}
	}
	return $Number(value);
};

},{"../GetIntrinsic":83,"../helpers/callBound":87,"../helpers/isPrimitive":91,"../helpers/regexTester":92,"./ToPrimitive":76}],75:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $Object = GetIntrinsic('%Object%');

var RequireObjectCoercible = require('./RequireObjectCoercible');

// https://www.ecma-international.org/ecma-262/6.0/#sec-toobject

module.exports = function ToObject(value) {
	RequireObjectCoercible(value);
	return $Object(value);
};

},{"../GetIntrinsic":83,"./RequireObjectCoercible":71}],76:[function(require,module,exports){
'use strict';

var toPrimitive = require('es-to-primitive/es2015');

// https://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive

module.exports = function ToPrimitive(input) {
	if (arguments.length > 1) {
		return toPrimitive(input, arguments[1]);
	}
	return toPrimitive(input);
};

},{"es-to-primitive/es2015":96}],77:[function(require,module,exports){
'use strict';

var has = require('has');

var GetIntrinsic = require('../GetIntrinsic');

var $TypeError = GetIntrinsic('%TypeError%');

var Type = require('./Type');
var ToBoolean = require('./ToBoolean');
var IsCallable = require('./IsCallable');

// https://ecma-international.org/ecma-262/5.1/#sec-8.10.5

module.exports = function ToPropertyDescriptor(Obj) {
	if (Type(Obj) !== 'Object') {
		throw new $TypeError('ToPropertyDescriptor requires an object');
	}

	var desc = {};
	if (has(Obj, 'enumerable')) {
		desc['[[Enumerable]]'] = ToBoolean(Obj.enumerable);
	}
	if (has(Obj, 'configurable')) {
		desc['[[Configurable]]'] = ToBoolean(Obj.configurable);
	}
	if (has(Obj, 'value')) {
		desc['[[Value]]'] = Obj.value;
	}
	if (has(Obj, 'writable')) {
		desc['[[Writable]]'] = ToBoolean(Obj.writable);
	}
	if (has(Obj, 'get')) {
		var getter = Obj.get;
		if (typeof getter !== 'undefined' && !IsCallable(getter)) {
			throw new TypeError('getter must be a function');
		}
		desc['[[Get]]'] = getter;
	}
	if (has(Obj, 'set')) {
		var setter = Obj.set;
		if (typeof setter !== 'undefined' && !IsCallable(setter)) {
			throw new $TypeError('setter must be a function');
		}
		desc['[[Set]]'] = setter;
	}

	if ((has(desc, '[[Get]]') || has(desc, '[[Set]]')) && (has(desc, '[[Value]]') || has(desc, '[[Writable]]'))) {
		throw new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');
	}
	return desc;
};

},{"../GetIntrinsic":83,"./IsCallable":62,"./ToBoolean":73,"./Type":80,"has":104}],78:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $String = GetIntrinsic('%String%');
var $TypeError = GetIntrinsic('%TypeError%');

// https://www.ecma-international.org/ecma-262/6.0/#sec-tostring

module.exports = function ToString(argument) {
	if (typeof argument === 'symbol') {
		throw new $TypeError('Cannot convert a Symbol value to a string');
	}
	return $String(argument);
};

},{"../GetIntrinsic":83}],79:[function(require,module,exports){
'use strict';

var ToNumber = require('./ToNumber');

// http://www.ecma-international.org/ecma-262/5.1/#sec-9.6

module.exports = function ToUint32(x) {
	return ToNumber(x) >>> 0;
};

},{"./ToNumber":74}],80:[function(require,module,exports){
'use strict';

var ES5Type = require('../5/Type');

// https://www.ecma-international.org/ecma-262/6.0/#sec-tostring

module.exports = function Type(x) {
	if (typeof x === 'symbol') {
		return 'Symbol';
	}
	return ES5Type(x);
};

},{"../5/Type":82}],81:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $TypeError = GetIntrinsic('%TypeError%');

// http://www.ecma-international.org/ecma-262/5.1/#sec-9.10

module.exports = function CheckObjectCoercible(value, optMessage) {
	if (value == null) {
		throw new $TypeError(optMessage || ('Cannot call method on ' + value));
	}
	return value;
};

},{"../GetIntrinsic":83}],82:[function(require,module,exports){
'use strict';

// https://www.ecma-international.org/ecma-262/5.1/#sec-8

module.exports = function Type(x) {
	if (x === null) {
		return 'Null';
	}
	if (typeof x === 'undefined') {
		return 'Undefined';
	}
	if (typeof x === 'function' || typeof x === 'object') {
		return 'Object';
	}
	if (typeof x === 'number') {
		return 'Number';
	}
	if (typeof x === 'boolean') {
		return 'Boolean';
	}
	if (typeof x === 'string') {
		return 'String';
	}
};

},{}],83:[function(require,module,exports){
'use strict';

/* globals
	Atomics,
	SharedArrayBuffer,
*/

var undefined;

var $TypeError = TypeError;

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () { throw new $TypeError(); };
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var generator; // = function * () {};
var generatorFunction = generator ? getProto(generator) : undefined;
var asyncFn; // async function() {};
var asyncFunction = asyncFn ? asyncFn.constructor : undefined;
var asyncGen; // async function * () {};
var asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined;
var asyncGenIterator = asyncGen ? asyncGen() : undefined;

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer.prototype,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%ArrayPrototype%': Array.prototype,
	'%ArrayProto_entries%': Array.prototype.entries,
	'%ArrayProto_forEach%': Array.prototype.forEach,
	'%ArrayProto_keys%': Array.prototype.keys,
	'%ArrayProto_values%': Array.prototype.values,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': asyncFunction,
	'%AsyncFunctionPrototype%': asyncFunction ? asyncFunction.prototype : undefined,
	'%AsyncGenerator%': asyncGen ? getProto(asyncGenIterator) : undefined,
	'%AsyncGeneratorFunction%': asyncGenFunction,
	'%AsyncGeneratorPrototype%': asyncGenFunction ? asyncGenFunction.prototype : undefined,
	'%AsyncIteratorPrototype%': asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%Boolean%': Boolean,
	'%BooleanPrototype%': Boolean.prototype,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%DataViewPrototype%': typeof DataView === 'undefined' ? undefined : DataView.prototype,
	'%Date%': Date,
	'%DatePrototype%': Date.prototype,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%ErrorPrototype%': Error.prototype,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%EvalErrorPrototype%': EvalError.prototype,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined : Float32Array.prototype,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined : Float64Array.prototype,
	'%Function%': Function,
	'%FunctionPrototype%': Function.prototype,
	'%Generator%': generator ? getProto(generator()) : undefined,
	'%GeneratorFunction%': generatorFunction,
	'%GeneratorPrototype%': generatorFunction ? generatorFunction.prototype : undefined,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined : Int8Array.prototype,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined : Int8Array.prototype,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined : Int32Array.prototype,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%JSONParse%': typeof JSON === 'object' ? JSON.parse : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%MapPrototype%': typeof Map === 'undefined' ? undefined : Map.prototype,
	'%Math%': Math,
	'%Number%': Number,
	'%NumberPrototype%': Number.prototype,
	'%Object%': Object,
	'%ObjectPrototype%': Object.prototype,
	'%ObjProto_toString%': Object.prototype.toString,
	'%ObjProto_valueOf%': Object.prototype.valueOf,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%PromisePrototype%': typeof Promise === 'undefined' ? undefined : Promise.prototype,
	'%PromiseProto_then%': typeof Promise === 'undefined' ? undefined : Promise.prototype.then,
	'%Promise_all%': typeof Promise === 'undefined' ? undefined : Promise.all,
	'%Promise_reject%': typeof Promise === 'undefined' ? undefined : Promise.reject,
	'%Promise_resolve%': typeof Promise === 'undefined' ? undefined : Promise.resolve,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%RangeErrorPrototype%': RangeError.prototype,
	'%ReferenceError%': ReferenceError,
	'%ReferenceErrorPrototype%': ReferenceError.prototype,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%RegExpPrototype%': RegExp.prototype,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SetPrototype%': typeof Set === 'undefined' ? undefined : Set.prototype,
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer.prototype,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%StringPrototype%': String.prototype,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SymbolPrototype%': hasSymbols ? Symbol.prototype : undefined,
	'%SyntaxError%': SyntaxError,
	'%SyntaxErrorPrototype%': SyntaxError.prototype,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined,
	'%TypeError%': $TypeError,
	'%TypeErrorPrototype%': $TypeError.prototype,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array.prototype,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray.prototype,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array.prototype,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array.prototype,
	'%URIError%': URIError,
	'%URIErrorPrototype%': URIError.prototype,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined : WeakMap.prototype,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
	'%WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined : WeakSet.prototype
};

var bind = require('function-bind');
var $replace = bind.call(Function.call, String.prototype.replace);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : (number || match);
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	if (!(name in INTRINSICS)) {
		throw new SyntaxError('intrinsic ' + name + ' does not exist!');
	}

	// istanbul ignore if // hopefully this is impossible to test :-)
	if (typeof INTRINSICS[name] === 'undefined' && !allowMissing) {
		throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
	}

	return INTRINSICS[name];
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new TypeError('"allowMissing" argument must be a boolean');
	}

	var parts = stringToPath(name);

	var value = getBaseIntrinsic('%' + (parts.length > 0 ? parts[0] : '') + '%', allowMissing);
	for (var i = 1; i < parts.length; i += 1) {
		if (value != null) {
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, parts[i]);
				if (!allowMissing && !(parts[i] in value)) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				value = desc ? (desc.get || desc.value) : value[parts[i]];
			} else {
				value = value[parts[i]];
			}
		}
	}
	return value;
};

},{"function-bind":101,"has-symbols":102}],84:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = null;
	}
}

var callBound = require('../helpers/callBound');

var $isEnumerable = callBound('Object.prototype.propertyIsEnumerable');

// eslint-disable-next-line max-params
module.exports = function DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, desc) {
	if (!$defineProperty) {
		if (!IsDataDescriptor(desc)) {
			// ES3 does not support getters/setters
			return false;
		}
		if (!desc['[[Configurable]]'] || !desc['[[Writable]]']) {
			return false;
		}

		// fallback for ES3
		if (P in O && $isEnumerable(O, P) !== !!desc['[[Enumerable]]']) {
			// a non-enumerable existing property
			return false;
		}

		// property does not exist at all, or exists but is enumerable
		var V = desc['[[Value]]'];
		// eslint-disable-next-line no-param-reassign
		O[P] = V; // will use [[Define]]
		return SameValue(O[P], V);
	}
	$defineProperty(O, P, FromPropertyDescriptor(desc));
	return true;
};

},{"../GetIntrinsic":83,"../helpers/callBound":87}],85:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $TypeError = GetIntrinsic('%TypeError%');
var $SyntaxError = GetIntrinsic('%SyntaxError%');

var has = require('has');

var predicates = {
	// https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type
	'Property Descriptor': function isPropertyDescriptor(Type, Desc) {
		if (Type(Desc) !== 'Object') {
			return false;
		}
		var allowed = {
			'[[Configurable]]': true,
			'[[Enumerable]]': true,
			'[[Get]]': true,
			'[[Set]]': true,
			'[[Value]]': true,
			'[[Writable]]': true
		};

		for (var key in Desc) { // eslint-disable-line
			if (has(Desc, key) && !allowed[key]) {
				return false;
			}
		}

		var isData = has(Desc, '[[Value]]');
		var IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');
		if (isData && IsAccessor) {
			throw new $TypeError('Property Descriptors may not be both accessor and data descriptors');
		}
		return true;
	}
};

module.exports = function assertRecord(Type, recordType, argumentName, value) {
	var predicate = predicates[recordType];
	if (typeof predicate !== 'function') {
		throw new $SyntaxError('unknown record type: ' + recordType);
	}
	if (!predicate(Type, value)) {
		throw new $TypeError(argumentName + ' must be a ' + recordType);
	}
};

},{"../GetIntrinsic":83,"has":104}],86:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

var GetIntrinsic = require('../GetIntrinsic');

var $Function = GetIntrinsic('%Function%');
var $apply = $Function.apply;
var $call = $Function.call;

module.exports = function callBind() {
	return bind.apply($call, arguments);
};

module.exports.apply = function applyBind() {
	return bind.apply($apply, arguments);
};

},{"../GetIntrinsic":83,"function-bind":101}],87:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var callBind = require('./callBind');

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
	var intrinsic = GetIntrinsic(name, !!allowMissing);
	if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.')) {
		return callBind(intrinsic);
	}
	return intrinsic;
};

},{"../GetIntrinsic":83,"./callBind":86}],88:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');
if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;

},{"../GetIntrinsic":83}],89:[function(require,module,exports){
'use strict';

var $isNaN = Number.isNaN || function (a) { return a !== a; };

module.exports = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };

},{}],90:[function(require,module,exports){
'use strict';

module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};

},{}],91:[function(require,module,exports){
'use strict';

module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};

},{}],92:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('../GetIntrinsic');

var $test = GetIntrinsic('RegExp.prototype.test');

var callBind = require('./callBind');

module.exports = function regexTester(regex) {
	return callBind($test, regex);
};

},{"../GetIntrinsic":83,"./callBind":86}],93:[function(require,module,exports){
module.exports = function properlyBoxed(method) {
	// Check node 0.6.21 bug where third parameter is not boxed
	var properlyBoxesNonStrict = true;
	var properlyBoxesStrict = true;
	var threwException = false;
	if (typeof method === 'function') {
		try {
			// eslint-disable-next-line max-params
			method.call('f', function (_, __, O) {
				if (typeof O !== 'object') {
					properlyBoxesNonStrict = false;
				}
			});

			method.call(
				[null],
				function () {
					'use strict';

					properlyBoxesStrict = typeof this === 'string'; // eslint-disable-line no-invalid-this
				},
				'x'
			);
		} catch (e) {
			threwException = true;
		}
		return !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
	}
	return false;
};

},{}],94:[function(require,module,exports){
(function (process){
'use strict';

/* eslint global-require: 0 */
// the code is structured this way so that bundlers can
// alias out `has-symbols` to `() => true` or `() => false` if your target
// environments' Symbol capabilities are known, and then use
// dead code elimination on the rest of this module.
//
// Similarly, `isarray` can be aliased to `Array.isArray` if
// available in all target environments.

var isArguments = require('is-arguments');

if (require('has-symbols')() || require('has-symbols/shams')()) {
	var $iterator = Symbol.iterator;
	// Symbol is available natively or shammed
	// natively:
	//  - Chrome >= 38
	//  - Edge 12-14?, Edge >= 15 for sure
	//  - FF >= 36
	//  - Safari >= 9
	//  - node >= 0.12
	module.exports = function getIterator(iterable) {
		// alternatively, `iterable[$iterator]?.()`
		if (iterable != null && typeof iterable[$iterator] !== 'undefined') {
			return iterable[$iterator]();
		}
		if (isArguments(iterable)) {
			// arguments objects lack Symbol.iterator
			// - node 0.12
			return Array.prototype[$iterator].call(iterable);
		}
	};
} else {
	// Symbol is not available, native or shammed
	var isArray = require('isarray');
	var isString = require('is-string');
	var GetIntrinsic = require('es-abstract/GetIntrinsic');
	var $Map = GetIntrinsic('%Map%', true);
	var $Set = GetIntrinsic('%Set%', true);
	var callBound = require('es-abstract/helpers/callBound');
	var $arrayPush = callBound('Array.prototype.push');
	var $charCodeAt = callBound('String.prototype.charCodeAt');
	var $stringSlice = callBound('String.prototype.slice');

	var advanceStringIndex = function advanceStringIndex(S, index) {
		var length = S.length;
		if ((index + 1) >= length) {
			return index + 1;
		}

		var first = $charCodeAt(S, index);
		if (first < 0xD800 || first > 0xDBFF) {
			return index + 1;
		}

		var second = $charCodeAt(S, index + 1);
		if (second < 0xDC00 || second > 0xDFFF) {
			return index + 1;
		}

		return index + 2;
	};

	var getArrayIterator = function getArrayIterator(arraylike) {
		var i = 0;
		return {
			next: function next() {
				var done = i >= arraylike.length;
				var value;
				if (!done) {
					value = arraylike[i];
					i += 1;
				}
				return {
					done: done,
					value: value
				};
			}
		};
	};

	var getNonCollectionIterator = function getNonCollectionIterator(iterable) {
		if (isArray(iterable) || isArguments(iterable)) {
			return getArrayIterator(iterable);
		}
		if (isString(iterable)) {
			var i = 0;
			return {
				next: function next() {
					var nextIndex = advanceStringIndex(iterable, i);
					var value = $stringSlice(iterable, i, nextIndex);
					i = nextIndex;
					return {
						done: nextIndex > iterable.length,
						value: value
					};
				}
			};
		}
	};

	if (!$Map && !$Set) {
		// the only language iterables are Array, String, arguments
		// - Safari <= 6.0
		// - Chrome < 38
		// - node < 0.12
		// - FF < 13
		// - IE < 11
		// - Edge < 11

		module.exports = getNonCollectionIterator;
	} else {
		// either Map or Set are available, but Symbol is not
		// - es6-shim on an ES5 browser
		// - Safari 6.2 (maybe 6.1?)
		// - FF v[13, 36)
		// - IE 11
		// - Edge 11
		// - Safari v[6, 9)

		var isMap = require('is-map');
		var isSet = require('is-set');

		// Firefox >= 27, IE 11, Safari 6.2 - 9, Edge 11, es6-shim in older envs, all have forEach
		var $mapForEach = callBound('Map.prototype.forEach', true);
		var $setForEach = callBound('Set.prototype.forEach', true);
		if (typeof process === 'undefined' || !process.versions || !process.versions.node) { // "if is not node"

			// Firefox 17 - 26 has `.iterator()`, whose iterator `.next()` either
			// returns a value, or throws a StopIteration object. These browsers
			// do not have any other mechanism for iteration.
			var $mapIterator = callBound('Map.prototype.iterator', true);
			var $setIterator = callBound('Set.prototype.iterator', true);
			var getStopIterationIterator = function (iterator) {
				var done = false;
				return {
					next: function next() {
						try {
							return {
								done: done,
								value: done ? undefined : iterator.next()
							};
						} catch (e) {
							done = true;
							return {
								done: true,
								value: undefined
							};
						}
					}
				};
			};
		}
		// Firefox 27-35, and some older es6-shim versions, use a string "@@iterator" property
		// this returns a proper iterator object, so we should use it instead of forEach.
		// newer es6-shim versions use a string "_es6-shim iterator_" property.
		var $mapAtAtIterator = callBound('Map.prototype.@@iterator', true) || callBound('Map.prototype._es6-shim iterator_', true);
		var $setAtAtIterator = callBound('Set.prototype.@@iterator', true) || callBound('Set.prototype._es6-shim iterator_', true);

		var getCollectionIterator = function getCollectionIterator(iterable) {
			if (isMap(iterable)) {
				if ($mapIterator) {
					return getStopIterationIterator($mapIterator(iterable));
				}
				if ($mapAtAtIterator) {
					return $mapAtAtIterator(iterable);
				}
				if ($mapForEach) {
					var entries = [];
					$mapForEach(iterable, function (v, k) {
						$arrayPush(entries, [k, v]);
					});
					return getArrayIterator(entries);
				}
			}
			if (isSet(iterable)) {
				if ($setIterator) {
					return getStopIterationIterator($setIterator(iterable));
				}
				if ($setAtAtIterator) {
					return $setAtAtIterator(iterable);
				}
				if ($setForEach) {
					var values = [];
					$setForEach(iterable, function (v) {
						$arrayPush(values, v);
					});
					return getArrayIterator(values);
				}
			}
		};

		module.exports = function getIterator(iterable) {
			return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
		};
	}
}

}).call(this,require('_process'))
},{"_process":330,"es-abstract/GetIntrinsic":83,"es-abstract/helpers/callBound":87,"has-symbols":102,"has-symbols/shams":103,"is-arguments":192,"is-map":195,"is-set":197,"is-string":198,"isarray":95}],95:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],96:[function(require,module,exports){
'use strict';

var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

var isPrimitive = require('./helpers/isPrimitive');
var isCallable = require('is-callable');
var isDate = require('is-date-object');
var isSymbol = require('is-symbol');

var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
	if (typeof O === 'undefined' || O === null) {
		throw new TypeError('Cannot call method on ' + O);
	}
	if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
		throw new TypeError('hint must be "string" or "number"');
	}
	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
	var method, result, i;
	for (i = 0; i < methodNames.length; ++i) {
		method = O[methodNames[i]];
		if (isCallable(method)) {
			result = method.call(O);
			if (isPrimitive(result)) {
				return result;
			}
		}
	}
	throw new TypeError('No default value');
};

var GetMethod = function GetMethod(O, P) {
	var func = O[P];
	if (func !== null && typeof func !== 'undefined') {
		if (!isCallable(func)) {
			throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
		}
		return func;
	}
	return void 0;
};

// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
module.exports = function ToPrimitive(input) {
	if (isPrimitive(input)) {
		return input;
	}
	var hint = 'default';
	if (arguments.length > 1) {
		if (arguments[1] === String) {
			hint = 'string';
		} else if (arguments[1] === Number) {
			hint = 'number';
		}
	}

	var exoticToPrim;
	if (hasSymbols) {
		if (Symbol.toPrimitive) {
			exoticToPrim = GetMethod(input, Symbol.toPrimitive);
		} else if (isSymbol(input)) {
			exoticToPrim = Symbol.prototype.valueOf;
		}
	}
	if (typeof exoticToPrim !== 'undefined') {
		var result = exoticToPrim.call(input, hint);
		if (isPrimitive(result)) {
			return result;
		}
		throw new TypeError('unable to convert exotic object to primitive');
	}
	if (hint === 'default' && (isDate(input) || isSymbol(input))) {
		hint = 'string';
	}
	return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
};

},{"./helpers/isPrimitive":97,"is-callable":193,"is-date-object":194,"is-symbol":199}],97:[function(require,module,exports){
arguments[4][91][0].apply(exports,arguments)
},{"dup":91}],98:[function(require,module,exports){
'use strict';

const matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;

module.exports = string => {
	if (typeof string !== 'string') {
		throw new TypeError('Expected a string');
	}

	return string.replace(matchOperatorsRegex, '\\$&');
};

},{}],99:[function(require,module,exports){
(function (global){
(function (self) {
  'use strict';

  function fetchPonyfill(options) {
    var Promise = options && options.Promise || self.Promise;
    var XMLHttpRequest = options && options.XMLHttpRequest || self.XMLHttpRequest;
    var global = self;

    return (function () {
      var self = Object.create(global, {
        fetch: {
          value: undefined,
          writable: true
        }
      });

      (function(self) {
        'use strict';

        if (self.fetch) {
          return
        }

        var support = {
          searchParams: 'URLSearchParams' in self,
          iterable: 'Symbol' in self && 'iterator' in Symbol,
          blob: 'FileReader' in self && 'Blob' in self && (function() {
            try {
              new Blob()
              return true
            } catch(e) {
              return false
            }
          })(),
          formData: 'FormData' in self,
          arrayBuffer: 'ArrayBuffer' in self
        }

        if (support.arrayBuffer) {
          var viewClasses = [
            '[object Int8Array]',
            '[object Uint8Array]',
            '[object Uint8ClampedArray]',
            '[object Int16Array]',
            '[object Uint16Array]',
            '[object Int32Array]',
            '[object Uint32Array]',
            '[object Float32Array]',
            '[object Float64Array]'
          ]

          var isDataView = function(obj) {
            return obj && DataView.prototype.isPrototypeOf(obj)
          }

          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
          }
        }

        function normalizeName(name) {
          if (typeof name !== 'string') {
            name = String(name)
          }
          if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
            throw new TypeError('Invalid character in header field name')
          }
          return name.toLowerCase()
        }

        function normalizeValue(value) {
          if (typeof value !== 'string') {
            value = String(value)
          }
          return value
        }

        // Build a destructive iterator for the value list
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift()
              return {done: value === undefined, value: value}
            }
          }

          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator
            }
          }

          return iterator
        }

        function Headers(headers) {
          this.map = {}

          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value)
            }, this)
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1])
            }, this)
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name])
            }, this)
          }
        }

        Headers.prototype.append = function(name, value) {
          name = normalizeName(name)
          value = normalizeValue(value)
          var oldValue = this.map[name]
          this.map[name] = oldValue ? oldValue+','+value : value
        }

        Headers.prototype['delete'] = function(name) {
          delete this.map[normalizeName(name)]
        }

        Headers.prototype.get = function(name) {
          name = normalizeName(name)
          return this.has(name) ? this.map[name] : null
        }

        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name))
        }

        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value)
        }

        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this)
            }
          }
        }

        Headers.prototype.keys = function() {
          var items = []
          this.forEach(function(value, name) { items.push(name) })
          return iteratorFor(items)
        }

        Headers.prototype.values = function() {
          var items = []
          this.forEach(function(value) { items.push(value) })
          return iteratorFor(items)
        }

        Headers.prototype.entries = function() {
          var items = []
          this.forEach(function(value, name) { items.push([name, value]) })
          return iteratorFor(items)
        }

        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries
        }

        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError('Already read'))
          }
          body.bodyUsed = true
        }

        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result)
            }
            reader.onerror = function() {
              reject(reader.error)
            }
          })
        }

        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader()
          var promise = fileReaderReady(reader)
          reader.readAsArrayBuffer(blob)
          return promise
        }

        function readBlobAsText(blob) {
          var reader = new FileReader()
          var promise = fileReaderReady(reader)
          reader.readAsText(blob)
          return promise
        }

        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf)
          var chars = new Array(view.length)

          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i])
          }
          return chars.join('')
        }

        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0)
          } else {
            var view = new Uint8Array(buf.byteLength)
            view.set(new Uint8Array(buf))
            return view.buffer
          }
        }

        function Body() {
          this.bodyUsed = false

          this._initBody = function(body) {
            this._bodyInit = body
            if (!body) {
              this._bodyText = ''
            } else if (typeof body === 'string') {
              this._bodyText = body
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString()
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer)
              // IE 10-11 can't handle a DataView body.
              this._bodyInit = new Blob([this._bodyArrayBuffer])
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body)
            } else {
              throw new Error('unsupported BodyInit type')
            }

            if (!this.headers.get('content-type')) {
              if (typeof body === 'string') {
                this.headers.set('content-type', 'text/plain;charset=UTF-8')
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set('content-type', this._bodyBlob.type)
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
              }
            }
          }

          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this)
              if (rejected) {
                return rejected
              }

              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob)
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]))
              } else if (this._bodyFormData) {
                throw new Error('could not read FormData body as blob')
              } else {
                return Promise.resolve(new Blob([this._bodyText]))
              }
            }

            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
              } else {
                return this.blob().then(readBlobAsArrayBuffer)
              }
            }
          }

          this.text = function() {
            var rejected = consumed(this)
            if (rejected) {
              return rejected
            }

            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob)
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
            } else if (this._bodyFormData) {
              throw new Error('could not read FormData body as text')
            } else {
              return Promise.resolve(this._bodyText)
            }
          }

          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode)
            }
          }

          this.json = function() {
            return this.text().then(JSON.parse)
          }

          return this
        }

        // HTTP methods whose capitalization should be normalized
        var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

        function normalizeMethod(method) {
          var upcased = method.toUpperCase()
          return (methods.indexOf(upcased) > -1) ? upcased : method
        }

        function Request(input, options) {
          options = options || {}
          var body = options.body

          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError('Already read')
            }
            this.url = input.url
            this.credentials = input.credentials
            if (!options.headers) {
              this.headers = new Headers(input.headers)
            }
            this.method = input.method
            this.mode = input.mode
            if (!body && input._bodyInit != null) {
              body = input._bodyInit
              input.bodyUsed = true
            }
          } else {
            this.url = String(input)
          }

          this.credentials = options.credentials || this.credentials || 'omit'
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers)
          }
          this.method = normalizeMethod(options.method || this.method || 'GET')
          this.mode = options.mode || this.mode || null
          this.referrer = null

          if ((this.method === 'GET' || this.method === 'HEAD') && body) {
            throw new TypeError('Body not allowed for GET or HEAD requests')
          }
          this._initBody(body)
        }

        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit })
        }

        function decode(body) {
          var form = new FormData()
          body.trim().split('&').forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split('=')
              var name = split.shift().replace(/\+/g, ' ')
              var value = split.join('=').replace(/\+/g, ' ')
              form.append(decodeURIComponent(name), decodeURIComponent(value))
            }
          })
          return form
        }

        function parseHeaders(rawHeaders) {
          var headers = new Headers()
          // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
          // https://tools.ietf.org/html/rfc7230#section-3.2
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(':')
            var key = parts.shift().trim()
            if (key) {
              var value = parts.join(':').trim()
              headers.append(key, value)
            }
          })
          return headers
        }

        Body.call(Request.prototype)

        function Response(bodyInit, options) {
          if (!options) {
            options = {}
          }

          this.type = 'default'
          this.status = options.status === undefined ? 200 : options.status
          this.ok = this.status >= 200 && this.status < 300
          this.statusText = 'statusText' in options ? options.statusText : 'OK'
          this.headers = new Headers(options.headers)
          this.url = options.url || ''
          this._initBody(bodyInit)
        }

        Body.call(Response.prototype)

        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          })
        }

        Response.error = function() {
          var response = new Response(null, {status: 0, statusText: ''})
          response.type = 'error'
          return response
        }

        var redirectStatuses = [301, 302, 303, 307, 308]

        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError('Invalid status code')
          }

          return new Response(null, {status: status, headers: {location: url}})
        }

        self.Headers = Headers
        self.Request = Request
        self.Response = Response

        self.fetch = function(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init)
            var xhr = new XMLHttpRequest()

            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || '')
              }
              options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
              var body = 'response' in xhr ? xhr.response : xhr.responseText
              resolve(new Response(body, options))
            }

            xhr.onerror = function() {
              reject(new TypeError('Network request failed'))
            }

            xhr.ontimeout = function() {
              reject(new TypeError('Network request failed'))
            }

            xhr.open(request.method, request.url, true)

            if (request.credentials === 'include') {
              xhr.withCredentials = true
            } else if (request.credentials === 'omit') {
              xhr.withCredentials = false
            }

            if ('responseType' in xhr && support.blob) {
              xhr.responseType = 'blob'
            }

            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value)
            })

            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
          })
        }
        self.fetch.polyfill = true
      })(typeof self !== 'undefined' ? self : this);


      return {
        fetch: self.fetch,
        Headers: self.Headers,
        Request: self.Request,
        Response: self.Response
      };
    }());
  }

  if (typeof define === 'function' && define.amd) {
    define(function () {
      return fetchPonyfill;
    });
  } else if (typeof exports === 'object') {
    module.exports = fetchPonyfill;
  } else {
    self.fetchPonyfill = fetchPonyfill;
  }
}(typeof self !== 'undefined' ? self : typeof global !== 'undefined' ? global : this));


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],100:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

},{}],101:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

},{"./implementation":100}],102:[function(require,module,exports){
(function (global){
'use strict';

var origSymbol = global.Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./shams":103}],103:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

},{}],104:[function(require,module,exports){
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

},{"function-bind":101}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// dummy capability, this capability reuses the same AWAY sytax from rfc1459 for broadcasts
var AwayNotifyCapability = {
    name: 'away-notify'
};
exports.default = AwayNotifyCapability;

},{}],106:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../../../../Message/Message");
var MessageDefinition_1 = require("../../../../../Message/MessageDefinition");
var ChgHost = /** @class */ (function (_super) {
    __extends(ChgHost, _super);
    function ChgHost() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition()
    ], ChgHost.prototype, "newUser", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition()
    ], ChgHost.prototype, "newHost", void 0);
    ChgHost = __decorate([
        MessageDefinition_1.MessageType('CHGHOST')
    ], ChgHost);
    return ChgHost;
}(Message_1.default));
exports.default = ChgHost;

},{"../../../../../Message/Message":116,"../../../../../Message/MessageDefinition":118}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ChgHost_1 = require("./MessageTypes/Commands/ChgHost");
var ChgHostCapability = {
    name: 'chghost',
    messageTypes: [ChgHost_1.default]
};
exports.default = ChgHostCapability;

},{"./MessageTypes/Commands/ChgHost":106}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// dummy capability, this capability reuses the same INVITE sytax from rfc1459 for broadcasts
var InviteNotifyCapability = {
    name: 'invite-notify'
};
exports.default = InviteNotifyCapability;

},{}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// dummy capability, the code handles both single and multiple prefixes just fine
var MultiPrefixCapability = {
    name: 'multi-prefix'
};
exports.default = MultiPrefixCapability;

},{}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AwayNotifyCapability_1 = require("./AwayNotifyCapability");
exports.AwayNotify = AwayNotifyCapability_1.default;
var ChgHostCapability_1 = require("./ChgHostCapability");
exports.ChgHost = ChgHostCapability_1.default;
var InviteNotifyCapability_1 = require("./InviteNotifyCapability");
exports.InviteNotify = InviteNotifyCapability_1.default;
var MultiPrefixCapability_1 = require("./MultiPrefixCapability");
exports.MultiPrefix = MultiPrefixCapability_1.default;

},{"./AwayNotifyCapability":105,"./ChgHostCapability":107,"./InviteNotifyCapability":108,"./MultiPrefixCapability":109}],111:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var MessageError = /** @class */ (function (_super) {
    __extends(MessageError, _super);
    function MessageError(msg) {
        var _this = _super.call(this, "Received error from IRC server: " + msg.rawLine) || this;
        _this.ircMessage = msg;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, _this.constructor);
        }
        return _this;
    }
    Object.defineProperty(MessageError.prototype, "name", {
        get: function () {
            return this.constructor.name;
        },
        enumerable: true,
        configurable: true
    });
    return MessageError;
}(Error));
exports.default = MessageError;

},{}],112:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var NotEnoughParametersError = /** @class */ (function (_super) {
    __extends(NotEnoughParametersError, _super);
    function NotEnoughParametersError(_command, _expectedParams, _actualParams) {
        var _this = _super.call(this, "command \"" + _command + "\" expected " + _expectedParams + " or more parameters, got " + _actualParams) || this;
        _this._command = _command;
        _this._expectedParams = _expectedParams;
        _this._actualParams = _actualParams;
        Object.setPrototypeOf(_this, NotEnoughParametersError.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, NotEnoughParametersError);
        }
        return _this;
    }
    Object.defineProperty(NotEnoughParametersError.prototype, "command", {
        get: function () {
            return this._command;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotEnoughParametersError.prototype, "expectedParams", {
        get: function () {
            return this._expectedParams;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NotEnoughParametersError.prototype, "actualParams", {
        get: function () {
            return this._actualParams;
        },
        enumerable: true,
        configurable: true
    });
    return NotEnoughParametersError;
}(Error));
exports.default = NotEnoughParametersError;

},{}],113:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ParameterRequirementMismatchError = /** @class */ (function (_super) {
    __extends(ParameterRequirementMismatchError, _super);
    function ParameterRequirementMismatchError(_command, _paramName, _paramSpec, _givenValue) {
        var _this = _super.call(this, "required parameter \"" + _paramName + "\" did not validate against " + (_paramSpec.type ||
            'regex') + " validation: \"" + _givenValue + "\"") || this;
        _this._command = _command;
        _this._paramName = _paramName;
        _this._paramSpec = _paramSpec;
        _this._givenValue = _givenValue;
        Object.setPrototypeOf(_this, ParameterRequirementMismatchError.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, ParameterRequirementMismatchError);
        }
        return _this;
    }
    Object.defineProperty(ParameterRequirementMismatchError.prototype, "command", {
        get: function () {
            return this._command;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParameterRequirementMismatchError.prototype, "paramName", {
        get: function () {
            return this._paramName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParameterRequirementMismatchError.prototype, "paramSpec", {
        get: function () {
            return this._paramSpec;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParameterRequirementMismatchError.prototype, "givenValue", {
        get: function () {
            return this._givenValue;
        },
        enumerable: true,
        configurable: true
    });
    return ParameterRequirementMismatchError;
}(Error));
exports.default = ParameterRequirementMismatchError;

},{}],114:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var UnknownChannelModeCharError = /** @class */ (function (_super) {
    __extends(UnknownChannelModeCharError, _super);
    function UnknownChannelModeCharError(_char) {
        var _this = _super.call(this, "Unknown channel mode character " + _char) || this;
        _this._char = _char;
        Object.setPrototypeOf(_this, UnknownChannelModeCharError.prototype);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, UnknownChannelModeCharError);
        }
        return _this;
    }
    Object.defineProperty(UnknownChannelModeCharError.prototype, "char", {
        get: function () {
            return this._char;
        },
        enumerable: true,
        configurable: true
    });
    return UnknownChannelModeCharError;
}(Error));
exports.default = UnknownChannelModeCharError;

},{}],115:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var connection_1 = require("@d-fischer/connection");
var logger_1 = require("@d-fischer/logger");
var shared_utils_1 = require("@d-fischer/shared-utils");
var typed_event_emitter_1 = require("@d-fischer/typed-event-emitter");
var clone = require("clone");
var CoreCapabilities = require("./Capability/CoreCapabilities");
var MessageError_1 = require("./Errors/MessageError");
var Message_1 = require("./Message/Message");
var MessageCollector_1 = require("./Message/MessageCollector");
var MessageParser_1 = require("./Message/MessageParser");
var MessageTypes = require("./Message/MessageTypes");
var Commands_1 = require("./Message/MessageTypes/Commands");
var ClientQuit_1 = require("./Message/MessageTypes/Commands/ClientQuit");
var Numerics_1 = require("./Message/MessageTypes/Numerics");
var ServerProperties_1 = require("./ServerProperties");
var StringTools_1 = require("./Toolkit/StringTools");
var IRCClient = /** @class */ (function (_super) {
    __extends(IRCClient, _super);
    function IRCClient(options) {
        var e_1, _a;
        var _this = _super.call(this) || this;
        _this._registered = false;
        _this._supportsCapabilities = true;
        _this._events = new Map();
        _this._registeredMessageTypes = new Map();
        // emitted events
        _this.onConnect = _this.registerEvent();
        _this.onRegister = _this.registerEvent();
        _this.onDisconnect = _this.registerEvent();
        _this.onPrivmsg = _this.registerEvent();
        _this.onAction = _this.registerEvent();
        _this.onNotice = _this.registerEvent();
        _this.onNickChange = _this.registerEvent();
        _this.onCtcp = _this.registerEvent();
        _this.onCtcpReply = _this.registerEvent();
        _this.onAnyMessage = _this.registerEvent();
        _this._serverProperties = clone(ServerProperties_1.defaultServerProperties, false);
        _this._supportedFeatures = {};
        _this._collectors = [];
        _this._clientCapabilities = new Map();
        _this._serverCapabilities = new Map();
        _this._negotiatedCapabilities = new Map();
        var connection = options.connection, credentials = options.credentials, channels = options.channels, channelTypes = options.channelTypes, _b = options.logger, logger = _b === void 0 ? {} : _b;
        _this._options = options;
        var _c = connection.pingOnInactivity, pingOnInactivity = _c === void 0 ? 60 : _c, _d = connection.pingTimeout, pingTimeout = _d === void 0 ? 10 : _d;
        _this._pingOnInactivity = pingOnInactivity;
        _this._pingTimeout = pingTimeout;
        _this._currentNick = credentials.nick;
        _this._logger = new logger_1.default(__assign({ name: 'ircv3', emoji: true }, logger));
        _this.registerCoreMessageTypes();
        try {
            for (var _e = __values(Object.values(CoreCapabilities)), _f = _e.next(); !_f.done; _f = _e.next()) {
                var cap = _f.value;
                _this.registerCapability(cap);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (channels) {
            _this.onRegister(function () { return __awaiter(_this, void 0, void 0, function () {
                var resolvedChannels, resolvedChannels_1, resolvedChannels_1_1, channel;
                var e_2, _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, shared_utils_1.resolveConfigValue(channels)];
                        case 1:
                            resolvedChannels = _b.sent();
                            if (resolvedChannels) {
                                try {
                                    for (resolvedChannels_1 = __values(resolvedChannels), resolvedChannels_1_1 = resolvedChannels_1.next(); !resolvedChannels_1_1.done; resolvedChannels_1_1 = resolvedChannels_1.next()) {
                                        channel = resolvedChannels_1_1.value;
                                        this.join(channel);
                                    }
                                }
                                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                                finally {
                                    try {
                                        if (resolvedChannels_1_1 && !resolvedChannels_1_1.done && (_a = resolvedChannels_1.return)) _a.call(resolvedChannels_1);
                                    }
                                    finally { if (e_2) throw e_2.error; }
                                }
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
        }
        _this.onMessage(Commands_1.CapabilityNegotiation, function (_a) {
            var e_3, _b, e_4, _c;
            var _d = _a.params, subCommand = _d.subCommand, capabilities = _d.capabilities;
            var caps = capabilities.split(' ');
            // eslint-disable-next-line default-case
            switch (subCommand.toUpperCase()) {
                case 'NEW': {
                    _this._logger.debug2("Server registered new capabilities: " + caps.join(', '));
                    var capList = shared_utils_1.arrayToObject(caps, function (part) {
                        var _a;
                        if (!part) {
                            return {};
                        }
                        var _b = __read(shared_utils_1.splitWithLimit(part, '=', 2), 2), cap = _b[0], param = _b[1];
                        return _a = {},
                            _a[cap] = {
                                name: cap,
                                param: param || true
                            },
                            _a;
                    });
                    try {
                        for (var _e = __values(Object.entries(capList)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var _g = __read(_f.value, 2), name_1 = _g[0], cap = _g[1];
                            _this._serverCapabilities.set(name_1, cap);
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                    var capNames_1 = Object.keys(capList);
                    _this._negotiateCapabilities(Array.from(_this._clientCapabilities.entries())
                        .filter(function (_a) {
                        var _b = __read(_a, 1), name = _b[0];
                        return capNames_1.includes(name);
                    })
                        .map(function (_a) {
                        var _b = __read(_a, 2), cap = _b[1];
                        return cap;
                    }));
                    break;
                }
                case 'DEL': {
                    _this._logger.debug2("Server removed capabilities: " + caps.join(', '));
                    try {
                        for (var caps_1 = __values(caps), caps_1_1 = caps_1.next(); !caps_1_1.done; caps_1_1 = caps_1.next()) {
                            var cap = caps_1_1.value;
                            _this._serverCapabilities.delete(cap);
                            _this._negotiatedCapabilities.delete(cap);
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (caps_1_1 && !caps_1_1.done && (_c = caps_1.return)) _c.call(caps_1);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
            }
        });
        _this.onMessage(Commands_1.Ping, function (_a) {
            var message = _a.params.message;
            _this.sendMessage(Commands_1.Pong, { message: message });
        });
        _this.onMessage(Numerics_1.Reply001Welcome, function (_a) {
            var me = _a.params.me;
            if (_this._currentNick !== me) {
                if (_this._currentNick !== '') {
                    _this._logger.warn("Mismatching nicks: passed " + _this._currentNick + ", but you're actually " + me);
                }
                _this._currentNick = me;
            }
            if (!_this._supportsCapabilities) {
                _this._registered = true;
                _this.emit(_this.onRegister);
            }
        });
        _this.onMessage(Numerics_1.Reply004ServerInfo, function (_a) {
            var userModes = _a.params.userModes;
            if (userModes) {
                _this._serverProperties.supportedUserModes = userModes;
            }
        });
        _this.onMessage(Numerics_1.Reply005ISupport, function (_a) {
            var supports = _a.params.supports;
            var newFeatures = shared_utils_1.arrayToObject(supports.split(' '), function (part) {
                var _a;
                var _b = __read(shared_utils_1.splitWithLimit(part, '=', 2), 2), support = _b[0], param = _b[1];
                return _a = {}, _a[support] = param || true, _a;
            });
            _this._supportedFeatures = __assign(__assign({}, _this._supportedFeatures), newFeatures);
        });
        _this.onMessage(Numerics_1.Error462AlreadyRegistered, function () {
            // what, I thought we are not registered yet?
            if (!_this._registered) {
                // screw this, we are now.
                _this._logger.warn("We thought we're not registered yet, but we actually are");
                _this._registered = true;
                _this.emit(_this.onRegister);
            }
        });
        _this.onMessage(Commands_1.PrivateMessage, function (msg) {
            var _a = msg.params, target = _a.target, message = _a.message;
            var ctcpMessage = StringTools_1.decodeCtcp(message);
            var nick = msg.prefix && msg.prefix.nick;
            if (ctcpMessage) {
                if (ctcpMessage.command === 'ACTION') {
                    _this.emit(_this.onAction, target, nick, ctcpMessage.params, msg);
                }
                else {
                    _this.emit(_this.onCtcp, target, nick, ctcpMessage.command, ctcpMessage.params, msg);
                }
            }
            else {
                _this.emit(_this.onPrivmsg, target, nick, message, msg);
            }
        });
        _this.onMessage(Commands_1.NickChange, function (msg) {
            var newNick = msg.params.nick;
            var oldNick = msg.prefix && msg.prefix.nick;
            if (oldNick === _this._currentNick) {
                _this._currentNick = newNick;
            }
            _this.emit(_this.onNickChange, oldNick, newNick, msg);
        });
        _this.onMessage(Commands_1.Notice, function (msg) {
            var _a = msg.params, target = _a.target, message = _a.message;
            var ctcpMessage = StringTools_1.decodeCtcp(message);
            var nick = msg.prefix && msg.prefix.nick;
            if (ctcpMessage) {
                _this.emit(_this.onCtcpReply, target, nick, ctcpMessage.command, ctcpMessage.params, msg);
            }
            _this.emit(_this.onNotice, target, nick, message, msg);
        });
        _this.onRegister(function () { return _this._startPingCheckTimer(); });
        _this._credentials = __assign({}, credentials);
        if (channelTypes) {
            _this._serverProperties.channelTypes = channelTypes;
        }
        return _this;
    }
    IRCClient.prototype.setupConnection = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, connection, _b, webSocket, hostName, port, secure, _c, reconnect, connectionOptions, password;
            var _this = this;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _a = this._options, connection = _a.connection, _b = _a.webSocket, webSocket = _b === void 0 ? [] : _b;
                        hostName = connection.hostName, port = connection.port, secure = connection.secure, _c = connection.reconnect, reconnect = _c === void 0 ? true : _c;
                        connectionOptions = {
                            hostName: hostName,
                            port: port,
                            secure: secure,
                            lineBased: true
                        };
                        this._connection = webSocket
                            ? new connection_1.WebSocketConnection(connectionOptions)
                            : new connection_1.DirectConnection(connectionOptions);
                        this._logger.debug1('Determining connection password');
                        return [4 /*yield*/, this.getPassword(this._credentials.password)];
                    case 1:
                        password = _d.sent();
                        if (password) {
                            if (password !== this._credentials.password) {
                                this._updateCredentials({ password: password });
                            }
                        }
                        this._connection.on('connect', function () { return __awaiter(_this, void 0, void 0, function () {
                            var _this = this;
                            return __generator(this, function (_a) {
                                this._retryDelayGenerator = undefined;
                                this._logger.info("Connection to server " + this._connection.host + ":" + this._connection.port + " established");
                                this.sendMessageAndCaptureReply(Commands_1.CapabilityNegotiation, {
                                    subCommand: 'LS',
                                    version: '302'
                                }).then(function (capReply) {
                                    if (!capReply.length || !(capReply[0] instanceof Commands_1.CapabilityNegotiation)) {
                                        _this._logger.debug2('Server does not support capabilities');
                                        return;
                                    }
                                    _this._supportsCapabilities = true;
                                    var capLists = capReply.map(function (line) {
                                        return shared_utils_1.arrayToObject(line.params.capabilities.split(' '), function (part) {
                                            var _a;
                                            if (!part) {
                                                return {};
                                            }
                                            var _b = __read(shared_utils_1.splitWithLimit(part, '=', 2), 2), cap = _b[0], param = _b[1];
                                            return _a = {},
                                                _a[cap] = {
                                                    name: cap,
                                                    param: param || true
                                                },
                                                _a;
                                        });
                                    });
                                    _this._serverCapabilities = new Map(Object.entries(Object.assign.apply(Object, __spread([{}], capLists))));
                                    _this._logger.debug2("Capabilities supported by server: " + Array.from(_this._serverCapabilities.keys()).join(', '));
                                    var capabilitiesToNegotiate = capLists.map(function (list) {
                                        var capNames = Object.keys(list);
                                        return Array.from(_this._clientCapabilities.entries())
                                            .filter(function (_a) {
                                            var _b = __read(_a, 1), name = _b[0];
                                            return capNames.includes(name);
                                        })
                                            .map(function (_a) {
                                            var _b = __read(_a, 2), cap = _b[1];
                                            return cap;
                                        });
                                    });
                                    _this._negotiateCapabilityBatch(capabilitiesToNegotiate).then(function () {
                                        _this.sendMessage(Commands_1.CapabilityNegotiation, { subCommand: 'END' });
                                        _this._registered = true;
                                        _this.emit(_this.onRegister);
                                    });
                                });
                                if (password) {
                                    this.sendMessage(Commands_1.Password, { password: password });
                                }
                                this.sendMessage(Commands_1.NickChange, { nick: this._credentials.nick });
                                this.sendMessage(Commands_1.UserRegistration, {
                                    user: this._credentials.userName || this._credentials.nick,
                                    mode: '8',
                                    unused: '*',
                                    realName: this._credentials.realName || this._credentials.nick
                                });
                                return [2 /*return*/];
                            });
                        }); });
                        this._connection.on('receive', function (line) {
                            _this.receiveLine(line);
                        });
                        this._connection.on('disconnect', function (manually, reason) {
                            _this._registered = false;
                            if (_this._pingCheckTimer) {
                                clearTimeout(_this._pingCheckTimer);
                            }
                            if (_this._pingTimeoutTimer) {
                                clearTimeout(_this._pingTimeoutTimer);
                            }
                            if (manually) {
                                _this._logger.info('Disconnected manually');
                            }
                            else {
                                if (reason) {
                                    _this._logger.err("Disconnected unexpectedly: " + reason.message);
                                }
                                else {
                                    _this._logger.err('Disconnected unexpectedly');
                                }
                            }
                            _this.emit(_this.onDisconnect, manually, reason);
                            _this._connection = undefined;
                            if (!manually && reconnect) {
                                if (!_this._retryDelayGenerator) {
                                    _this._retryDelayGenerator = IRCClient._getReconnectWaitTime();
                                }
                                var delay = _this._retryDelayGenerator.next().value;
                                _this._logger.info("Reconnecting in " + delay + " seconds");
                                _this._retryTimer = setTimeout(function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                    return [2 /*return*/, this.connect()];
                                }); }); }, delay * 1000);
                            }
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    IRCClient.prototype.receiveLine = function (line) {
        this._logger.debug1("Received message: " + line);
        var parsedMessage;
        try {
            parsedMessage = MessageParser_1.parseMessage(line, this._serverProperties, this._registeredMessageTypes, true, this._options.nonConformingCommands);
        }
        catch (e) {
            this._logger.err("Error parsing message: " + e.message);
            this._logger.trace(e.stack);
            return;
        }
        this._logger.debug3("Parsed message: " + JSON.stringify(parsedMessage));
        this._startPingCheckTimer();
        this.emit(this.onAnyMessage, parsedMessage);
        this.handleEvents(parsedMessage);
    };
    Object.defineProperty(IRCClient.prototype, "serverProperties", {
        get: function () {
            return clone(this._serverProperties, false);
        },
        enumerable: true,
        configurable: true
    });
    IRCClient.prototype.pingCheck = function () {
        var _this = this;
        var now = Date.now();
        var nowStr = now.toString();
        var handler = this.onMessage(Commands_1.Pong, function (msg) {
            var message = msg.params.message;
            if (message === nowStr) {
                _this._logger.debug2("Current ping: " + (Date.now() - now) + "ms");
                if (_this._pingTimeoutTimer) {
                    clearTimeout(_this._pingTimeoutTimer);
                }
                _this.removeMessageListener(handler);
            }
        });
        this._pingTimeoutTimer = setTimeout(function () {
            _this._logger.warn("Reconnecting because the last ping took over " + _this._pingTimeout + " seconds");
            _this.removeMessageListener(handler);
            _this.reconnect('Ping timeout');
        }, this._pingTimeout * 1000);
        this.sendMessage(Commands_1.Ping, { message: nowStr });
    };
    IRCClient.prototype.reconnect = function (message) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.quit(message);
                return [2 /*return*/, this.connect()];
            });
        });
    };
    IRCClient.prototype.registerMessageType = function (cls) {
        if (cls.COMMAND !== '') {
            this._logger.debug3("Registering message type " + cls.COMMAND);
            this._registeredMessageTypes.set(cls.COMMAND.toUpperCase(), cls);
        }
    };
    IRCClient.prototype.knowsCommand = function (command) {
        return this._registeredMessageTypes.has(command.toUpperCase());
    };
    IRCClient.prototype.getCommandClass = function (command) {
        return this._registeredMessageTypes.get(command.toUpperCase());
    };
    IRCClient.prototype.connect = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._supportsCapabilities = false;
                        this._negotiatedCapabilities = new Map();
                        this._currentNick = this._credentials.nick;
                        return [4 /*yield*/, this.setupConnection()];
                    case 1:
                        _a.sent();
                        this._logger.info("Connecting to " + this._connection.host + ":" + this._connection.port);
                        return [4 /*yield*/, this._connection.connect()];
                    case 2:
                        _a.sent();
                        this.emit(this.onConnect);
                        return [2 /*return*/];
                }
            });
        });
    };
    IRCClient.prototype.waitForRegistration = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (this._registered) {
                    return [2 /*return*/, undefined];
                }
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var errorListener;
                        var disconnectListener;
                        var registerListener = _this.onRegister(function () {
                            registerListener.unbind();
                            _this.removeMessageListener(errorListener);
                            disconnectListener.unbind();
                            resolve();
                        });
                        errorListener = _this.onMessage(MessageTypes.Commands.ErrorMessage, function (msg) {
                            registerListener.unbind();
                            _this.removeMessageListener(errorListener);
                            disconnectListener.unbind();
                            reject(new MessageError_1.default(msg));
                        });
                        disconnectListener = _this.onDisconnect(function (reason) {
                            registerListener.unbind();
                            _this.removeMessageListener(errorListener);
                            disconnectListener.unbind();
                            reject(reason);
                        });
                    })];
            });
        });
    };
    IRCClient.prototype.registerCapability = function (cap) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, messageType;
            var e_5, _c;
            return __generator(this, function (_d) {
                this._clientCapabilities.set(cap.name, cap);
                if (cap.messageTypes) {
                    try {
                        for (_a = __values(cap.messageTypes), _b = _a.next(); !_b.done; _b = _a.next()) {
                            messageType = _b.value;
                            this.registerMessageType(messageType);
                        }
                    }
                    catch (e_5_1) { e_5 = { error: e_5_1 }; }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_5) throw e_5.error; }
                    }
                }
                if (this._serverCapabilities.has(cap.name)) {
                    return [2 /*return*/, this._negotiateCapabilities([cap])];
                }
                return [2 /*return*/, []];
            });
        });
    };
    IRCClient.prototype.send = function (message) {
        this.sendRaw(message.toString());
    };
    IRCClient.prototype.sendRaw = function (line) {
        if (this._connection) {
            this._logger.debug1("Sending message: " + line);
            this._connection.sendLine(line);
        }
    };
    IRCClient.prototype.onMessage = function (type, handler, handlerName) {
        var commandName = typeof type === 'string' ? type : type.COMMAND;
        if (!this._events.has(commandName)) {
            this._events.set(commandName, new Map());
        }
        var handlerList = this._events.get(commandName);
        if (!handlerName) {
            do {
                handlerName = commandName + ":" + shared_utils_1.padLeft(Math.random() * 10000, 4, '0');
            } while (handlerList.has(handlerName));
        }
        handlerList.set(handlerName, handler);
        return handlerName;
    };
    IRCClient.prototype.removeMessageListener = function (handlerName) {
        var _a = __read(handlerName.split(':'), 1), commandName = _a[0];
        if (!this._events.has(commandName)) {
            return;
        }
        this._events.get(commandName).delete(handlerName);
    };
    IRCClient.prototype.createMessage = function (type, params, tags) {
        return Message_1.createMessage(type, params, undefined, tags, this.serverProperties);
    };
    IRCClient.prototype.sendMessage = function (type, params) {
        this.send(this.createMessage(type, params));
    };
    IRCClient.prototype.sendMessageAndCaptureReply = function (type, params) {
        return __awaiter(this, void 0, void 0, function () {
            var message, promise;
            return __generator(this, function (_a) {
                if (!type.SUPPORTS_CAPTURE) {
                    throw new Error("The command \"" + type.COMMAND + "\" does not support reply capture");
                }
                message = this.createMessage(type, params);
                promise = this.collect(message).promise();
                this.send(message);
                return [2 /*return*/, promise];
            });
        });
    };
    Object.defineProperty(IRCClient.prototype, "isConnected", {
        get: function () {
            return this._connection ? this._connection.isConnected : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IRCClient.prototype, "isConnecting", {
        get: function () {
            return this._connection ? this._connection.isConnecting : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IRCClient.prototype, "isRegistered", {
        get: function () {
            return this._registered;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IRCClient.prototype, "currentNick", {
        get: function () {
            return this._currentNick;
        },
        enumerable: true,
        configurable: true
    });
    /** @private */
    IRCClient.prototype.collect = function (originalMessage) {
        var types = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            types[_i - 1] = arguments[_i];
        }
        var collector = new (MessageCollector_1.default.bind.apply(MessageCollector_1.default, __spread([void 0, this, originalMessage], types)))();
        this._collectors.push(collector);
        return collector;
    };
    /** @private */
    IRCClient.prototype.stopCollect = function (collector) {
        this._collectors.splice(this._collectors.findIndex(function (value) { return value === collector; }), 1);
    };
    // convenience methods
    IRCClient.prototype.join = function (channel, key) {
        this.sendMessage(Commands_1.ChannelJoin, { channel: channel, key: key });
    };
    IRCClient.prototype.part = function (channel) {
        this.sendMessage(Commands_1.ChannelPart, { channel: channel });
    };
    IRCClient.prototype.quit = function (message) {
        if (this._retryTimer) {
            clearInterval(this._retryTimer);
        }
        this._retryDelayGenerator = undefined;
        this.sendMessage(ClientQuit_1.default, { message: message });
        if (this._connection) {
            this._connection.disconnect();
        }
    };
    IRCClient.prototype.say = function (target, message) {
        this.sendMessage(Commands_1.PrivateMessage, { target: target, message: message });
    };
    IRCClient.prototype.sendCTCP = function (target, type, message) {
        this.say(target, "\u0001" + type.toUpperCase() + " " + message + "\u0001");
    };
    IRCClient.prototype.action = function (target, message) {
        this.sendCTCP(target, 'ACTION', message);
    };
    IRCClient.prototype.getPassword = function (currentPassword) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, currentPassword];
            });
        });
    };
    IRCClient.prototype.registerCoreMessageTypes = function () {
        var _this = this;
        shared_utils_1.forEachObjectEntry(MessageTypes.Commands, function (type) {
            _this.registerMessageType(type);
        });
        shared_utils_1.forEachObjectEntry(MessageTypes.Numerics, function (type) {
            _this.registerMessageType(type);
        });
    };
    IRCClient.prototype._negotiateCapabilityBatch = function (capabilities) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, Promise.all(capabilities
                        .filter(function (list) { return list.length; })
                        .map(function (capList) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                        return [2 /*return*/, this._negotiateCapabilities(capList)];
                    }); }); }))];
            });
        });
    };
    IRCClient.prototype._negotiateCapabilities = function (capList) {
        return __awaiter(this, void 0, void 0, function () {
            var mappedCapList, messages, capReply, negotiatedCapNames, newNegotiatedCaps, newNegotiatedCaps_1, newNegotiatedCaps_1_1, newCap, mergedCap;
            var e_6, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        mappedCapList = shared_utils_1.arrayToObject(capList, function (cap) {
                            var _a;
                            return (_a = {},
                                _a[cap.name] = cap,
                                _a);
                        });
                        return [4 /*yield*/, this.sendMessageAndCaptureReply(Commands_1.CapabilityNegotiation, {
                                subCommand: 'REQ',
                                capabilities: capList.map(function (cap) { return cap.name; }).join(' ')
                            })];
                    case 1:
                        messages = _b.sent();
                        capReply = messages.shift();
                        if (!capReply) {
                            throw new Error('capability negotiation failed unexpectedly without any reply');
                        }
                        if (!(capReply instanceof Commands_1.CapabilityNegotiation)) {
                            throw new Error("capability negotiation failed unexpectedly with \"" + capReply.command + "\" command");
                        }
                        negotiatedCapNames = capReply.params.capabilities.split(' ').filter(function (c) { return c; });
                        if (capReply.params.subCommand === 'ACK') {
                            // filter is necessary because some networks seem to add trailing spaces...
                            this._logger.debug2("Successfully negotiated capabilities: " + negotiatedCapNames.join(', '));
                            newNegotiatedCaps = negotiatedCapNames.map(function (capName) { return mappedCapList[capName]; });
                            try {
                                for (newNegotiatedCaps_1 = __values(newNegotiatedCaps), newNegotiatedCaps_1_1 = newNegotiatedCaps_1.next(); !newNegotiatedCaps_1_1.done; newNegotiatedCaps_1_1 = newNegotiatedCaps_1.next()) {
                                    newCap = newNegotiatedCaps_1_1.value;
                                    mergedCap = this._clientCapabilities.get(newCap.name);
                                    mergedCap.param = newCap.param;
                                    this._negotiatedCapabilities.set(mergedCap.name, mergedCap);
                                }
                            }
                            catch (e_6_1) { e_6 = { error: e_6_1 }; }
                            finally {
                                try {
                                    if (newNegotiatedCaps_1_1 && !newNegotiatedCaps_1_1.done && (_a = newNegotiatedCaps_1.return)) _a.call(newNegotiatedCaps_1);
                                }
                                finally { if (e_6) throw e_6.error; }
                            }
                            return [2 /*return*/, newNegotiatedCaps];
                        }
                        else {
                            this._logger.debug2("Failed to negotiate capabilities: " + negotiatedCapNames.join(', '));
                            return [2 /*return*/, new Error('capabilities failed to negotiate')];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    IRCClient.prototype._updateCredentials = function (newCredentials) {
        this._credentials = __assign(__assign({}, this._credentials), newCredentials);
    };
    // event helper
    IRCClient.prototype.handleEvents = function (message) {
        var e_7, _a;
        this._collectors.some(function (collector) { return collector.collect(message); });
        var handlers = this._events.get(message.constructor.COMMAND);
        if (!handlers) {
            return;
        }
        try {
            for (var _b = __values(handlers.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var handler = _c.value;
                handler(message);
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
    };
    IRCClient.prototype._startPingCheckTimer = function () {
        var _this = this;
        if (this._pingCheckTimer) {
            clearTimeout(this._pingCheckTimer);
        }
        this._pingCheckTimer = setTimeout(function () { return _this.pingCheck(); }, this._pingOnInactivity * 1000);
    };
    // yes, this is just fibonacci with a limit
    IRCClient._getReconnectWaitTime = function () {
        var current, next;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    current = 0;
                    next = 1;
                    _b.label = 1;
                case 1:
                    if (!(current < 120)) return [3 /*break*/, 3];
                    return [4 /*yield*/, current];
                case 2:
                    _b.sent();
                    _a = __read([next, current + next], 2), current = _a[0], next = _a[1];
                    return [3 /*break*/, 1];
                case 3:
                    if (!true) return [3 /*break*/, 5];
                    return [4 /*yield*/, 120];
                case 4:
                    _b.sent();
                    return [3 /*break*/, 3];
                case 5: return [2 /*return*/];
            }
        });
    };
    __decorate([
        shared_utils_1.NonEnumerable
    ], IRCClient.prototype, "_options", void 0);
    __decorate([
        shared_utils_1.NonEnumerable
    ], IRCClient.prototype, "_credentials", void 0);
    return IRCClient;
}(typed_event_emitter_1.EventEmitter));
exports.default = IRCClient;

},{"./Capability/CoreCapabilities":110,"./Errors/MessageError":111,"./Message/Message":116,"./Message/MessageCollector":117,"./Message/MessageParser":119,"./Message/MessageTypes":188,"./Message/MessageTypes/Commands":150,"./Message/MessageTypes/Commands/ClientQuit":127,"./Message/MessageTypes/Numerics":187,"./ServerProperties":189,"./Toolkit/StringTools":190,"@d-fischer/connection":11,"@d-fischer/logger":16,"@d-fischer/shared-utils":36,"@d-fischer/typed-event-emitter":37,"clone":46}],116:[function(require,module,exports){
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var shared_utils_1 = require("@d-fischer/shared-utils");
var NotEnoughParametersError_1 = require("../Errors/NotEnoughParametersError");
var ParameterRequirementMismatchError_1 = require("../Errors/ParameterRequirementMismatchError");
var ServerProperties_1 = require("../ServerProperties");
var StringTools_1 = require("../Toolkit/StringTools");
var tagEscapeMap = {
    '\\': '\\',
    ';': ':',
    '\n': 'n',
    '\r': 'r',
    ' ': 's'
};
function escapeTag(str) {
    return str.replace(/[\\;\n\r ]/g, function (match) { return "\\" + tagEscapeMap[match]; });
}
function prefixToString(prefix) {
    var result = "" + prefix.nick;
    if (prefix.user) {
        result += "!" + prefix.user;
    }
    if (prefix.host) {
        result += "@" + prefix.host;
    }
    return result;
}
exports.prefixToString = prefixToString;
function createMessage(type, params, prefix, tags, serverProperties, isServer) {
    if (serverProperties === void 0) { serverProperties = ServerProperties_1.defaultServerProperties; }
    if (isServer === void 0) { isServer = false; }
    var message = new type(type.COMMAND, undefined, undefined, undefined, serverProperties);
    var parsedParams = {};
    shared_utils_1.forEachObjectEntry(type.PARAM_SPEC, function (paramSpec, paramName) {
        if (isServer && paramSpec.noServer) {
            return;
        }
        if (!isServer && paramSpec.noClient) {
            return;
        }
        if (paramName in params) {
            var param = params[paramName];
            if (param !== undefined) {
                if (type.checkParam(param, paramSpec, serverProperties)) {
                    parsedParams[paramName] = {
                        value: param,
                        trailing: Boolean(paramSpec.trailing)
                    };
                }
                else if (!paramSpec.optional) {
                    throw new Error("required parameter \"" + paramName + "\" did not suit requirements: \"" + param + "\"");
                }
            }
        }
        if (!(paramName in parsedParams) && !paramSpec.optional) {
            throw new Error("required parameter \"" + paramName + "\" not found in command \"" + type.COMMAND + "\"");
        }
    });
    Object.assign(message, parsedParams);
    message._initPrefixAndTags(prefix, tags);
    return message;
}
exports.createMessage = createMessage;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var Message = /** @class */ (function () {
    function Message(command, params, tags, prefix, serverProperties, rawLine, isServer, shouldParseParams) {
        if (serverProperties === void 0) { serverProperties = ServerProperties_1.defaultServerProperties; }
        if (isServer === void 0) { isServer = false; }
        if (shouldParseParams === void 0) { shouldParseParams = true; }
        this._params = [];
        this._serverProperties = ServerProperties_1.defaultServerProperties;
        this._command = command;
        this._params = params;
        this._tags = tags || new Map();
        this._prefix = prefix;
        this._serverProperties = serverProperties;
        this._raw = rawLine;
        if (shouldParseParams) {
            this.parseParams(isServer);
        }
    }
    Message.checkParam = function (param, spec, serverProperties) {
        if (serverProperties === void 0) { serverProperties = ServerProperties_1.defaultServerProperties; }
        if (spec.type === 'channel') {
            if (!StringTools_1.isChannel(param, serverProperties.channelTypes)) {
                return false;
            }
        }
        if (spec.type === 'channelList') {
            var channels = param.split(',');
            if (!channels.every(function (chan) { return StringTools_1.isChannel(chan, serverProperties.channelTypes); })) {
                return false;
            }
        }
        if (spec.match) {
            if (!spec.match.test(param)) {
                return false;
            }
        }
        return true;
    };
    Message.getMinParamCount = function (isServer) {
        if (isServer === void 0) { isServer = false; }
        if (!this.PARAM_SPEC) {
            return 0;
        }
        return Object.values(this.PARAM_SPEC).filter(function (spec) {
            if (spec.noServer && isServer) {
                return false;
            }
            if (spec.noClient && !isServer) {
                return false;
            }
            return !spec.optional;
        }).length;
    };
    Message.prototype.prefixToString = function () {
        if (!this._prefix) {
            return '';
        }
        return prefixToString(this._prefix);
    };
    Message.prototype.tagsToString = function () {
        if (!this._tags) {
            return '';
        }
        return __spread(this._tags.entries()).map(function (_a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            return (value ? key + "=" + escapeTag(value) : key);
        }).join(';');
    };
    Message.prototype.toString = function (complete) {
        var _this = this;
        if (complete === void 0) { complete = false; }
        var cls = this.constructor;
        var specKeys = Object.keys(cls.PARAM_SPEC);
        var fullCommand = __spread([
            this._command
        ], specKeys
            .map(function (paramName) {
            // TS inference does really not help here... so this is any for now
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var param = _this[paramName];
            if (param) {
                return (param.trailing ? ':' : '') + param.value;
            }
            return undefined;
        })
            .filter(function (param) { return param !== undefined; })).join(' ');
        if (!complete) {
            return fullCommand;
        }
        var parts = [fullCommand];
        var prefix = this.prefixToString();
        if (prefix) {
            parts.unshift(":" + prefix);
        }
        var tags = this.tagsToString();
        if (tags) {
            parts.unshift("@" + tags);
        }
        return parts.join(' ');
    };
    /** @private */
    Message.prototype._initPrefixAndTags = function (prefix, tags) {
        this._prefix = prefix;
        if (tags) {
            this._tags = tags;
        }
    };
    Message.prototype.parseParams = function (isServer) {
        var e_1, _a;
        if (isServer === void 0) { isServer = false; }
        if (this._params) {
            var cls = this.constructor;
            var requiredParamsLeft = cls.getMinParamCount(isServer);
            if (requiredParamsLeft > this._params.length) {
                throw new NotEnoughParametersError_1.default(this._command, requiredParamsLeft, this._params.length);
            }
            var paramSpecList = cls.PARAM_SPEC;
            if (!paramSpecList) {
                return;
            }
            var i = 0;
            var parsedParams = {};
            try {
                for (var _b = __values(Object.entries(paramSpecList)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), paramName = _d[0], paramSpec = _d[1];
                    if (paramSpec.noServer && isServer) {
                        continue;
                    }
                    if (paramSpec.noClient && !isServer) {
                        continue;
                    }
                    if (this._params.length - i <= requiredParamsLeft) {
                        if (paramSpec.optional) {
                            continue;
                        }
                        else if (this._params.length - i !== requiredParamsLeft) {
                            throw new Error('not enough parameters left for required parameters parsing (this is a library bug)');
                        }
                    }
                    var param = this._params[i];
                    if (!param) {
                        if (paramSpec.optional) {
                            break;
                        }
                        throw new Error('unexpected parameter underflow');
                    }
                    if (paramSpec.rest) {
                        var restParams = [];
                        while (this._params[i] && !this._params[i].trailing) {
                            restParams.push(this._params[i].value);
                            ++i;
                        }
                        if (!restParams.length) {
                            if (paramSpec.optional) {
                                continue;
                            }
                            throw new Error("no parameters left for required rest parameter \"" + paramName + "\"");
                        }
                        param = {
                            value: restParams.join(' '),
                            trailing: false
                        };
                    }
                    if (Message.checkParam(param.value, paramSpec)) {
                        parsedParams[paramName] = __assign({}, param);
                        if (!paramSpec.optional) {
                            --requiredParamsLeft;
                        }
                        if (!paramSpec.rest) {
                            ++i;
                        }
                    }
                    else if (!paramSpec.optional) {
                        throw new ParameterRequirementMismatchError_1.default(this._command, paramName, paramSpec, param.value);
                    }
                    if (paramSpec.trailing) {
                        break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            Object.assign(this, parsedParams);
        }
    };
    Object.defineProperty(Message.prototype, "params", {
        get: function () {
            var _this = this;
            var cls = this.constructor;
            var specKeys = Object.keys(cls.PARAM_SPEC);
            return Object.assign.apply(Object, __spread([{}], specKeys
                .map(function (paramName) {
                // TS inference does really not help here... so this is any for now
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var param = _this[paramName];
                if (param) {
                    return [paramName, param.value];
                }
                return undefined;
            })
                .filter(function (pair) { return pair !== undefined; })
                .map(function (_a) {
                var _b;
                var _c = __read(_a, 2), key = _c[0], value = _c[1];
                return (_b = {}, _b[key] = value, _b);
            })));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Message.prototype, "prefix", {
        get: function () {
            return this._prefix;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Message.prototype, "command", {
        get: function () {
            return this._command;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Message.prototype, "tags", {
        get: function () {
            return this._tags;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Message.prototype, "rawLine", {
        get: function () {
            return this._raw;
        },
        enumerable: true,
        configurable: true
    });
    Message.prototype.isResponseTo = function (originalMessage) {
        return false;
    };
    Message.prototype.endsResponseTo = function (originalMessage) {
        return false;
    };
    Message.prototype._acceptsInReplyCollection = function (message) {
        // TODO implement IRCv3 labeled-response / batch here
        return message.isResponseTo(this);
    };
    Message.COMMAND = '';
    Message.SUPPORTS_CAPTURE = false;
    return Message;
}());
exports.default = Message;

},{"../Errors/NotEnoughParametersError":112,"../Errors/ParameterRequirementMismatchError":113,"../ServerProperties":189,"../Toolkit/StringTools":190,"@d-fischer/shared-utils":36}],117:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var MessageCollector = /** @class */ (function () {
    function MessageCollector(_client, _originalMessage) {
        var types = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            types[_i - 2] = arguments[_i];
        }
        this._client = _client;
        this._originalMessage = _originalMessage;
        this._messages = [];
        this._endEventHandlers = new Map();
        this._types = new Set(types);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    MessageCollector.prototype.untilEvent = function (eventType) {
        var _this = this;
        this._cleanEndEventHandler(eventType);
        var listener = this._client.on(eventType, function () { return _this.end(); });
        this._endEventHandlers.set(eventType, listener);
    };
    MessageCollector.prototype.promise = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (!this._promise) {
                    this._promise = new Promise(function (resolve) { return (_this._promiseResolve = resolve); });
                }
                return [2 /*return*/, this._promise];
            });
        });
    };
    MessageCollector.prototype.collect = function (message) {
        if (!this._originalMessage._acceptsInReplyCollection(message)) {
            return false;
        }
        this._messages.push(message);
        if (message.endsResponseTo(this._originalMessage)) {
            this.end();
        }
        return true;
    };
    MessageCollector.prototype.end = function () {
        this._client.stopCollect(this);
        this._cleanEndEventHandlers();
        if (this._promiseResolve) {
            this._promiseResolve(this._messages);
        }
    };
    MessageCollector.prototype._cleanEndEventHandlers = function () {
        var _this = this;
        this._endEventHandlers.forEach(function (listener) { return _this._client.removeListener(listener); });
        this._endEventHandlers.clear();
    };
    MessageCollector.prototype._cleanEndEventHandler = function (eventType) {
        if (this._endEventHandlers.has(eventType)) {
            this._client.removeListener(this._endEventHandlers.get(eventType));
            this._endEventHandlers.delete(eventType);
        }
    };
    return MessageCollector;
}());
exports.default = MessageCollector;

},{}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("./Message");
var isMessageType = function (ctor) {
    return Object.prototype.isPrototypeOf.call(Message_1.default, ctor);
};
exports.MessageType = function (commandName) { return function (target) {
    if (!isMessageType(target)) {
        throw new Error('You need to extend the Message class to use the MessageType decorator');
    }
    target.COMMAND = commandName;
}; };
exports.MessageParamDefinition = function (spec) {
    if (spec === void 0) { spec = {}; }
    return function (target, propertyKey) {
        if (!(target instanceof Message_1.default)) {
            throw new Error('You need to extend the Message class to use the MessageParam decorator');
        }
        if (typeof propertyKey !== 'string') {
            return;
        }
        var cls = target.constructor;
        if (!cls.PARAM_SPEC) {
            cls.PARAM_SPEC = {};
        }
        cls.PARAM_SPEC[propertyKey] = spec;
    };
};

},{"./Message":116}],119:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var shared_utils_1 = require("@d-fischer/shared-utils");
var ServerProperties_1 = require("../ServerProperties");
var Message_1 = require("./Message");
var MessageTypes_1 = require("./MessageTypes");
function parsePrefix(raw) {
    var _a = __read(shared_utils_1.splitWithLimit(raw, '!', 2), 2), nick = _a[0], hostName = _a[1];
    if (hostName) {
        var _b = __read(shared_utils_1.splitWithLimit(hostName, '@', 2), 2), user = _b[0], host = _b[1];
        if (host) {
            return { nick: nick, user: user, host: host };
        }
        else {
            return { nick: nick, host: user };
        }
    }
    else {
        return { nick: nick };
    }
}
exports.parsePrefix = parsePrefix;
var tagUnescapeMap = {
    ':': ';',
    n: '\n',
    r: '\r',
    s: ' '
};
function parseTags(raw) {
    var e_1, _a;
    var tags = new Map();
    var tagStrings = raw.split(';');
    try {
        for (var tagStrings_1 = __values(tagStrings), tagStrings_1_1 = tagStrings_1.next(); !tagStrings_1_1.done; tagStrings_1_1 = tagStrings_1.next()) {
            var tagString = tagStrings_1_1.value;
            var _b = __read(shared_utils_1.splitWithLimit(tagString, '=', 2), 2), tagName = _b[0], tagValue = _b[1];
            if (tagName === '') {
                continue; // Ignore empty tags: @ @; @x; etc.
            }
            // unescape according to http://ircv3.net/specs/core/message-tags-3.2.html#escaping-values
            tags.set(tagName, tagValue
                ? tagValue.replace(/\\(.?)/g, function (_, match) {
                    return Object.prototype.hasOwnProperty.call(tagUnescapeMap, match) ? tagUnescapeMap[match] : match;
                })
                : '');
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (tagStrings_1_1 && !tagStrings_1_1.done && (_a = tagStrings_1.return)) _a.call(tagStrings_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return tags;
}
exports.parseTags = parseTags;
function parseMessage(line, serverProperties, knownCommands, isServer, nonConformingCommands) {
    if (serverProperties === void 0) { serverProperties = ServerProperties_1.defaultServerProperties; }
    if (knownCommands === void 0) { knownCommands = MessageTypes_1.all; }
    if (isServer === void 0) { isServer = false; }
    if (nonConformingCommands === void 0) { nonConformingCommands = []; }
    var splitLine = line.split(' ');
    var token;
    var command;
    var params = [];
    var tags;
    var prefix;
    while (splitLine.length) {
        token = splitLine[0];
        if (token[0] === '@' && !tags && !command && !prefix) {
            tags = parseTags(token.substr(1));
        }
        else if (token[0] === ':') {
            if (!prefix && !command) {
                if (token.length > 1) {
                    // Not an empty prefix
                    prefix = parsePrefix(token.substr(1));
                }
            }
            else {
                params.push({
                    value: splitLine.join(' ').substr(1),
                    trailing: true
                });
                break;
            }
        }
        else if (command) {
            params.push({
                value: token,
                trailing: false
            });
        }
        else {
            command = token.toUpperCase();
        }
        splitLine.shift();
    }
    if (!tags) {
        tags = new Map();
    }
    if (!command) {
        throw new Error("line without command received: " + line);
    }
    var messageClass = Message_1.default;
    if (knownCommands.has(command)) {
        messageClass = knownCommands.get(command);
    }
    return new messageClass(command, params, tags, prefix, serverProperties, line, isServer, !nonConformingCommands.includes(command));
}
exports.parseMessage = parseMessage;

},{"../ServerProperties":189,"./Message":116,"./MessageTypes":188,"@d-fischer/shared-utils":36}],120:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Away = /** @class */ (function (_super) {
    __extends(Away, _super);
    function Away() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition()
    ], Away.prototype, "message", void 0);
    Away = __decorate([
        MessageDefinition_1.MessageType('AWAY')
    ], Away);
    return Away;
}(Message_1.default));
exports.default = Away;

},{"../../Message":116,"../../MessageDefinition":118}],121:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var CapabilityNegotiation = /** @class */ (function (_super) {
    __extends(CapabilityNegotiation, _super);
    function CapabilityNegotiation() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CapabilityNegotiation_1 = CapabilityNegotiation;
    CapabilityNegotiation.prototype.isResponseTo = function (originalMessage) {
        if (!(originalMessage instanceof CapabilityNegotiation_1)) {
            return false;
        }
        switch (this.params.subCommand) {
            case 'ACK':
            case 'NAK': {
                // trim is necessary because some networks seem to add trailing spaces (looking at you, Freenode)...
                return (originalMessage.params.subCommand === 'REQ' &&
                    originalMessage.params.capabilities === this.params.capabilities.trim());
            }
            case 'LS':
            case 'LIST': {
                return originalMessage.params.subCommand === this.params.subCommand;
            }
            default: {
                return false;
            }
        }
    };
    CapabilityNegotiation.prototype.endsResponseTo = function (originalMessage) {
        if (!(originalMessage instanceof CapabilityNegotiation_1)) {
            return false;
        }
        switch (this.params.subCommand) {
            case 'LS':
            case 'LIST': {
                return !this.params.continued;
            }
            default: {
                return true;
            }
        }
    };
    var CapabilityNegotiation_1;
    CapabilityNegotiation.SUPPORTS_CAPTURE = true;
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            match: /^(?:[a-z_\-\[\]\\^{}|`][a-z0-9_\-\[\]\\^{}|`]+|\*)$/i,
            optional: true,
            noClient: true
        })
    ], CapabilityNegotiation.prototype, "target", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            match: /^(?:LS|LIST|REQ|ACK|NAK|END|NEW|DEL)$/i
        })
    ], CapabilityNegotiation.prototype, "subCommand", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            match: /^\d+$/,
            optional: true
        })
    ], CapabilityNegotiation.prototype, "version", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            match: /^\*$/,
            optional: true
        })
    ], CapabilityNegotiation.prototype, "continued", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true,
            optional: true
        })
    ], CapabilityNegotiation.prototype, "capabilities", void 0);
    CapabilityNegotiation = CapabilityNegotiation_1 = __decorate([
        MessageDefinition_1.MessageType('CAP')
    ], CapabilityNegotiation);
    return CapabilityNegotiation;
}(Message_1.default));
exports.default = CapabilityNegotiation;

},{"../../Message":116,"../../MessageDefinition":118}],122:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var ChannelInvite = /** @class */ (function (_super) {
    __extends(ChannelInvite, _super);
    function ChannelInvite() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], ChannelInvite.prototype, "target", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            type: 'channel'
        })
    ], ChannelInvite.prototype, "channel", void 0);
    ChannelInvite = __decorate([
        MessageDefinition_1.MessageType('INVITE')
    ], ChannelInvite);
    return ChannelInvite;
}(Message_1.default));
exports.default = ChannelInvite;

},{"../../Message":116,"../../MessageDefinition":118}],123:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var ChannelJoin = /** @class */ (function (_super) {
    __extends(ChannelJoin, _super);
    function ChannelJoin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            type: 'channel'
        })
    ], ChannelJoin.prototype, "channel", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            optional: true
        })
    ], ChannelJoin.prototype, "key", void 0);
    ChannelJoin = __decorate([
        MessageDefinition_1.MessageType('JOIN')
    ], ChannelJoin);
    return ChannelJoin;
}(Message_1.default));
exports.default = ChannelJoin;

},{"../../Message":116,"../../MessageDefinition":118}],124:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var ChannelKick = /** @class */ (function (_super) {
    __extends(ChannelKick, _super);
    function ChannelKick() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            type: 'channel'
        })
    ], ChannelKick.prototype, "channel", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], ChannelKick.prototype, "target", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true,
            optional: true
        })
    ], ChannelKick.prototype, "comment", void 0);
    ChannelKick = __decorate([
        MessageDefinition_1.MessageType('KICK')
    ], ChannelKick);
    return ChannelKick;
}(Message_1.default));
exports.default = ChannelKick;

},{"../../Message":116,"../../MessageDefinition":118}],125:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var ChannelList = /** @class */ (function (_super) {
    __extends(ChannelList, _super);
    function ChannelList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            type: 'channel',
            optional: true
        })
    ], ChannelList.prototype, "channel", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            optional: true
        })
    ], ChannelList.prototype, "server", void 0);
    ChannelList = __decorate([
        MessageDefinition_1.MessageType('LIST')
    ], ChannelList);
    return ChannelList;
}(Message_1.default));
exports.default = ChannelList;

},{"../../Message":116,"../../MessageDefinition":118}],126:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var ChannelPart = /** @class */ (function (_super) {
    __extends(ChannelPart, _super);
    function ChannelPart() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            type: 'channel'
        })
    ], ChannelPart.prototype, "channel", void 0);
    ChannelPart = __decorate([
        MessageDefinition_1.MessageType('PART')
    ], ChannelPart);
    return ChannelPart;
}(Message_1.default));
exports.default = ChannelPart;

},{"../../Message":116,"../../MessageDefinition":118}],127:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var ClientQuit = /** @class */ (function (_super) {
    __extends(ClientQuit, _super);
    function ClientQuit() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true,
            optional: true
        })
    ], ClientQuit.prototype, "message", void 0);
    ClientQuit = __decorate([
        MessageDefinition_1.MessageType('QUIT')
    ], ClientQuit);
    return ClientQuit;
}(Message_1.default));
exports.default = ClientQuit;

},{"../../Message":116,"../../MessageDefinition":118}],128:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var ErrorMessage = /** @class */ (function (_super) {
    __extends(ErrorMessage, _super);
    function ErrorMessage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], ErrorMessage.prototype, "message", void 0);
    ErrorMessage = __decorate([
        MessageDefinition_1.MessageType('ERROR')
    ], ErrorMessage);
    return ErrorMessage;
}(Message_1.default));
exports.default = ErrorMessage;

},{"../../Message":116,"../../MessageDefinition":118}],129:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var IsOnQuery = /** @class */ (function (_super) {
    __extends(IsOnQuery, _super);
    function IsOnQuery() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            rest: true
        })
    ], IsOnQuery.prototype, "nicks", void 0);
    IsOnQuery = __decorate([
        MessageDefinition_1.MessageType('ISON')
    ], IsOnQuery);
    return IsOnQuery;
}(Message_1.default));
exports.default = IsOnQuery;

},{"../../Message":116,"../../MessageDefinition":118}],130:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Kill = /** @class */ (function (_super) {
    __extends(Kill, _super);
    function Kill() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Kill.prototype, "target", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true,
            optional: true
        })
    ], Kill.prototype, "comment", void 0);
    Kill = __decorate([
        MessageDefinition_1.MessageType('KILL')
    ], Kill);
    return Kill;
}(Message_1.default));
exports.default = Kill;

},{"../../Message":116,"../../MessageDefinition":118}],131:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
var UnknownChannelModeCharError_1 = require("../../../Errors/UnknownChannelModeCharError");
var StringTools_1 = require("../../../Toolkit/StringTools");
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Mode = /** @class */ (function (_super) {
    __extends(Mode, _super);
    function Mode() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Mode.prototype, "isChannel", {
        get: function () {
            return StringTools_1.isChannel(this.params.target, this._serverProperties.channelTypes);
        },
        enumerable: true,
        configurable: true
    });
    Mode.prototype.separate = function () {
        var e_1, _a;
        var result = [];
        var modeRestParam = this.params.modes;
        if (!modeRestParam) {
            throw new Error("can't separate a channel mode request, just set actions");
        }
        var modeParams = modeRestParam.split(' ');
        var modes = modeParams.shift();
        var currentModeAction = 'add';
        try {
            for (var modes_1 = __values(modes), modes_1_1 = modes_1.next(); !modes_1_1.done; modes_1_1 = modes_1.next()) {
                var ch = modes_1_1.value;
                var thisModeAction = currentModeAction;
                switch (ch) {
                    case '+': {
                        currentModeAction = 'add';
                        break;
                    }
                    case '-': {
                        currentModeAction = 'remove';
                        break;
                    }
                    default: {
                        var requiresParam = false;
                        var known = true;
                        if (this.isChannel) {
                            if (this._serverProperties.supportedChannelModes.alwaysWithParam.includes(ch) ||
                                this._serverProperties.supportedChannelModes.prefix.includes(ch)) {
                                requiresParam = true;
                            }
                            else if (this._serverProperties.supportedChannelModes.paramWhenSet.includes(ch)) {
                                if (currentModeAction === 'add') {
                                    requiresParam = true;
                                }
                            }
                            else if (this._serverProperties.supportedChannelModes.list.includes(ch)) {
                                if (modeParams.length) {
                                    requiresParam = true;
                                }
                                else {
                                    thisModeAction = 'getList';
                                }
                            }
                            else if (this._serverProperties.supportedChannelModes.noParam.includes(ch)) {
                                // whatever
                            }
                            else {
                                throw new UnknownChannelModeCharError_1.default(ch);
                            }
                        }
                        else {
                            // user modes never have a param
                            // also, they don't break the whole command if invalid mode letters are given
                            known = this._serverProperties.supportedUserModes.includes(ch);
                        }
                        if (requiresParam && !modeParams.length) {
                            continue;
                        }
                        result.push({
                            prefix: this._prefix,
                            action: thisModeAction,
                            letter: ch,
                            param: requiresParam ? modeParams.shift() : undefined,
                            known: known
                        });
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (modes_1_1 && !modes_1_1.done && (_a = modes_1.return)) _a.call(modes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    };
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Mode.prototype, "target", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            rest: true,
            optional: true
        })
    ], Mode.prototype, "modes", void 0);
    Mode = __decorate([
        MessageDefinition_1.MessageType('MODE')
    ], Mode);
    return Mode;
}(Message_1.default));
exports.default = Mode;

},{"../../../Errors/UnknownChannelModeCharError":114,"../../../Toolkit/StringTools":190,"../../Message":116,"../../MessageDefinition":118}],132:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Names = /** @class */ (function (_super) {
    __extends(Names, _super);
    function Names() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Names.SUPPORTS_CAPTURE = true;
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            type: 'channelList',
            optional: true
        })
    ], Names.prototype, "channel", void 0);
    Names = __decorate([
        MessageDefinition_1.MessageType('NAMES')
    ], Names);
    return Names;
}(Message_1.default));
exports.default = Names;

},{"../../Message":116,"../../MessageDefinition":118}],133:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var NickChange = /** @class */ (function (_super) {
    __extends(NickChange, _super);
    function NickChange() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], NickChange.prototype, "nick", void 0);
    NickChange = __decorate([
        MessageDefinition_1.MessageType('NICK')
    ], NickChange);
    return NickChange;
}(Message_1.default));
exports.default = NickChange;

},{"../../Message":116,"../../MessageDefinition":118}],134:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Notice = /** @class */ (function (_super) {
    __extends(Notice, _super);
    function Notice() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Notice.prototype, "target", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Notice.prototype, "message", void 0);
    Notice = __decorate([
        MessageDefinition_1.MessageType('NOTICE')
    ], Notice);
    return Notice;
}(Message_1.default));
exports.default = Notice;

},{"../../Message":116,"../../MessageDefinition":118}],135:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var OperLogin = /** @class */ (function (_super) {
    __extends(OperLogin, _super);
    function OperLogin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], OperLogin.prototype, "name", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], OperLogin.prototype, "password", void 0);
    OperLogin = __decorate([
        MessageDefinition_1.MessageType('OPER')
    ], OperLogin);
    return OperLogin;
}(Message_1.default));
exports.default = OperLogin;

},{"../../Message":116,"../../MessageDefinition":118}],136:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Password = /** @class */ (function (_super) {
    __extends(Password, _super);
    function Password() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Password.prototype, "password", void 0);
    Password = __decorate([
        MessageDefinition_1.MessageType('PASS')
    ], Password);
    return Password;
}(Message_1.default));
exports.default = Password;

},{"../../Message":116,"../../MessageDefinition":118}],137:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Ping = /** @class */ (function (_super) {
    __extends(Ping, _super);
    function Ping() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Ping.prototype, "message", void 0);
    Ping = __decorate([
        MessageDefinition_1.MessageType('PING')
    ], Ping);
    return Ping;
}(Message_1.default));
exports.default = Ping;

},{"../../Message":116,"../../MessageDefinition":118}],138:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Pong = /** @class */ (function (_super) {
    __extends(Pong, _super);
    function Pong() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            noClient: true
        })
    ], Pong.prototype, "server", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Pong.prototype, "message", void 0);
    Pong = __decorate([
        MessageDefinition_1.MessageType('PONG')
    ], Pong);
    return Pong;
}(Message_1.default));
exports.default = Pong;

},{"../../Message":116,"../../MessageDefinition":118}],139:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var PrivateMessage = /** @class */ (function (_super) {
    __extends(PrivateMessage, _super);
    function PrivateMessage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], PrivateMessage.prototype, "target", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], PrivateMessage.prototype, "message", void 0);
    PrivateMessage = __decorate([
        MessageDefinition_1.MessageType('PRIVMSG')
    ], PrivateMessage);
    return PrivateMessage;
}(Message_1.default));
exports.default = PrivateMessage;

},{"../../Message":116,"../../MessageDefinition":118}],140:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Rehash = /** @class */ (function (_super) {
    __extends(Rehash, _super);
    function Rehash() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rehash = __decorate([
        MessageDefinition_1.MessageType('REHASH')
    ], Rehash);
    return Rehash;
}(Message_1.default));
exports.default = Rehash;

},{"../../Message":116,"../../MessageDefinition":118}],141:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Restart = /** @class */ (function (_super) {
    __extends(Restart, _super);
    function Restart() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Restart = __decorate([
        MessageDefinition_1.MessageType('RESTART')
    ], Restart);
    return Restart;
}(Message_1.default));
exports.default = Restart;

},{"../../Message":116,"../../MessageDefinition":118}],142:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var ServerQuit = /** @class */ (function (_super) {
    __extends(ServerQuit, _super);
    function ServerQuit() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], ServerQuit.prototype, "server", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], ServerQuit.prototype, "message", void 0);
    ServerQuit = __decorate([
        MessageDefinition_1.MessageType('SQUIT')
    ], ServerQuit);
    return ServerQuit;
}(Message_1.default));
exports.default = ServerQuit;

},{"../../Message":116,"../../MessageDefinition":118}],143:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Topic = /** @class */ (function (_super) {
    __extends(Topic, _super);
    function Topic() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            type: 'channel'
        })
    ], Topic.prototype, "channel", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            optional: true,
            trailing: true
        })
    ], Topic.prototype, "newTopic", void 0);
    Topic = __decorate([
        MessageDefinition_1.MessageType('TOPIC')
    ], Topic);
    return Topic;
}(Message_1.default));
exports.default = Topic;

},{"../../Message":116,"../../MessageDefinition":118}],144:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var UserHostQuery = /** @class */ (function (_super) {
    __extends(UserHostQuery, _super);
    function UserHostQuery() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            rest: true
        })
    ], UserHostQuery.prototype, "nicks", void 0);
    UserHostQuery = __decorate([
        MessageDefinition_1.MessageType('USERHOST')
    ], UserHostQuery);
    return UserHostQuery;
}(Message_1.default));
exports.default = UserHostQuery;

},{"../../Message":116,"../../MessageDefinition":118}],145:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var UserRegistration = /** @class */ (function (_super) {
    __extends(UserRegistration, _super);
    function UserRegistration() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], UserRegistration.prototype, "user", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], UserRegistration.prototype, "mode", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], UserRegistration.prototype, "unused", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], UserRegistration.prototype, "realName", void 0);
    UserRegistration = __decorate([
        MessageDefinition_1.MessageType('USER')
    ], UserRegistration);
    return UserRegistration;
}(Message_1.default));
exports.default = UserRegistration;

},{"../../Message":116,"../../MessageDefinition":118}],146:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var WallopsMessage = /** @class */ (function (_super) {
    __extends(WallopsMessage, _super);
    function WallopsMessage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], WallopsMessage.prototype, "message", void 0);
    WallopsMessage = __decorate([
        MessageDefinition_1.MessageType('WALLOPS')
    ], WallopsMessage);
    return WallopsMessage;
}(Message_1.default));
exports.default = WallopsMessage;

},{"../../Message":116,"../../MessageDefinition":118}],147:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var WhoIsQuery = /** @class */ (function (_super) {
    __extends(WhoIsQuery, _super);
    function WhoIsQuery() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            optional: true
        })
    ], WhoIsQuery.prototype, "server", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], WhoIsQuery.prototype, "nickMask", void 0);
    WhoIsQuery = __decorate([
        MessageDefinition_1.MessageType('WHOIS')
    ], WhoIsQuery);
    return WhoIsQuery;
}(Message_1.default));
exports.default = WhoIsQuery;

},{"../../Message":116,"../../MessageDefinition":118}],148:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var WhoQuery = /** @class */ (function (_super) {
    __extends(WhoQuery, _super);
    function WhoQuery() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            optional: true
        })
    ], WhoQuery.prototype, "mask", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            rest: true
        })
    ], WhoQuery.prototype, "flags", void 0);
    WhoQuery = __decorate([
        MessageDefinition_1.MessageType('WHO')
    ], WhoQuery);
    return WhoQuery;
}(Message_1.default));
exports.default = WhoQuery;

},{"../../Message":116,"../../MessageDefinition":118}],149:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var WhoWasQuery = /** @class */ (function (_super) {
    __extends(WhoWasQuery, _super);
    function WhoWasQuery() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], WhoWasQuery.prototype, "nickname", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            optional: true
        })
    ], WhoWasQuery.prototype, "count", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            optional: true
        })
    ], WhoWasQuery.prototype, "server", void 0);
    WhoWasQuery = __decorate([
        MessageDefinition_1.MessageType('WHOWAS')
    ], WhoWasQuery);
    return WhoWasQuery;
}(Message_1.default));
exports.default = WhoWasQuery;

},{"../../Message":116,"../../MessageDefinition":118}],150:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// region RFC1459
// region 4 Message details
// region 4.1 Connection Registration
// 4.1.1 Password message
var Password_1 = require("./Password");
exports.Password = Password_1.default;
// 4.1.2 Nickname message
var NickChange_1 = require("./NickChange");
exports.NickChange = NickChange_1.default;
// 4.1.3 User message
var UserRegistration_1 = require("./UserRegistration");
exports.UserRegistration = UserRegistration_1.default;
// 4.1.4 Server message
// We can't be a server yet
// 4.1.5 Operator message
var OperLogin_1 = require("./OperLogin");
exports.OperLogin = OperLogin_1.default;
// 4.1.6 Quit message
var ClientQuit_1 = require("./ClientQuit");
exports.ClientQuit = ClientQuit_1.default;
// 4.1.7 Server Quit message
var ServerQuit_1 = require("./ServerQuit");
exports.ServerQuit = ServerQuit_1.default;
// endregion
// region 4.2 Channel operations
// 4.2.1 Join message
var ChannelJoin_1 = require("./ChannelJoin");
exports.ChannelJoin = ChannelJoin_1.default;
// 4.2.2 Part message
var ChannelPart_1 = require("./ChannelPart");
exports.ChannelPart = ChannelPart_1.default;
// 4.2.3 Mode message
var Mode_1 = require("./Mode");
exports.Mode = Mode_1.default;
// 4.2.4 Topic message
var Topic_1 = require("./Topic");
exports.Topic = Topic_1.default;
// 4.2.5 Names message
var Names_1 = require("./Names");
exports.Names = Names_1.default;
// 4.2.6 List message
var ChannelList_1 = require("./ChannelList");
exports.ChannelList = ChannelList_1.default;
// 4.2.7 Invite message
var ChannelInvite_1 = require("./ChannelInvite");
exports.ChannelInvite = ChannelInvite_1.default;
// 4.2.8 Kick message
var ChannelKick_1 = require("./ChannelKick");
exports.ChannelKick = ChannelKick_1.default;
// endregion
// region 4.3 Server queries and commands
// TODO
// endregion
// region 4.4 Sending messages
// 4.4.1 Private messages
var PrivateMessage_1 = require("./PrivateMessage");
exports.PrivateMessage = PrivateMessage_1.default;
// 4.4.2 Notice messages
var Notice_1 = require("./Notice");
exports.Notice = Notice_1.default;
// endregion
// region 4.5 User-based queries
// 4.5.1 Who query
var WhoQuery_1 = require("./WhoQuery");
exports.WhoQuery = WhoQuery_1.default;
// 4.5.2 Whois query
var WhoIsQuery_1 = require("./WhoIsQuery");
exports.WhoIsQuery = WhoIsQuery_1.default;
// 4.5.3 Whowas
var WhoWasQuery_1 = require("./WhoWasQuery");
exports.WhoWasQuery = WhoWasQuery_1.default;
// endregion
// region 4.6 Miscellaneous messages
// 4.6.1 Kill message
var Kill_1 = require("./Kill");
exports.Kill = Kill_1.default;
// 4.6.2 Ping message
var Ping_1 = require("./Ping");
exports.Ping = Ping_1.default;
// 4.6.3 Pong message
var Pong_1 = require("./Pong");
exports.Pong = Pong_1.default;
// 4.6.4 Error message
var ErrorMessage_1 = require("./ErrorMessage");
exports.ErrorMessage = ErrorMessage_1.default;
// endregion
// endregion
// region 5 Optionals
// 5.1 Away
var Away_1 = require("./Away");
exports.Away = Away_1.default;
// 5.2 Rehash message
var Rehash_1 = require("./Rehash");
exports.Rehash = Rehash_1.default;
// 5.3 Restart message
var Restart_1 = require("./Restart");
exports.Restart = Restart_1.default;
// 5.4 Summon message
// really, would anyone use that?
// 5.5 Users message
// would anyone WANT to have that? it seems like a huge security risk.
// 5.6 Operwall message
var WallopsMessage_1 = require("./WallopsMessage");
exports.Wallops = WallopsMessage_1.default;
// 5.7 Userhost message
var UserHostQuery_1 = require("./UserHostQuery");
exports.UserHostQuery = UserHostQuery_1.default;
// 5.8 Ison message
var IsOnQuery_1 = require("./IsOnQuery");
exports.IsOnQuery = IsOnQuery_1.default;
// endregion
// endregion
// region IRCv3
// Capability Negotiation
var CapabilityNegotiation_1 = require("./CapabilityNegotiation");
exports.CapabilityNegotiation = CapabilityNegotiation_1.default;
// endregion

},{"./Away":120,"./CapabilityNegotiation":121,"./ChannelInvite":122,"./ChannelJoin":123,"./ChannelKick":124,"./ChannelList":125,"./ChannelPart":126,"./ClientQuit":127,"./ErrorMessage":128,"./IsOnQuery":129,"./Kill":130,"./Mode":131,"./Names":132,"./NickChange":133,"./Notice":134,"./OperLogin":135,"./Password":136,"./Ping":137,"./Pong":138,"./PrivateMessage":139,"./Rehash":140,"./Restart":141,"./ServerQuit":142,"./Topic":143,"./UserHostQuery":144,"./UserRegistration":145,"./WallopsMessage":146,"./WhoIsQuery":147,"./WhoQuery":148,"./WhoWasQuery":149}],151:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error401NoSuchNick = /** @class */ (function (_super) {
    __extends(Error401NoSuchNick, _super);
    function Error401NoSuchNick() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error401NoSuchNick.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error401NoSuchNick.prototype, "nick", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error401NoSuchNick.prototype, "suffix", void 0);
    Error401NoSuchNick = __decorate([
        MessageDefinition_1.MessageType('401')
    ], Error401NoSuchNick);
    return Error401NoSuchNick;
}(Message_1.default));
exports.default = Error401NoSuchNick;

},{"../../Message":116,"../../MessageDefinition":118}],152:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error403NoSuchChannel = /** @class */ (function (_super) {
    __extends(Error403NoSuchChannel, _super);
    function Error403NoSuchChannel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error403NoSuchChannel.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
        // channel type is wrong here - this numeric is also used for showing the user this is *not* a valid channel name
        // type: 'channel'
        })
    ], Error403NoSuchChannel.prototype, "channel", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error403NoSuchChannel.prototype, "suffix", void 0);
    Error403NoSuchChannel = __decorate([
        MessageDefinition_1.MessageType('403')
    ], Error403NoSuchChannel);
    return Error403NoSuchChannel;
}(Message_1.default));
exports.default = Error403NoSuchChannel;

},{"../../Message":116,"../../MessageDefinition":118}],153:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error404CanNotSendToChan = /** @class */ (function (_super) {
    __extends(Error404CanNotSendToChan, _super);
    function Error404CanNotSendToChan() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error404CanNotSendToChan.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            type: 'channel'
        })
    ], Error404CanNotSendToChan.prototype, "channel", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error404CanNotSendToChan.prototype, "suffix", void 0);
    Error404CanNotSendToChan = __decorate([
        MessageDefinition_1.MessageType('404')
    ], Error404CanNotSendToChan);
    return Error404CanNotSendToChan;
}(Message_1.default));
exports.default = Error404CanNotSendToChan;

},{"../../Message":116,"../../MessageDefinition":118}],154:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error421UnknownCommand = /** @class */ (function (_super) {
    __extends(Error421UnknownCommand, _super);
    function Error421UnknownCommand() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Error421UnknownCommand.prototype.isResponseTo = function (originalMessage) {
        return originalMessage.command === this.params.originalCommand;
    };
    Error421UnknownCommand.prototype.endsResponseTo = function (originalMessage) {
        return true;
    };
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error421UnknownCommand.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error421UnknownCommand.prototype, "originalCommand", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error421UnknownCommand.prototype, "suffix", void 0);
    Error421UnknownCommand = __decorate([
        MessageDefinition_1.MessageType('421')
    ], Error421UnknownCommand);
    return Error421UnknownCommand;
}(Message_1.default));
exports.default = Error421UnknownCommand;

},{"../../Message":116,"../../MessageDefinition":118}],155:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error422NoMOTD = /** @class */ (function (_super) {
    __extends(Error422NoMOTD, _super);
    function Error422NoMOTD() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error422NoMOTD.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error422NoMOTD.prototype, "suffix", void 0);
    Error422NoMOTD = __decorate([
        MessageDefinition_1.MessageType('422')
    ], Error422NoMOTD);
    return Error422NoMOTD;
}(Message_1.default));
exports.default = Error422NoMOTD;

},{"../../Message":116,"../../MessageDefinition":118}],156:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error431NoNickNameGiven = /** @class */ (function (_super) {
    __extends(Error431NoNickNameGiven, _super);
    function Error431NoNickNameGiven() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Error431NoNickNameGiven.prototype.isResponseTo = function (originalMessage) {
        return originalMessage.command === 'NICK';
    };
    Error431NoNickNameGiven.prototype.endsResponseTo = function (originalMessage) {
        return true;
    };
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error431NoNickNameGiven.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error431NoNickNameGiven.prototype, "suffix", void 0);
    Error431NoNickNameGiven = __decorate([
        MessageDefinition_1.MessageType('431')
    ], Error431NoNickNameGiven);
    return Error431NoNickNameGiven;
}(Message_1.default));
exports.default = Error431NoNickNameGiven;

},{"../../Message":116,"../../MessageDefinition":118}],157:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
// misspelt for historical reasons
var Error432ErroneusNickname = /** @class */ (function (_super) {
    __extends(Error432ErroneusNickname, _super);
    function Error432ErroneusNickname() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Error432ErroneusNickname.prototype.isResponseTo = function (originalMessage) {
        return originalMessage.command === 'NICK';
    };
    Error432ErroneusNickname.prototype.endsResponseTo = function (originalMessage) {
        return true;
    };
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error432ErroneusNickname.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error432ErroneusNickname.prototype, "nick", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error432ErroneusNickname.prototype, "suffix", void 0);
    Error432ErroneusNickname = __decorate([
        MessageDefinition_1.MessageType('432')
    ], Error432ErroneusNickname);
    return Error432ErroneusNickname;
}(Message_1.default));
exports.default = Error432ErroneusNickname;

},{"../../Message":116,"../../MessageDefinition":118}],158:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error433NickNameInUse = /** @class */ (function (_super) {
    __extends(Error433NickNameInUse, _super);
    function Error433NickNameInUse() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Error433NickNameInUse.prototype.isResponseTo = function (originalMessage) {
        return originalMessage.command === 'NICK';
    };
    Error433NickNameInUse.prototype.endsResponseTo = function (originalMessage) {
        return true;
    };
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error433NickNameInUse.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error433NickNameInUse.prototype, "nick", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error433NickNameInUse.prototype, "suffix", void 0);
    Error433NickNameInUse = __decorate([
        MessageDefinition_1.MessageType('433')
    ], Error433NickNameInUse);
    return Error433NickNameInUse;
}(Message_1.default));
exports.default = Error433NickNameInUse;

},{"../../Message":116,"../../MessageDefinition":118}],159:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error436NickCollision = /** @class */ (function (_super) {
    __extends(Error436NickCollision, _super);
    function Error436NickCollision() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Error436NickCollision.prototype.isResponseTo = function (originalMessage) {
        return originalMessage.command === 'NICK';
    };
    Error436NickCollision.prototype.endsResponseTo = function (originalMessage) {
        return true;
    };
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error436NickCollision.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error436NickCollision.prototype, "nick", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error436NickCollision.prototype, "suffix", void 0);
    Error436NickCollision = __decorate([
        MessageDefinition_1.MessageType('436')
    ], Error436NickCollision);
    return Error436NickCollision;
}(Message_1.default));
exports.default = Error436NickCollision;

},{"../../Message":116,"../../MessageDefinition":118}],160:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error441UserNotInChannel = /** @class */ (function (_super) {
    __extends(Error441UserNotInChannel, _super);
    function Error441UserNotInChannel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Error441UserNotInChannel.prototype.isResponseTo = function (originalMessage) {
        return originalMessage.command === 'NICK';
    };
    Error441UserNotInChannel.prototype.endsResponseTo = function (originalMessage) {
        return true;
    };
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error441UserNotInChannel.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error441UserNotInChannel.prototype, "nick", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            type: 'channel'
        })
    ], Error441UserNotInChannel.prototype, "channel", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error441UserNotInChannel.prototype, "suffix", void 0);
    Error441UserNotInChannel = __decorate([
        MessageDefinition_1.MessageType('441')
    ], Error441UserNotInChannel);
    return Error441UserNotInChannel;
}(Message_1.default));
exports.default = Error441UserNotInChannel;

},{"../../Message":116,"../../MessageDefinition":118}],161:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error442NotOnChannel = /** @class */ (function (_super) {
    __extends(Error442NotOnChannel, _super);
    function Error442NotOnChannel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Error442NotOnChannel.prototype.isResponseTo = function (originalMessage) {
        return originalMessage.command === 'NICK';
    };
    Error442NotOnChannel.prototype.endsResponseTo = function (originalMessage) {
        return true;
    };
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error442NotOnChannel.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            type: 'channel'
        })
    ], Error442NotOnChannel.prototype, "channel", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error442NotOnChannel.prototype, "suffix", void 0);
    Error442NotOnChannel = __decorate([
        MessageDefinition_1.MessageType('442')
    ], Error442NotOnChannel);
    return Error442NotOnChannel;
}(Message_1.default));
exports.default = Error442NotOnChannel;

},{"../../Message":116,"../../MessageDefinition":118}],162:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error443UserOnChannel = /** @class */ (function (_super) {
    __extends(Error443UserOnChannel, _super);
    function Error443UserOnChannel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Error443UserOnChannel.prototype.isResponseTo = function (originalMessage) {
        return originalMessage.command === 'NICK';
    };
    Error443UserOnChannel.prototype.endsResponseTo = function (originalMessage) {
        return true;
    };
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error443UserOnChannel.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error443UserOnChannel.prototype, "nick", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            type: 'channel'
        })
    ], Error443UserOnChannel.prototype, "channel", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error443UserOnChannel.prototype, "suffix", void 0);
    Error443UserOnChannel = __decorate([
        MessageDefinition_1.MessageType('443')
    ], Error443UserOnChannel);
    return Error443UserOnChannel;
}(Message_1.default));
exports.default = Error443UserOnChannel;

},{"../../Message":116,"../../MessageDefinition":118}],163:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error451NotRegistered = /** @class */ (function (_super) {
    __extends(Error451NotRegistered, _super);
    function Error451NotRegistered() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error451NotRegistered.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error451NotRegistered.prototype, "suffix", void 0);
    Error451NotRegistered = __decorate([
        MessageDefinition_1.MessageType('451')
    ], Error451NotRegistered);
    return Error451NotRegistered;
}(Message_1.default));
exports.default = Error451NotRegistered;

},{"../../Message":116,"../../MessageDefinition":118}],164:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error461NeedMoreParams = /** @class */ (function (_super) {
    __extends(Error461NeedMoreParams, _super);
    function Error461NeedMoreParams() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error461NeedMoreParams.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error461NeedMoreParams.prototype, "originalCommand", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error461NeedMoreParams.prototype, "suffix", void 0);
    Error461NeedMoreParams = __decorate([
        MessageDefinition_1.MessageType('461')
    ], Error461NeedMoreParams);
    return Error461NeedMoreParams;
}(Message_1.default));
exports.default = Error461NeedMoreParams;

},{"../../Message":116,"../../MessageDefinition":118}],165:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error462AlreadyRegistered = /** @class */ (function (_super) {
    __extends(Error462AlreadyRegistered, _super);
    function Error462AlreadyRegistered() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error462AlreadyRegistered.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error462AlreadyRegistered.prototype, "suffix", void 0);
    Error462AlreadyRegistered = __decorate([
        MessageDefinition_1.MessageType('462')
    ], Error462AlreadyRegistered);
    return Error462AlreadyRegistered;
}(Message_1.default));
exports.default = Error462AlreadyRegistered;

},{"../../Message":116,"../../MessageDefinition":118}],166:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error472UnknownMode = /** @class */ (function (_super) {
    __extends(Error472UnknownMode, _super);
    function Error472UnknownMode() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error472UnknownMode.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error472UnknownMode.prototype, "char", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error472UnknownMode.prototype, "suffix", void 0);
    Error472UnknownMode = __decorate([
        MessageDefinition_1.MessageType('472')
    ], Error472UnknownMode);
    return Error472UnknownMode;
}(Message_1.default));
exports.default = Error472UnknownMode;

},{"../../Message":116,"../../MessageDefinition":118}],167:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error473InviteOnlyChan = /** @class */ (function (_super) {
    __extends(Error473InviteOnlyChan, _super);
    function Error473InviteOnlyChan() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error473InviteOnlyChan.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error473InviteOnlyChan.prototype, "channel", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error473InviteOnlyChan.prototype, "suffix", void 0);
    Error473InviteOnlyChan = __decorate([
        MessageDefinition_1.MessageType('473')
    ], Error473InviteOnlyChan);
    return Error473InviteOnlyChan;
}(Message_1.default));
exports.default = Error473InviteOnlyChan;

},{"../../Message":116,"../../MessageDefinition":118}],168:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error482ChanOPrivsNeeded = /** @class */ (function (_super) {
    __extends(Error482ChanOPrivsNeeded, _super);
    function Error482ChanOPrivsNeeded() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error482ChanOPrivsNeeded.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error482ChanOPrivsNeeded.prototype, "channel", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error482ChanOPrivsNeeded.prototype, "suffix", void 0);
    Error482ChanOPrivsNeeded = __decorate([
        MessageDefinition_1.MessageType('482')
    ], Error482ChanOPrivsNeeded);
    return Error482ChanOPrivsNeeded;
}(Message_1.default));
exports.default = Error482ChanOPrivsNeeded;

},{"../../Message":116,"../../MessageDefinition":118}],169:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error501UModeUnknownFlag = /** @class */ (function (_super) {
    __extends(Error501UModeUnknownFlag, _super);
    function Error501UModeUnknownFlag() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error501UModeUnknownFlag.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error501UModeUnknownFlag.prototype, "suffix", void 0);
    Error501UModeUnknownFlag = __decorate([
        MessageDefinition_1.MessageType('501')
    ], Error501UModeUnknownFlag);
    return Error501UModeUnknownFlag;
}(Message_1.default));
exports.default = Error501UModeUnknownFlag;

},{"../../Message":116,"../../MessageDefinition":118}],170:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Error502UsersDontMatch = /** @class */ (function (_super) {
    __extends(Error502UsersDontMatch, _super);
    function Error502UsersDontMatch() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Error502UsersDontMatch.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Error502UsersDontMatch.prototype, "suffix", void 0);
    Error502UsersDontMatch = __decorate([
        MessageDefinition_1.MessageType('502')
    ], Error502UsersDontMatch);
    return Error502UsersDontMatch;
}(Message_1.default));
exports.default = Error502UsersDontMatch;

},{"../../Message":116,"../../MessageDefinition":118}],171:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Reply001Welcome = /** @class */ (function (_super) {
    __extends(Reply001Welcome, _super);
    function Reply001Welcome() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply001Welcome.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Reply001Welcome.prototype, "welcomeText", void 0);
    Reply001Welcome = __decorate([
        MessageDefinition_1.MessageType('001')
    ], Reply001Welcome);
    return Reply001Welcome;
}(Message_1.default));
exports.default = Reply001Welcome;

},{"../../Message":116,"../../MessageDefinition":118}],172:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Reply002YourHost = /** @class */ (function (_super) {
    __extends(Reply002YourHost, _super);
    function Reply002YourHost() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply002YourHost.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Reply002YourHost.prototype, "yourHost", void 0);
    Reply002YourHost = __decorate([
        MessageDefinition_1.MessageType('002')
    ], Reply002YourHost);
    return Reply002YourHost;
}(Message_1.default));
exports.default = Reply002YourHost;

},{"../../Message":116,"../../MessageDefinition":118}],173:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Reply003Created = /** @class */ (function (_super) {
    __extends(Reply003Created, _super);
    function Reply003Created() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply003Created.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Reply003Created.prototype, "createdText", void 0);
    Reply003Created = __decorate([
        MessageDefinition_1.MessageType('003')
    ], Reply003Created);
    return Reply003Created;
}(Message_1.default));
exports.default = Reply003Created;

},{"../../Message":116,"../../MessageDefinition":118}],174:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Reply004ServerInfo = /** @class */ (function (_super) {
    __extends(Reply004ServerInfo, _super);
    function Reply004ServerInfo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply004ServerInfo.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply004ServerInfo.prototype, "serverName", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply004ServerInfo.prototype, "version", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply004ServerInfo.prototype, "userModes", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply004ServerInfo.prototype, "channelModes", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            optional: true
        })
    ], Reply004ServerInfo.prototype, "channelModesWithParam", void 0);
    Reply004ServerInfo = __decorate([
        MessageDefinition_1.MessageType('004')
    ], Reply004ServerInfo);
    return Reply004ServerInfo;
}(Message_1.default));
exports.default = Reply004ServerInfo;

},{"../../Message":116,"../../MessageDefinition":118}],175:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Reply005ISupport = /** @class */ (function (_super) {
    __extends(Reply005ISupport, _super);
    function Reply005ISupport() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply005ISupport.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            rest: true
        })
    ], Reply005ISupport.prototype, "supports", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Reply005ISupport.prototype, "suffix", void 0);
    Reply005ISupport = __decorate([
        MessageDefinition_1.MessageType('005')
    ], Reply005ISupport);
    return Reply005ISupport;
}(Message_1.default));
exports.default = Reply005ISupport;

},{"../../Message":116,"../../MessageDefinition":118}],176:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Reply221UModeIs = /** @class */ (function (_super) {
    __extends(Reply221UModeIs, _super);
    function Reply221UModeIs() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply221UModeIs.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply221UModeIs.prototype, "modes", void 0);
    Reply221UModeIs = __decorate([
        MessageDefinition_1.MessageType('221')
    ], Reply221UModeIs);
    return Reply221UModeIs;
}(Message_1.default));
exports.default = Reply221UModeIs;

},{"../../Message":116,"../../MessageDefinition":118}],177:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Reply324ChannelModeIs = /** @class */ (function (_super) {
    __extends(Reply324ChannelModeIs, _super);
    function Reply324ChannelModeIs() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply324ChannelModeIs.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            type: 'channel'
        })
    ], Reply324ChannelModeIs.prototype, "channel", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            rest: true
        })
    ], Reply324ChannelModeIs.prototype, "modes", void 0);
    Reply324ChannelModeIs = __decorate([
        MessageDefinition_1.MessageType('324')
    ], Reply324ChannelModeIs);
    return Reply324ChannelModeIs;
}(Message_1.default));
exports.default = Reply324ChannelModeIs;

},{"../../Message":116,"../../MessageDefinition":118}],178:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Reply331NoTopic = /** @class */ (function (_super) {
    __extends(Reply331NoTopic, _super);
    function Reply331NoTopic() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply331NoTopic.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            type: 'channel'
        })
    ], Reply331NoTopic.prototype, "channel", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Reply331NoTopic.prototype, "suffix", void 0);
    Reply331NoTopic = __decorate([
        MessageDefinition_1.MessageType('331')
    ], Reply331NoTopic);
    return Reply331NoTopic;
}(Message_1.default));
exports.default = Reply331NoTopic;

},{"../../Message":116,"../../MessageDefinition":118}],179:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Reply332Topic = /** @class */ (function (_super) {
    __extends(Reply332Topic, _super);
    function Reply332Topic() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply332Topic.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            type: 'channel'
        })
    ], Reply332Topic.prototype, "channel", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Reply332Topic.prototype, "topic", void 0);
    Reply332Topic = __decorate([
        MessageDefinition_1.MessageType('332')
    ], Reply332Topic);
    return Reply332Topic;
}(Message_1.default));
exports.default = Reply332Topic;

},{"../../Message":116,"../../MessageDefinition":118}],180:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Reply333TopicWhoTime = /** @class */ (function (_super) {
    __extends(Reply333TopicWhoTime, _super);
    function Reply333TopicWhoTime() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply333TopicWhoTime.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            type: 'channel'
        })
    ], Reply333TopicWhoTime.prototype, "channel", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply333TopicWhoTime.prototype, "who", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply333TopicWhoTime.prototype, "ts", void 0);
    Reply333TopicWhoTime = __decorate([
        MessageDefinition_1.MessageType('333')
    ], Reply333TopicWhoTime);
    return Reply333TopicWhoTime;
}(Message_1.default));
exports.default = Reply333TopicWhoTime;

},{"../../Message":116,"../../MessageDefinition":118}],181:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Reply341Inviting = /** @class */ (function (_super) {
    __extends(Reply341Inviting, _super);
    function Reply341Inviting() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply341Inviting.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply341Inviting.prototype, "nick", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            type: 'channel'
        })
    ], Reply341Inviting.prototype, "channel", void 0);
    Reply341Inviting = __decorate([
        MessageDefinition_1.MessageType('341')
    ], Reply341Inviting);
    return Reply341Inviting;
}(Message_1.default));
exports.default = Reply341Inviting;

},{"../../Message":116,"../../MessageDefinition":118}],182:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var Names_1 = require("../Commands/Names");
var MessageDefinition_1 = require("../../MessageDefinition");
var Reply353NamesReply = /** @class */ (function (_super) {
    __extends(Reply353NamesReply, _super);
    function Reply353NamesReply() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Reply353NamesReply.prototype.isResponseTo = function (originalMessage) {
        return originalMessage instanceof Names_1.default;
    };
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply353NamesReply.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply353NamesReply.prototype, "channelType", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            type: 'channel'
        })
    ], Reply353NamesReply.prototype, "channel", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Reply353NamesReply.prototype, "names", void 0);
    Reply353NamesReply = __decorate([
        MessageDefinition_1.MessageType('353')
    ], Reply353NamesReply);
    return Reply353NamesReply;
}(Message_1.default));
exports.default = Reply353NamesReply;

},{"../../Message":116,"../../MessageDefinition":118,"../Commands/Names":132}],183:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var Names_1 = require("../Commands/Names");
var MessageDefinition_1 = require("../../MessageDefinition");
var Reply366EndOfNames = /** @class */ (function (_super) {
    __extends(Reply366EndOfNames, _super);
    function Reply366EndOfNames() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Reply366EndOfNames.prototype.isResponseTo = function (originalMessage) {
        return originalMessage instanceof Names_1.default;
    };
    Reply366EndOfNames.prototype.endsResponseTo = function (originalMessage) {
        return true;
    };
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply366EndOfNames.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            type: 'channel'
        })
    ], Reply366EndOfNames.prototype, "channel", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Reply366EndOfNames.prototype, "suffix", void 0);
    Reply366EndOfNames = __decorate([
        MessageDefinition_1.MessageType('366')
    ], Reply366EndOfNames);
    return Reply366EndOfNames;
}(Message_1.default));
exports.default = Reply366EndOfNames;

},{"../../Message":116,"../../MessageDefinition":118,"../Commands/Names":132}],184:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Reply372MOTD = /** @class */ (function (_super) {
    __extends(Reply372MOTD, _super);
    function Reply372MOTD() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply372MOTD.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Reply372MOTD.prototype, "line", void 0);
    Reply372MOTD = __decorate([
        MessageDefinition_1.MessageType('372')
    ], Reply372MOTD);
    return Reply372MOTD;
}(Message_1.default));
exports.default = Reply372MOTD;

},{"../../Message":116,"../../MessageDefinition":118}],185:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Reply375MOTDStart = /** @class */ (function (_super) {
    __extends(Reply375MOTDStart, _super);
    function Reply375MOTDStart() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply375MOTDStart.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Reply375MOTDStart.prototype, "message", void 0);
    Reply375MOTDStart = __decorate([
        MessageDefinition_1.MessageType('375')
    ], Reply375MOTDStart);
    return Reply375MOTDStart;
}(Message_1.default));
exports.default = Reply375MOTDStart;

},{"../../Message":116,"../../MessageDefinition":118}],186:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("../../Message");
var MessageDefinition_1 = require("../../MessageDefinition");
var Reply376EndOfMOTD = /** @class */ (function (_super) {
    __extends(Reply376EndOfMOTD, _super);
    function Reply376EndOfMOTD() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    __decorate([
        MessageDefinition_1.MessageParamDefinition({})
    ], Reply376EndOfMOTD.prototype, "me", void 0);
    __decorate([
        MessageDefinition_1.MessageParamDefinition({
            trailing: true
        })
    ], Reply376EndOfMOTD.prototype, "suffix", void 0);
    Reply376EndOfMOTD = __decorate([
        MessageDefinition_1.MessageType('376')
    ], Reply376EndOfMOTD);
    return Reply376EndOfMOTD;
}(Message_1.default));
exports.default = Reply376EndOfMOTD;

},{"../../Message":116,"../../MessageDefinition":118}],187:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Reply001Welcome_1 = require("./Reply001Welcome");
exports.Reply001Welcome = Reply001Welcome_1.default;
var Reply002YourHost_1 = require("./Reply002YourHost");
exports.Reply002YourHost = Reply002YourHost_1.default;
var Reply003Created_1 = require("./Reply003Created");
exports.Reply003Created = Reply003Created_1.default;
var Reply004ServerInfo_1 = require("./Reply004ServerInfo");
exports.Reply004ServerInfo = Reply004ServerInfo_1.default;
var Reply005ISupport_1 = require("./Reply005ISupport");
exports.Reply005ISupport = Reply005ISupport_1.default;
var Reply221UModeIs_1 = require("./Reply221UModeIs");
exports.Reply221UModeIs = Reply221UModeIs_1.default;
var Reply324ChannelModeIs_1 = require("./Reply324ChannelModeIs");
exports.Reply324ChannelModeIs = Reply324ChannelModeIs_1.default;
var Reply331NoTopic_1 = require("./Reply331NoTopic");
exports.Reply331NoTopic = Reply331NoTopic_1.default;
var Reply332Topic_1 = require("./Reply332Topic");
exports.Reply332Topic = Reply332Topic_1.default;
var Reply333TopicWhoTime_1 = require("./Reply333TopicWhoTime");
exports.Reply333TopicWhoTime = Reply333TopicWhoTime_1.default;
var Reply341Inviting_1 = require("./Reply341Inviting");
exports.Reply341Inviting = Reply341Inviting_1.default;
var Reply353NamesReply_1 = require("./Reply353NamesReply");
exports.Reply353NamesReply = Reply353NamesReply_1.default;
var Reply366EndOfNames_1 = require("./Reply366EndOfNames");
exports.Reply366EndOfNames = Reply366EndOfNames_1.default;
var Reply372MOTD_1 = require("./Reply372MOTD");
exports.Reply372MOTD = Reply372MOTD_1.default;
var Reply375MOTDStart_1 = require("./Reply375MOTDStart");
exports.Reply375MOTDStart = Reply375MOTDStart_1.default;
var Reply376EndOfMOTD_1 = require("./Reply376EndOfMOTD");
exports.Reply376EndOfMOTD = Reply376EndOfMOTD_1.default;
var Error401NoSuchNick_1 = require("./Error401NoSuchNick");
exports.Error401NoSuchNick = Error401NoSuchNick_1.default;
var Error403NoSuchChannel_1 = require("./Error403NoSuchChannel");
exports.Error403NoSuchChannel = Error403NoSuchChannel_1.default;
var Error404CanNotSendToChan_1 = require("./Error404CanNotSendToChan");
exports.Error404CanNotSendToChan = Error404CanNotSendToChan_1.default;
var Error421UnknownCommand_1 = require("./Error421UnknownCommand");
exports.Error421UnknownCommand = Error421UnknownCommand_1.default;
var Error422NoMOTD_1 = require("./Error422NoMOTD");
exports.Error422NoMOTD = Error422NoMOTD_1.default;
var Error431NoNickNameGiven_1 = require("./Error431NoNickNameGiven");
exports.Error431NoNickNameGiven = Error431NoNickNameGiven_1.default;
var Error432ErroneusNickname_1 = require("./Error432ErroneusNickname");
exports.Error432ErroneusNickname = Error432ErroneusNickname_1.default;
var Error433NickNameInUse_1 = require("./Error433NickNameInUse");
exports.Error433NickNameInUse = Error433NickNameInUse_1.default;
var Error436NickCollision_1 = require("./Error436NickCollision");
exports.Error436NickCollision = Error436NickCollision_1.default;
var Error441UserNotInChannel_1 = require("./Error441UserNotInChannel");
exports.Error441UserNotInChannel = Error441UserNotInChannel_1.default;
var Error442NotOnChannel_1 = require("./Error442NotOnChannel");
exports.Error442NotOnChannel = Error442NotOnChannel_1.default;
var Error443UserOnChannel_1 = require("./Error443UserOnChannel");
exports.Error443UserOnChannel = Error443UserOnChannel_1.default;
var Error451NotRegistered_1 = require("./Error451NotRegistered");
exports.Error451NotRegistered = Error451NotRegistered_1.default;
var Error461NeedMoreParams_1 = require("./Error461NeedMoreParams");
exports.Error461NeedMoreParams = Error461NeedMoreParams_1.default;
var Error462AlreadyRegistered_1 = require("./Error462AlreadyRegistered");
exports.Error462AlreadyRegistered = Error462AlreadyRegistered_1.default;
var Error472UnknownMode_1 = require("./Error472UnknownMode");
exports.Error472UnknownMode = Error472UnknownMode_1.default;
var Error473InviteOnlyChan_1 = require("./Error473InviteOnlyChan");
exports.Error473InviteOnlyChan = Error473InviteOnlyChan_1.default;
var Error482ChanOPrivsNeeded_1 = require("./Error482ChanOPrivsNeeded");
exports.Error482ChanOPrivsNeeded = Error482ChanOPrivsNeeded_1.default;
var Error501UModeUnknownFlag_1 = require("./Error501UModeUnknownFlag");
exports.Error501UModeUnknownFlag = Error501UModeUnknownFlag_1.default;
var Error502UsersDontMatch_1 = require("./Error502UsersDontMatch");
exports.Error502UsersDontMatch = Error502UsersDontMatch_1.default;

},{"./Error401NoSuchNick":151,"./Error403NoSuchChannel":152,"./Error404CanNotSendToChan":153,"./Error421UnknownCommand":154,"./Error422NoMOTD":155,"./Error431NoNickNameGiven":156,"./Error432ErroneusNickname":157,"./Error433NickNameInUse":158,"./Error436NickCollision":159,"./Error441UserNotInChannel":160,"./Error442NotOnChannel":161,"./Error443UserOnChannel":162,"./Error451NotRegistered":163,"./Error461NeedMoreParams":164,"./Error462AlreadyRegistered":165,"./Error472UnknownMode":166,"./Error473InviteOnlyChan":167,"./Error482ChanOPrivsNeeded":168,"./Error501UModeUnknownFlag":169,"./Error502UsersDontMatch":170,"./Reply001Welcome":171,"./Reply002YourHost":172,"./Reply003Created":173,"./Reply004ServerInfo":174,"./Reply005ISupport":175,"./Reply221UModeIs":176,"./Reply324ChannelModeIs":177,"./Reply331NoTopic":178,"./Reply332Topic":179,"./Reply333TopicWhoTime":180,"./Reply341Inviting":181,"./Reply353NamesReply":182,"./Reply366EndOfNames":183,"./Reply372MOTD":184,"./Reply375MOTDStart":185,"./Reply376EndOfMOTD":186}],188:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Commands = require("./Commands");
exports.Commands = Commands;
var Numerics = require("./Numerics");
exports.Numerics = Numerics;
exports.all = new Map(__spread(Object.values(Commands), Object.values(Numerics)).map(function (cmd) { return [cmd.COMMAND, cmd]; }));

},{"./Commands":150,"./Numerics":187}],189:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// sane defaults based on RFC 1459
exports.defaultServerProperties = {
    channelTypes: '#&',
    supportedUserModes: 'iwso',
    supportedChannelModes: {
        prefix: 'ov',
        list: 'b',
        alwaysWithParam: 'ovk',
        paramWhenSet: 'l',
        noParam: 'imnpst'
    },
    prefixes: [
        {
            modeChar: 'v',
            prefix: '+'
        },
        {
            modeChar: 'o',
            prefix: '@'
        }
    ]
};

},{}],190:[function(require,module,exports){
"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
// eslint-disable-next-line @typescript-eslint/no-require-imports
var escapeRegexString = require("escape-string-regexp");
var shared_utils_1 = require("@d-fischer/shared-utils");
function sanitizeParameter(param, spaceAllowed) {
    if (spaceAllowed === void 0) { spaceAllowed = false; }
    if (spaceAllowed) {
        return param.replace(/[\0\r\n]/g, '');
    }
    else {
        return param.replace(/[\0\r\n ]/g, '');
    }
}
exports.sanitizeParameter = sanitizeParameter;
function isChannel(str, validTypes) {
    if (validTypes === void 0) { validTypes = '#&'; }
    var re = new RegExp("^[" + escapeRegexString(validTypes) + "][^ \b\0\n\r,]+$");
    return re.test(str);
}
exports.isChannel = isChannel;
var ctcpEscapeMap = {
    0: '\0',
    n: '\n',
    r: '\r',
    '\x10': '\x10'
};
function decodeCtcp(message) {
    if (message[0] !== '\x01') {
        // this is not a CTCP message
        return false;
    }
    message = message.substring(1);
    // remove trailing \x01 if present
    if (message.slice(-1) === '\x01') {
        message = message.slice(0, -1);
    }
    if (!message) {
        // completely empty CTCPs don't exist either, I think
        return false;
    }
    // unescape weirdly escaped stuff
    message = message.replace(/\x10(.)/, function (_, escapedChar) {
        return escapedChar in ctcpEscapeMap ? ctcpEscapeMap[escapedChar] : '';
    });
    var _a = __read(shared_utils_1.splitWithLimit(message, ' ', 2), 2), command = _a[0], _b = _a[1], params = _b === void 0 ? '' : _b;
    command = command ? command.toUpperCase() : '';
    return { command: command, params: params };
}
exports.decodeCtcp = decodeCtcp;

},{"@d-fischer/shared-utils":36,"escape-string-regexp":98}],191:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Message_1 = require("./Message/Message");
exports.Message = Message_1.default;
exports.prefixToString = Message_1.prefixToString;
var MessageTypes = require("./Message/MessageTypes");
exports.MessageTypes = MessageTypes;
var CoreCapabilities = require("./Capability/CoreCapabilities");
exports.CoreCapabilities = CoreCapabilities;
var StringTools_1 = require("./Toolkit/StringTools");
exports.isChannel = StringTools_1.isChannel;
var IRCClient_1 = require("./IRCClient");
exports.default = IRCClient_1.default;
var MessageParser_1 = require("./Message/MessageParser");
exports.parseMessage = MessageParser_1.parseMessage;
exports.parsePrefix = MessageParser_1.parsePrefix;
exports.parseTags = MessageParser_1.parseTags;
var ServerProperties_1 = require("./ServerProperties");
exports.defaultServerProperties = ServerProperties_1.defaultServerProperties;
var MessageError_1 = require("./Errors/MessageError");
exports.MessageError = MessageError_1.default;
var NotEnoughParametersError_1 = require("./Errors/NotEnoughParametersError");
exports.NotEnoughParametersError = NotEnoughParametersError_1.default;
var ParameterRequirementMismatchError_1 = require("./Errors/ParameterRequirementMismatchError");
exports.ParameterRequirementMismatchError = ParameterRequirementMismatchError_1.default;
var UnknownChannelModeCharError_1 = require("./Errors/UnknownChannelModeCharError");
exports.UnknownChannelModeCharError = UnknownChannelModeCharError_1.default;
var MessageDefinition_1 = require("./Message/MessageDefinition");
exports.MessageType = MessageDefinition_1.MessageType;
exports.MessageParamDefinition = MessageDefinition_1.MessageParamDefinition;

},{"./Capability/CoreCapabilities":110,"./Errors/MessageError":111,"./Errors/NotEnoughParametersError":112,"./Errors/ParameterRequirementMismatchError":113,"./Errors/UnknownChannelModeCharError":114,"./IRCClient":115,"./Message/Message":116,"./Message/MessageDefinition":118,"./Message/MessageParser":119,"./Message/MessageTypes":188,"./ServerProperties":189,"./Toolkit/StringTools":190}],192:[function(require,module,exports){
'use strict';

var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
var toStr = Object.prototype.toString;

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return toStr.call(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		toStr.call(value) !== '[object Array]' &&
		toStr.call(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

},{}],193:[function(require,module,exports){
'use strict';

var fnToStr = Function.prototype.toString;

var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
	try {
		var fnStr = fnToStr.call(value);
		return constructorRegex.test(fnStr);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionToStr(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isCallable(value) {
	if (!value) { return false; }
	if (typeof value !== 'function' && typeof value !== 'object') { return false; }
	if (typeof value === 'function' && !value.prototype) { return true; }
	if (hasToStringTag) { return tryFunctionObject(value); }
	if (isES6ClassFn(value)) { return false; }
	var strClass = toStr.call(value);
	return strClass === fnClass || strClass === genClass;
};

},{}],194:[function(require,module,exports){
'use strict';

var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) {
		return false;
	}
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};

},{}],195:[function(require,module,exports){
'use strict';

var $Map = typeof Map === 'function' && Map.prototype ? Map : null;
var $Set = typeof Set === 'function' && Set.prototype ? Set : null;

var exported;

if (!$Map) {
	// eslint-disable-next-line no-unused-vars
	exported = function isMap(x) {
		// `Map` is not present in this environment.
		return false;
	};
}

var $mapHas = $Map ? Map.prototype.has : null;
var $setHas = $Set ? Set.prototype.has : null;
if (!exported && !$mapHas) {
	// eslint-disable-next-line no-unused-vars
	exported = function isMap(x) {
		// `Map` does not have a `has` method
		return false;
	};
}

module.exports = exported || function isMap(x) {
	if (!x || typeof x !== 'object') {
		return false;
	}
	try {
		$mapHas.call(x);
		if ($setHas) {
			try {
				$setHas.call(x);
			} catch (e) {
				return true;
			}
		}
		return x instanceof $Map; // core-js workaround, pre-v2.5.0
	} catch (e) {}
	return false;
};

},{}],196:[function(require,module,exports){
'use strict';

var has = require('has');
var regexExec = RegExp.prototype.exec;
var gOPD = Object.getOwnPropertyDescriptor;

var tryRegexExecCall = function tryRegexExec(value) {
	try {
		var lastIndex = value.lastIndex;
		value.lastIndex = 0; // eslint-disable-line no-param-reassign

		regexExec.call(value);
		return true;
	} catch (e) {
		return false;
	} finally {
		value.lastIndex = lastIndex; // eslint-disable-line no-param-reassign
	}
};
var toStr = Object.prototype.toString;
var regexClass = '[object RegExp]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isRegex(value) {
	if (!value || typeof value !== 'object') {
		return false;
	}
	if (!hasToStringTag) {
		return toStr.call(value) === regexClass;
	}

	var descriptor = gOPD(value, 'lastIndex');
	var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
	if (!hasLastIndexDataProperty) {
		return false;
	}

	return tryRegexExecCall(value);
};

},{"has":104}],197:[function(require,module,exports){
'use strict';

var $Map = typeof Map === 'function' && Map.prototype ? Map : null;
var $Set = typeof Set === 'function' && Set.prototype ? Set : null;

var exported;

if (!$Set) {
	// eslint-disable-next-line no-unused-vars
	exported = function isSet(x) {
		// `Set` is not present in this environment.
		return false;
	};
}

var $mapHas = $Map ? Map.prototype.has : null;
var $setHas = $Set ? Set.prototype.has : null;
if (!exported && !$setHas) {
	// eslint-disable-next-line no-unused-vars
	exported = function isSet(x) {
		// `Set` does not have a `has` method
		return false;
	};
}

module.exports = exported || function isSet(x) {
	if (!x || typeof x !== 'object') {
		return false;
	}
	try {
		$setHas.call(x);
		if ($mapHas) {
			try {
				$mapHas.call(x);
			} catch (e) {
				return true;
			}
		}
		return x instanceof $Set; // core-js workaround, pre-v2.5.0
	} catch (e) {}
	return false;
};

},{}],198:[function(require,module,exports){
'use strict';

var strValue = String.prototype.valueOf;
var tryStringObject = function tryStringObject(value) {
	try {
		strValue.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var strClass = '[object String]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isString(value) {
	if (typeof value === 'string') {
		return true;
	}
	if (typeof value !== 'object') {
		return false;
	}
	return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
};

},{}],199:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;
var hasSymbols = require('has-symbols')();

if (hasSymbols) {
	var symToStr = Symbol.prototype.toString;
	var symStringRegex = /^Symbol\(.*\)$/;
	var isSymbolObject = function isRealSymbolObject(value) {
		if (typeof value.valueOf() !== 'symbol') {
			return false;
		}
		return symStringRegex.test(symToStr.call(value));
	};

	module.exports = function isSymbol(value) {
		if (typeof value === 'symbol') {
			return true;
		}
		if (toStr.call(value) !== '[object Symbol]') {
			return false;
		}
		try {
			return isSymbolObject(value);
		} catch (e) {
			return false;
		}
	};
} else {

	module.exports = function isSymbol(value) {
		// this environment does not support Symbols.
		return false && value;
	};
}

},{"has-symbols":102}],200:[function(require,module,exports){
'use strict';

var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
module.exports = function iterateIterator(iterator) {
	if (!iterator || typeof iterator.next !== 'function') {
		throw new $TypeError('iterator must be an object with a `next` method');
	}
	if (arguments.length > 1) {
		var callback = arguments[1];
		if (typeof callback !== 'function') {
			throw new $TypeError('`callback`, if provided, must be a function');
		}
	}
	var values = callback || [];
	var result;
	while ((result = iterator.next()) && !result.done) {
		if (callback) {
			callback(result.value); // eslint-disable-line callback-return
		} else {
			values.push(result.value);
		}
	}
	if (!callback) {
		return values;
	}
};

},{}],201:[function(require,module,exports){
'use strict';

var getIterator = require('es-get-iterator');
var $TypeError = TypeError;
var iterate = require('iterate-iterator');

module.exports = function iterateValue(iterable) {
	var iterator = getIterator(iterable);
	if (!iterator) {
		throw new $TypeError('non-iterable value provided');
	}
	if (arguments.length > 1) {
		return iterate(iterator, arguments[1]);
	}
	return iterate(iterator);
};

},{"es-get-iterator":94,"iterate-iterator":200}],202:[function(require,module,exports){
var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var match = String.prototype.match;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;

var inspectCustom = require('./util.inspect').custom;
var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
    var opts = options || {};

    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }

    if (typeof obj === 'undefined') {
        return 'undefined';
    }
    if (obj === null) {
        return 'null';
    }
    if (typeof obj === 'boolean') {
        return obj ? 'true' : 'false';
    }

    if (typeof obj === 'string') {
        return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
        if (obj === 0) {
            return Infinity / obj > 0 ? '0' : '-0';
        }
        return String(obj);
    }
    if (typeof obj === 'bigint') { // eslint-disable-line valid-typeof
        return String(obj) + 'n';
    }

    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') { depth = 0; }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
        return '[Object]';
    }

    if (typeof seen === 'undefined') {
        seen = [];
    } else if (indexOf(seen, obj) >= 0) {
        return '[Circular]';
    }

    function inspect(value, from) {
        if (from) {
            seen = seen.slice();
            seen.push(from);
        }
        return inspect_(value, opts, depth + 1, seen);
    }

    if (typeof obj === 'function') {
        var name = nameOf(obj);
        return '[Function' + (name ? ': ' + name : '') + ']';
    }
    if (isSymbol(obj)) {
        var symString = Symbol.prototype.toString.call(obj);
        return typeof obj === 'object' ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
        var s = '<' + String(obj.nodeName).toLowerCase();
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
        }
        s += '>';
        if (obj.childNodes && obj.childNodes.length) { s += '...'; }
        s += '</' + String(obj.nodeName).toLowerCase() + '>';
        return s;
    }
    if (isArray(obj)) {
        if (obj.length === 0) { return '[]'; }
        return '[ ' + arrObjKeys(obj, inspect).join(', ') + ' ]';
    }
    if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (parts.length === 0) { return '[' + String(obj) + ']'; }
        return '{ [' + String(obj) + '] ' + parts.join(', ') + ' }';
    }
    if (typeof obj === 'object') {
        if (inspectSymbol && typeof obj[inspectSymbol] === 'function') {
            return obj[inspectSymbol]();
        } else if (typeof obj.inspect === 'function') {
            return obj.inspect();
        }
    }
    if (isMap(obj)) {
        var mapParts = [];
        mapForEach.call(obj, function (value, key) {
            mapParts.push(inspect(key, obj) + ' => ' + inspect(value, obj));
        });
        return collectionOf('Map', mapSize.call(obj), mapParts);
    }
    if (isSet(obj)) {
        var setParts = [];
        setForEach.call(obj, function (value) {
            setParts.push(inspect(value, obj));
        });
        return collectionOf('Set', setSize.call(obj), setParts);
    }
    if (isWeakMap(obj)) {
        return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
        return weakCollectionOf('WeakSet');
    }
    if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
    }
    if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
    }
    if (!isDate(obj) && !isRegExp(obj)) {
        var xs = arrObjKeys(obj, inspect);
        if (xs.length === 0) { return '{}'; }
        return '{ ' + xs.join(', ') + ' }';
    }
    return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
}

function quote(s) {
    return String(s).replace(/"/g, '&quot;');
}

function isArray(obj) { return toStr(obj) === '[object Array]'; }
function isDate(obj) { return toStr(obj) === '[object Date]'; }
function isRegExp(obj) { return toStr(obj) === '[object RegExp]'; }
function isError(obj) { return toStr(obj) === '[object Error]'; }
function isSymbol(obj) { return toStr(obj) === '[object Symbol]'; }
function isString(obj) { return toStr(obj) === '[object String]'; }
function isNumber(obj) { return toStr(obj) === '[object Number]'; }
function isBigInt(obj) { return toStr(obj) === '[object BigInt]'; }
function isBoolean(obj) { return toStr(obj) === '[object Boolean]'; }

var hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };
function has(obj, key) {
    return hasOwn.call(obj, key);
}

function toStr(obj) {
    return objectToString.call(obj);
}

function nameOf(f) {
    if (f.name) { return f.name; }
    var m = match.call(f, /^function\s*([\w$]+)/);
    if (m) { return m[1]; }
    return null;
}

function indexOf(xs, x) {
    if (xs.indexOf) { return xs.indexOf(x); }
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) { return i; }
    }
    return -1;
}

function isMap(x) {
    if (!mapSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        mapSize.call(x);
        try {
            setSize.call(x);
        } catch (s) {
            return true;
        }
        return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakMapHas.call(x, weakMapHas);
        try {
            weakSetHas.call(x, weakSetHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isSet(x) {
    if (!setSize || !x || typeof x !== 'object') {
        return false;
    }
    try {
        setSize.call(x);
        try {
            mapSize.call(x);
        } catch (m) {
            return true;
        }
        return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== 'object') {
        return false;
    }
    try {
        weakSetHas.call(x, weakSetHas);
        try {
            weakMapHas.call(x, weakMapHas);
        } catch (s) {
            return true;
        }
        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
}

function isElement(x) {
    if (!x || typeof x !== 'object') { return false; }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
        return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
    // eslint-disable-next-line no-control-regex
    var s = str.replace(/(['\\])/g, '\\$1').replace(/[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
        8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r'
    }[n];
    if (x) { return '\\' + x; }
    return '\\x' + (n < 0x10 ? '0' : '') + n.toString(16);
}

function markBoxed(str) {
    return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
    return type + ' { ? }';
}

function collectionOf(type, size, entries) {
    return type + ' (' + size + ') {' + entries.join(', ') + '}';
}

function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj);
    var xs = [];
    if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
        }
    }
    for (var key in obj) { // eslint-disable-line no-restricted-syntax
        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue
        if ((/[^\w$]/).test(key)) {
            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
        } else {
            xs.push(key + ': ' + inspect(obj[key], obj));
        }
    }
    return xs;
}

},{"./util.inspect":325}],203:[function(require,module,exports){
'use strict';

var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = require('./isArguments'); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;

},{"./isArguments":205}],204:[function(require,module,exports){
'use strict';

var slice = Array.prototype.slice;
var isArgs = require('./isArguments');

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : require('./implementation');

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

},{"./implementation":203,"./isArguments":205}],205:[function(require,module,exports){
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

},{}],206:[function(require,module,exports){
'use strict';

var requirePromise = require('./requirePromise');

requirePromise();

var PromiseResolve = require('es-abstract/2019/PromiseResolve');
var Type = require('es-abstract/2019/Type');
var iterate = require('iterate-value');
var map = require('array.prototype.map');
var getIntrinsic = require('es-abstract/GetIntrinsic');
var bind = require('function-bind');

var all = bind.call(Function.call, getIntrinsic('%Promise_all%'));
var reject = bind.call(Function.call, getIntrinsic('%Promise_reject%'));

module.exports = function allSettled(iterable) {
	var C = this;
	if (Type(C) !== 'Object') {
		throw new TypeError('`this` value must be an object');
	}
	var values = iterate(iterable);
	return all(C, map(values, function (item) {
		var onFulfill = function (value) {
			return { status: 'fulfilled', value: value };
		};
		var onReject = function (reason) {
			return { status: 'rejected', reason: reason };
		};
		var itemPromise = PromiseResolve(C, item);
		try {
			return itemPromise.then(onFulfill, onReject);
		} catch (e) {
			return reject(C, e);
		}
	}));
};

},{"./requirePromise":209,"array.prototype.map":40,"es-abstract/2019/PromiseResolve":70,"es-abstract/2019/Type":80,"es-abstract/GetIntrinsic":83,"function-bind":101,"iterate-value":201}],207:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var define = require('define-properties');

var requirePromise = require('./requirePromise');
var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

requirePromise();
var bound = bind.call(Function.call, getPolyfill());

var rebindable = function allSettled(iterable) {
	// eslint-disable-next-line no-invalid-this
	return bound(typeof this === 'undefined' ? Promise : this, iterable);
};

define(rebindable, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = rebindable;

},{"./implementation":206,"./polyfill":208,"./requirePromise":209,"./shim":210,"define-properties":51,"function-bind":101}],208:[function(require,module,exports){
'use strict';

var requirePromise = require('./requirePromise');

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	requirePromise();
	return typeof Promise.allSettled === 'function' ? Promise.allSettled : implementation;
};

},{"./implementation":206,"./requirePromise":209}],209:[function(require,module,exports){
'use strict';

module.exports = function requirePromise() {
	if (typeof Promise !== 'function') {
		throw new TypeError('`Promise.allSettled` requires a global `Promise` be available.');
	}
};

},{}],210:[function(require,module,exports){
'use strict';

var requirePromise = require('./requirePromise');

var getPolyfill = require('./polyfill');
var define = require('define-properties');

module.exports = function shimAllSettled() {
	requirePromise();

	var polyfill = getPolyfill();
	define(Promise, { allSettled: polyfill }, {
		allSettled: function testAllSettled() {
			return Promise.allSettled !== polyfill;
		}
	});
	return polyfill;
};

},{"./polyfill":208,"./requirePromise":209,"define-properties":51}],211:[function(require,module,exports){
'use strict';

var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var util = require('./utils');

var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

module.exports = util.assign(
    {
        'default': Format.RFC3986,
        formatters: {
            RFC1738: function (value) {
                return replace.call(value, percentTwenties, '+');
            },
            RFC3986: function (value) {
                return String(value);
            }
        }
    },
    Format
);

},{"./utils":215}],212:[function(require,module,exports){
'use strict';

var stringify = require('./stringify');
var parse = require('./parse');
var formats = require('./formats');

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};

},{"./formats":211,"./parse":213,"./stringify":214}],213:[function(require,module,exports){
'use strict';

var utils = require('./utils');

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

// This is what browsers will submit when the  character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the  character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset, 'key');
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
            val = options.decoder(part.slice(pos + 1), defaults.decoder, charset, 'value');
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
            val = val.split(',');
        }

        if (part.indexOf('[]=') > -1) {
            val = isArray(val) ? [val] : val;
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new Error('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};

},{"./utils":215}],214:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var formats = require('./formats');
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaultFormat = formats['default'];
var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string'
        || typeof v === 'number'
        || typeof v === 'boolean'
        || typeof v === 'symbol'
        || typeof v === 'bigint';
};

var stringify = function stringify(
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly,
    charset
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = obj.join(',');
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key') : prefix;
        }

        obj = '';
    }

    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key');
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value'))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (isArray(obj)) {
            pushToArray(values, stringify(
                obj[key],
                typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix,
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        } else {
            pushToArray(values, stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        }
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.formatter,
            options.encodeValuesOnly,
            options.charset
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};

},{"./formats":211,"./utils":215}],215:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = str;
    if (typeof str === 'symbol') {
        string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
        string = String(str);
    }

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    merge: merge
};

},{}],216:[function(require,module,exports){
'use strict';
module.exports = {
	stdout: false,
	stderr: false
};

},{}],217:[function(require,module,exports){
(function (global){
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
var __classPrivateFieldGet;
var __classPrivateFieldSet;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __spreadArrays = function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result["default"] = mod;
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    __classPrivateFieldGet = function (receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    };

    __classPrivateFieldSet = function (receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],218:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ircv3_1 = require("ircv3");
/** @private */
var ClearChat = /** @class */ (function (_super) {
    tslib_1.__extends(ClearChat, _super);
    function ClearChat() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    tslib_1.__decorate([
        ircv3_1.MessageParamDefinition({
            type: 'channel'
        })
    ], ClearChat.prototype, "channel", void 0);
    tslib_1.__decorate([
        ircv3_1.MessageParamDefinition({
            trailing: true,
            optional: true
        })
    ], ClearChat.prototype, "user", void 0);
    ClearChat = tslib_1.__decorate([
        ircv3_1.MessageType('CLEARCHAT')
    ], ClearChat);
    return ClearChat;
}(ircv3_1.Message));
exports.default = ClearChat;

},{"ircv3":191,"tslib":217}],219:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ircv3_1 = require("ircv3");
// this command has no *useful* parameters, all information is in tags
/** @private */
var HostTarget = /** @class */ (function (_super) {
    tslib_1.__extends(HostTarget, _super);
    function HostTarget() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    tslib_1.__decorate([
        ircv3_1.MessageParamDefinition({
            type: 'channel'
        })
    ], HostTarget.prototype, "channel", void 0);
    tslib_1.__decorate([
        ircv3_1.MessageParamDefinition({
            trailing: true
        })
    ], HostTarget.prototype, "targetAndViewers", void 0);
    HostTarget = tslib_1.__decorate([
        ircv3_1.MessageType('HOSTTARGET')
    ], HostTarget);
    return HostTarget;
}(ircv3_1.Message));
exports.default = HostTarget;

},{"ircv3":191,"tslib":217}],220:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ircv3_1 = require("ircv3");
/** @private */
var Reconnect = /** @class */ (function (_super) {
    tslib_1.__extends(Reconnect, _super);
    function Reconnect() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Reconnect.COMMAND = 'RECONNECT';
    return Reconnect;
}(ircv3_1.Message));
exports.default = Reconnect;

},{"ircv3":191,"tslib":217}],221:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ircv3_1 = require("ircv3");
/** @private */
var RoomState = /** @class */ (function (_super) {
    tslib_1.__extends(RoomState, _super);
    function RoomState() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    tslib_1.__decorate([
        ircv3_1.MessageParamDefinition({
            type: 'channel'
        })
    ], RoomState.prototype, "channel", void 0);
    RoomState = tslib_1.__decorate([
        ircv3_1.MessageType('ROOMSTATE')
    ], RoomState);
    return RoomState;
}(ircv3_1.Message));
exports.default = RoomState;

},{"ircv3":191,"tslib":217}],222:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ircv3_1 = require("ircv3");
var ChatUser_1 = require("../../../ChatUser");
var EmoteTools_1 = require("../../../Toolkit/EmoteTools");
/** @private */
var UserNotice = /** @class */ (function (_super) {
    tslib_1.__extends(UserNotice, _super);
    function UserNotice() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(UserNotice.prototype, "userInfo", {
        get: function () {
            return new ChatUser_1.default(this._tags.get('login'), this._tags);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserNotice.prototype, "channelId", {
        get: function () {
            return this._tags.get('room-id') || null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserNotice.prototype, "emoteOffsets", {
        get: function () {
            var _a;
            return EmoteTools_1.parseEmoteOffsets((_a = this._tags) === null || _a === void 0 ? void 0 : _a.get('emotes'));
        },
        enumerable: true,
        configurable: true
    });
    UserNotice.prototype.parseEmotes = function () {
        var messageText = this.params.message;
        if (!messageText) {
            return [];
        }
        var foundEmotes = EmoteTools_1.parseEmotePositions(messageText, this.emoteOffsets);
        return EmoteTools_1.fillTextPositions(messageText, foundEmotes);
    };
    tslib_1.__decorate([
        ircv3_1.MessageParamDefinition({
            type: 'channel'
        })
    ], UserNotice.prototype, "channel", void 0);
    tslib_1.__decorate([
        ircv3_1.MessageParamDefinition({
            trailing: true,
            optional: true
        })
    ], UserNotice.prototype, "message", void 0);
    UserNotice = tslib_1.__decorate([
        ircv3_1.MessageType('USERNOTICE')
    ], UserNotice);
    return UserNotice;
}(ircv3_1.Message));
exports.default = UserNotice;

},{"../../../ChatUser":231,"../../../Toolkit/EmoteTools":233,"ircv3":191,"tslib":217}],223:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ircv3_1 = require("ircv3");
/** @private */
var UserState = /** @class */ (function (_super) {
    tslib_1.__extends(UserState, _super);
    function UserState() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    tslib_1.__decorate([
        ircv3_1.MessageParamDefinition({
            type: 'channel'
        })
    ], UserState.prototype, "type", void 0);
    UserState = tslib_1.__decorate([
        ircv3_1.MessageType('USERSTATE')
    ], UserState);
    return UserState;
}(ircv3_1.Message));
exports.default = UserState;

},{"ircv3":191,"tslib":217}],224:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ircv3_1 = require("ircv3");
var ChatUser_1 = require("../../../ChatUser");
var EmoteTools_1 = require("../../../Toolkit/EmoteTools");
/** @private */
var Whisper = /** @class */ (function (_super) {
    tslib_1.__extends(Whisper, _super);
    function Whisper() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Whisper.prototype, "userInfo", {
        get: function () {
            return new ChatUser_1.default(this._prefix.nick, this._tags);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Whisper.prototype, "emoteOffsets", {
        get: function () {
            var _a;
            return EmoteTools_1.parseEmoteOffsets((_a = this._tags) === null || _a === void 0 ? void 0 : _a.get('emotes'));
        },
        enumerable: true,
        configurable: true
    });
    Whisper.prototype.parseEmotes = function () {
        var messageText = this.params.message;
        var foundEmotes = EmoteTools_1.parseEmotePositions(messageText, this.emoteOffsets);
        return EmoteTools_1.fillTextPositions(messageText, foundEmotes);
    };
    tslib_1.__decorate([
        ircv3_1.MessageParamDefinition()
    ], Whisper.prototype, "target", void 0);
    tslib_1.__decorate([
        ircv3_1.MessageParamDefinition({
            trailing: true,
            optional: true
        })
    ], Whisper.prototype, "message", void 0);
    Whisper = tslib_1.__decorate([
        ircv3_1.MessageType('WHISPER')
    ], Whisper);
    return Whisper;
}(ircv3_1.Message));
exports.default = Whisper;

},{"../../../ChatUser":231,"../../../Toolkit/EmoteTools":233,"ircv3":191,"tslib":217}],225:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ClearChat_1 = require("./MessageTypes/ClearChat");
var HostTarget_1 = require("./MessageTypes/HostTarget");
var Reconnect_1 = require("./MessageTypes/Reconnect");
var RoomState_1 = require("./MessageTypes/RoomState");
var UserNotice_1 = require("./MessageTypes/UserNotice");
var UserState_1 = require("./MessageTypes/UserState");
var Whisper_1 = require("./MessageTypes/Whisper");
/** @private */
var TwitchCommandsCapability = {
    name: 'twitch.tv/commands',
    messageTypes: [ClearChat_1.default, HostTarget_1.default, Reconnect_1.default, RoomState_1.default, UserNotice_1.default, UserState_1.default, Whisper_1.default]
};
exports.default = TwitchCommandsCapability;

},{"./MessageTypes/ClearChat":218,"./MessageTypes/HostTarget":219,"./MessageTypes/Reconnect":220,"./MessageTypes/RoomState":221,"./MessageTypes/UserNotice":222,"./MessageTypes/UserState":223,"./MessageTypes/Whisper":224}],226:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This capability just enables standard IRC commands that Twitch chose to disable by default.
 * It has no message types on its own.
 *
 * @private
 */
var TwitchMembershipCapability = {
    name: 'twitch.tv/membership'
};
exports.default = TwitchMembershipCapability;

},{}],227:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ircv3_1 = require("ircv3");
/**
 * @private
 */
var ClearMsg = /** @class */ (function (_super) {
    tslib_1.__extends(ClearMsg, _super);
    function ClearMsg() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ClearMsg.prototype, "userName", {
        get: function () {
            return this._tags.get('login');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClearMsg.prototype, "targetMessageId", {
        get: function () {
            return this._tags.get('target-msg-id');
        },
        enumerable: true,
        configurable: true
    });
    ClearMsg.COMMAND = 'CLEARMSG';
    tslib_1.__decorate([
        ircv3_1.MessageParamDefinition({
            type: 'channel'
        })
    ], ClearMsg.prototype, "channel", void 0);
    tslib_1.__decorate([
        ircv3_1.MessageParamDefinition({
            trailing: true
        })
    ], ClearMsg.prototype, "message", void 0);
    return ClearMsg;
}(ircv3_1.Message));
exports.default = ClearMsg;

},{"ircv3":191,"tslib":217}],228:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ircv3_1 = require("ircv3");
/**
 * This command has no parameters, all information is in tags.
 *
 * @private
 */
var GlobalUserState = /** @class */ (function (_super) {
    tslib_1.__extends(GlobalUserState, _super);
    function GlobalUserState() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    GlobalUserState.COMMAND = 'GLOBALUSERSTATE';
    return GlobalUserState;
}(ircv3_1.Message));
exports.default = GlobalUserState;

},{"ircv3":191,"tslib":217}],229:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ClearMsg_1 = require("./MessageTypes/ClearMsg");
var GlobalUserState_1 = require("./MessageTypes/GlobalUserState");
/**
 * This capability mostly just adds tags to existing commands.
 *
 * @private
 */
var TwitchTagsCapability = {
    name: 'twitch.tv/tags',
    messageTypes: [GlobalUserState_1.default, ClearMsg_1.default]
};
exports.default = TwitchTagsCapability;

},{"./MessageTypes/ClearMsg":227,"./MessageTypes/GlobalUserState":228}],230:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var logger_1 = require("@d-fischer/logger");
var shared_utils_1 = require("@d-fischer/shared-utils");
var deprecate = require("deprecate");
var ircv3_1 = require("ircv3");
var Commands_1 = require("ircv3/lib/Message/MessageTypes/Commands/");
var twitch_1 = require("twitch");
var TwitchCommandsCapability_1 = require("./Capabilities/TwitchCommandsCapability");
var ClearChat_1 = require("./Capabilities/TwitchCommandsCapability/MessageTypes/ClearChat");
var HostTarget_1 = require("./Capabilities/TwitchCommandsCapability/MessageTypes/HostTarget");
var RoomState_1 = require("./Capabilities/TwitchCommandsCapability/MessageTypes/RoomState");
var UserNotice_1 = require("./Capabilities/TwitchCommandsCapability/MessageTypes/UserNotice");
var Whisper_1 = require("./Capabilities/TwitchCommandsCapability/MessageTypes/Whisper");
var TwitchMembershipCapability_1 = require("./Capabilities/TwitchMembershipCapability");
var TwitchTagsCapability_1 = require("./Capabilities/TwitchTagsCapability");
var ClearMsg_1 = require("./Capabilities/TwitchTagsCapability/MessageTypes/ClearMsg");
var TwitchPrivateMessage_1 = require("./StandardCommands/TwitchPrivateMessage");
var UserTools_1 = require("./Toolkit/UserTools");
var GENERIC_CHANNEL = 'twjs';
/**
 * An interface to Twitch chat.
 *
 * @inheritDoc
 * @hideProtected
 */
var ChatClient = /** @class */ (function (_super) {
    tslib_1.__extends(ChatClient, _super);
    /**
     * Creates a new Twitch chat client.
     *
     * @expandParams
     *
     * @param twitchClient The {@TwitchClient} instance to use for API requests.
     * @param options
     */
    function ChatClient(twitchClient, options) {
        if (options === void 0) { options = {}; }
        var _a, _b;
        var _this = 
        /* eslint-disable no-restricted-syntax */
        _super.call(this, {
            connection: {
                hostName: options.webSocket === false ? 'irc.chat.twitch.tv' : 'irc-ws.chat.twitch.tv',
                secure: options.ssl !== false
            },
            credentials: {
                nick: ''
            },
            webSocket: options.webSocket !== false,
            logger: tslib_1.__assign({ minLevel: options.logLevel }, (_a = options.logger, (_a !== null && _a !== void 0 ? _a : {}))),
            nonConformingCommands: ['004'],
            channels: options.channels
        }) || this;
        _this._authVerified = false;
        /**
         * Fires when a user is timed out from a channel.
         *
         * @eventListener
         * @param channel The channel the user is timed out from.
         * @param user The timed out user.
         * @param duration The duration of the timeout, in seconds.
         */
        _this.onTimeout = _this.registerEvent();
        /**
         * Fires when a user is permanently banned from a channel.
         *
         * @eventListener
         * @param channel The channel the user is banned from.
         * @param user The banned user.
         */
        _this.onBan = _this.registerEvent();
        /**
         * Fires when a user upgrades their bits badge in a channel.
         *
         * @eventListener
         * @param channel The channel where the bits badge was upgraded.
         * @param user The user that has upgraded their bits badge.
         * @param ritualInfo Additional information about the upgrade.
         * @param msg The raw message that was received.
         */
        _this.onBitsBadgeUpgrade = _this.registerEvent();
        /**
         * Fires when the chat of a channel is cleared.
         *
         * @eventListener
         * @param channel The channel whose chat is cleared.
         */
        _this.onChatClear = _this.registerEvent();
        /**
         * Fires when emote-only mode is toggled in a channel.
         *
         * @eventListener
         * @param channel The channel where emote-only mode is being toggled.
         * @param enabled Whether emote-only mode is being enabled. If false, it's being disabled.
         */
        _this.onEmoteOnly = _this.registerEvent();
        /**
         * Fires when followers-only mode is toggled in a channel.
         *
         * @eventListener
         * @param channel The channel where followers-only mode is being toggled.
         * @param enabled Whether followers-only mode is being enabled. If false, it's being disabled.
         * @param delay The time a user needs to follow the channel to be able to talk. Only available when `enabled === true`.
         */
        _this.onFollowersOnly = _this.registerEvent();
        /**
         * Fires when a channel hosts another channel.
         *
         * @eventListener
         * @param channel The hosting channel.
         * @param target The channel that is being hosted.
         * @param viewers The number of viewers in the hosting channel.
         *
         * If you're not logged in as the owner of the channel, this is undefined.
         */
        _this.onHost = _this.registerEvent();
        /**
         * Fires when a channel you're logged in as its owner is being hosted by another channel.
         *
         * @eventListener
         * @param channel The channel that is being hosted.
         * @param byChannel The hosting channel.
         * @param auto Whether the host was triggered automatically (by Twitch's auto-host functionality).
         * @param viewers The number of viewers in the hosting channel.
         */
        _this.onHosted = _this.registerEvent();
        /**
         * Fires when Twitch tells you the number of hosts you have remaining in the next half hour for the channel
         * for which you're logged in as owner after hosting a channel.
         *
         * @eventListener
         * @param channel The hosting channel.
         * @param numberOfHosts The number of hosts remaining in the next half hour.
         */
        _this.onHostsRemaining = _this.registerEvent();
        /**
         * Fires when a user joins a channel.
         *
         * The join/part events are cached by the Twitch chat server and will be batched and sent every 30-60 seconds.
         *
         * @eventListener
         * @param channel The channel that is being joined.
         * @param user The user that joined.
         */
        _this.onJoin = _this.registerEvent();
        /**
         * Fires when a user leaves ("parts") a channel.
         *
         * The join/part events are cached by the Twitch chat server and will be batched and sent every 30-60 seconds.
         *
         * @eventListener
         * @param channel The channel that is being left.
         * @param user The user that left.
         */
        _this.onPart = _this.registerEvent();
        /**
         * Fires when a single message is removed from a channel.
         *
         * @eventListener
         * @param channel The channel where the message was removed.
         * @param messageId The ID of the message that was removed.
         * @param msg The raw message that was received.
         *
         * This is *not* the message that was removed. The text of the message is available using `msg.params.message` though.
         */
        _this.onMessageRemove = _this.registerEvent();
        /**
         * Fires when R9K mode is toggled in a channel.
         *
         * @eventListener
         * @param channel The channel where R9K mode is being toggled.
         * @param enabled Whether R9K mode is being enabled. If false, it's being disabled.
         */
        _this.onR9k = _this.registerEvent();
        /**
         * Fires when host mode is disabled in a channel.
         *
         * @eventListener
         * @param channel The channel where host mode is being disabled.
         */
        _this.onUnhost = _this.registerEvent();
        /**
         * Fires when a user raids a channel.
         *
         * @eventListener
         * @param channel The channel that was raided.
         * @param user The user that has raided the channel.
         * @param raidInfo Additional information about the raid.
         * @param msg The raw message that was received.
         */
        _this.onRaid = _this.registerEvent();
        /**
         * Fires when a user cancels a raid.
         *
         * @eventListener
         * @param channel The channel where the raid was cancelled.
         * @param msg The raw message that was received.
         */
        _this.onRaidCancel = _this.registerEvent();
        /**
         * Fires when a user performs a "ritual" in a channel.
         *
         * @eventListener
         * @param channel The channel where the ritual was performed.
         * @param user The user that has performed the ritual.
         * @param ritualInfo Additional information about the ritual.
         * @param msg The raw message that was received.
         */
        _this.onRitual = _this.registerEvent();
        /**
         * Fires when slow mode is toggled in a channel.
         *
         * @eventListener
         * @param channel The channel where slow mode is being toggled.
         * @param enabled Whether slow mode is being enabled. If false, it's being disabled.
         * @param delay The time a user has to wait between sending messages. Only set when enabling slow mode.
         */
        _this.onSlow = _this.registerEvent();
        /**
         * Fires when sub only mode is toggled in a channel.
         *
         * @eventListener
         * @param channel The channel where sub only mode is being toggled.
         * @param enabled Whether sub only mode is being enabled. If false, it's being disabled.
         */
        _this.onSubsOnly = _this.registerEvent();
        /**
         * Fires when a user subscribes to a channel.
         *
         * @eventListener
         * @param channel The channel that was subscribed to.
         * @param user The subscribing user.
         * @param subInfo Additional information about the subscription.
         * @param msg The raw message that was received.
         */
        _this.onSub = _this.registerEvent();
        /**
         * Fires when a user resubscribes to a channel.
         *
         * @eventListener
         * @param channel The channel that was resubscribed to.
         * @param user The resubscribing user.
         * @param subInfo Additional information about the resubscription.
         * @param msg The raw message that was received.
         */
        _this.onResub = _this.registerEvent();
        /**
         * Fires when a user gifts a subscription to a channel to another user.
         *
         * @eventListener
         * @param channel The channel that was subscribed to.
         * @param user The user that the subscription was gifted to. The gifting user is defined in `subInfo.gifter`.
         * @param subInfo Additional information about the subscription.
         * @param msg The raw message that was received.
         */
        _this.onSubGift = _this.registerEvent();
        /**
         * Fires when a user gifts random subscriptions to the community of a channel.
         *
         * @eventListener
         * @param channel The channel that was subscribed to.
         * @param user The gifting user.
         * @param subInfo Additional information about the community subscription.
         * @param msg The raw message that was received.
         */
        _this.onCommunitySub = _this.registerEvent();
        /**
         * Fires when a user extends their subscription using a Sub Token.
         *
         * @eventListener
         * @param channel The channel where the subscription was extended.
         * @param user The user that extended their subscription.
         * @param subInfo Additional information about the subscription extension.
         * @param msg The raw message that was received.
         */
        _this.onSubExtend = _this.registerEvent();
        /**
         * Fires when a user upgrades their Prime subscription to a paid subscription in a channel.
         *
         * @eventListener
         * @param channel The channel where the subscription was upgraded.
         * @param user The user that upgraded their subscription.
         * @param subInfo Additional information about the subscription upgrade.
         * @param msg The raw message that was received.
         */
        _this.onPrimePaidUpgrade = _this.registerEvent();
        /**
         * Fires when a user upgrades their gift subscription to a paid subscription in a channel.
         *
         * @eventListener
         * @param channel The channel where the subscription was upgraded.
         * @param user The user that upgraded their subscription.
         * @param subInfo Additional information about the subscription upgrade.
         * @param msg The raw message that was received.
         */
        _this.onGiftPaidUpgrade = _this.registerEvent();
        /**
         * Fires when a user gifts a Twitch Prime benefit to the channel.
         *
         * @eventListener
         * @param channel The channel where the benefit was gifted.
         * @param user The user that received the gift.
         *
         * **WARNING:** This is a *display name* and thus will not work as an identifier for the API (login) in some cases.
         * @param subInfo Additional information about the gift.
         * @param msg The raw message that was received.
         */
        _this.onPrimeCommunityGift = _this.registerEvent();
        /**
         * Fires when a user pays forward a subscription that was gifted to them to a specific user.
         *
         * @eventListener
         * @param channel The channel where the gift was forwarded.
         * @param user The user that forwarded the gift.
         * @param forwardInfo Additional information about the gift.
         * @param msg The raw message that was received.
         */
        _this.onStandardPayForward = _this.registerEvent();
        /**
         * Fires when a user pays forward a subscription that was gifted to them to the community.
         *
         * @eventListener
         * @param channel The channel where the gift was forwarded.
         * @param user The user that forwarded the gift.
         * @param forwardInfo Additional information about the gift.
         * @param msg The raw message that was received.
         */
        _this.onCommunityPayForward = _this.registerEvent();
        /**
         * Fires when receiving a whisper from another user.
         *
         * @eventListener
         * @param user The user that sent the whisper.
         * @param message The message text.
         * @param msg The raw message that was received.
         */
        _this.onWhisper = _this.registerEvent();
        /**
         * Fires when you tried to execute a command you don't have sufficient permission for.
         *
         * @eventListener
         * @param channel The channel that a command without sufficient permissions was executed on.
         * @param message The message text.
         */
        _this.onNoPermission = _this.registerEvent();
        /**
         * Fires when a message you tried to send gets rejected by the ratelimiter.
         *
         * @eventListener
         * @param channel The channel that was attempted to send to.
         * @param message The message text.
         */
        _this.onMessageRatelimit = _this.registerEvent();
        /**
         * Fires when authentication fails.
         *
         * @eventListener
         * @param channel The channel that a command without sufficient permissions was executed on.
         * @param message The message text.
         */
        _this.onAuthenticationFailure = _this.registerEvent();
        /**
         * Fires when sending a message fails.
         *
         * @eventListener
         * @param channel The channel that rejected the message.
         * @param reason The reason for the failure, e.g. you're banned (msg_banned)
         */
        _this.onMessageFailed = _this.registerEvent();
        // internal events to resolve promises and stuff
        _this._onBanResult = _this.registerEvent();
        _this._onTimeoutResult = _this.registerEvent();
        _this._onUnbanResult = _this.registerEvent();
        _this._onColorResult = _this.registerEvent();
        _this._onCommercialResult = _this.registerEvent();
        _this._onDeleteMessageResult = _this.registerEvent();
        _this._onEmoteOnlyResult = _this.registerEvent();
        _this._onEmoteOnlyOffResult = _this.registerEvent();
        _this._onFollowersOnlyResult = _this.registerEvent();
        _this._onFollowersOnlyOffResult = _this.registerEvent();
        _this._onHostResult = _this.registerEvent();
        _this._onUnhostResult = _this.registerEvent();
        _this._onModResult = _this.registerEvent();
        _this._onUnmodResult = _this.registerEvent();
        _this._onModsResult = _this.registerEvent();
        _this._onJoinResult = _this.registerEvent();
        _this._onR9kResult = _this.registerEvent();
        _this._onR9kOffResult = _this.registerEvent();
        _this._onSlowResult = _this.registerEvent();
        _this._onSlowOffResult = _this.registerEvent();
        _this._onSubsOnlyResult = _this.registerEvent();
        _this._onSubsOnlyOffResult = _this.registerEvent();
        _this._onVipResult = _this.registerEvent();
        _this._onUnvipResult = _this.registerEvent();
        _this._onVipsResult = _this.registerEvent();
        /* eslint-enable no-restricted-syntax */
        _this._chatLogger = new logger_1.default(tslib_1.__assign({ name: 'twitch-chat', emoji: true, minLevel: options.logLevel }, (_b = options.logger, (_b !== null && _b !== void 0 ? _b : {}))));
        _this._twitchClient = twitchClient;
        _this._useLegacyScopes = !!options.legacyScopes;
        _this._readOnly = !!options.readOnly;
        // tslint:disable:no-floating-promises
        _this.registerCapability(TwitchTagsCapability_1.default);
        _this.registerCapability(TwitchCommandsCapability_1.default);
        if (options.requestMembershipEvents) {
            _this.registerCapability(TwitchMembershipCapability_1.default);
        }
        // tslint:enable:no-floating-promises
        _this.onRegister(function () {
            _this._authVerified = true;
            _this._authFailureMessage = undefined;
        });
        _this.onMessage(ClearChat_1.default, function (_a) {
            var _b = _a.params, channel = _b.channel, user = _b.user, tags = _a.tags;
            if (user) {
                var duration = tags.get('ban-duration');
                if (duration === undefined) {
                    // ban
                    _this.emit(_this.onBan, channel, user);
                }
                else {
                    // timeout
                    _this.emit(_this.onTimeout, channel, user, Number(duration));
                    _this.emit(_this._onTimeoutResult, channel, user, Number(duration));
                }
            }
            else {
                // full chat clear
                _this.emit(_this.onChatClear, channel);
            }
        });
        _this.onMessage(ClearMsg_1.default, function (msg) {
            var channel = msg.params.channel, targetMessageId = msg.targetMessageId;
            _this.emit(_this.onMessageRemove, channel, targetMessageId, msg);
        });
        _this.onMessage(HostTarget_1.default, function (_a) {
            var _b = _a.params, channel = _b.channel, targetAndViewers = _b.targetAndViewers;
            var _c = tslib_1.__read(targetAndViewers.split(' '), 2), target = _c[0], viewers = _c[1];
            if (target === '-') {
                // unhost
                _this.emit(_this.onUnhost, channel);
            }
            else {
                var numViewers = Number(viewers);
                _this.emit(_this.onHost, channel, target, isNaN(numViewers) ? undefined : numViewers);
            }
        });
        _this.onMessage(Commands_1.ChannelJoin, function (_a) {
            var prefix = _a.prefix, channel = _a.params.channel;
            _this.emit(_this.onJoin, channel, prefix.nick);
        });
        _this.onMessage(Commands_1.ChannelPart, function (_a) {
            var prefix = _a.prefix, channel = _a.params.channel;
            _this.emit(_this.onPart, channel, prefix.nick);
        });
        _this.onMessage(TwitchPrivateMessage_1.default, function (_a) {
            var prefix = _a.prefix, _b = _a.params, channel = _b.target, message = _b.message;
            if (prefix && prefix.nick === 'jtv') {
                // 1 = who hosted
                // 2 = auto-host or not
                // 3 = how many viewers (not always present)
                var match = message.match(ChatClient.HOST_MESSAGE_REGEX);
                if (match) {
                    _this.emit(_this.onHosted, channel, match[1], Boolean(match[2]), match[3] === '' ? undefined : Number(match[3]));
                }
            }
        });
        _this.onMessage(RoomState_1.default, function (_a) {
            var channel = _a.params.channel, tags = _a.tags;
            var isInitial = false;
            if (tags.has('subs-only') && tags.has('slow')) {
                // this is the full state - so we just successfully joined
                _this.emit(_this._onJoinResult, channel, tags);
                isInitial = true;
            }
            if (tags.has('slow')) {
                var slowDelay = Number(tags.get('slow'));
                if (slowDelay) {
                    _this.emit(_this._onSlowResult, channel, slowDelay);
                    if (!isInitial) {
                        _this.emit(_this.onSlow, channel, true, slowDelay);
                    }
                }
                else {
                    _this.emit(_this._onSlowOffResult, channel);
                    if (!isInitial) {
                        _this.emit(_this.onSlow, channel, false);
                    }
                }
            }
            if (tags.has('followers-only')) {
                var followDelay = Number(tags.get('followers-only'));
                if (followDelay === -1) {
                    _this.emit(_this._onFollowersOnlyOffResult, channel);
                    if (!isInitial) {
                        _this.emit(_this.onFollowersOnly, channel, false);
                    }
                }
                else {
                    _this.emit(_this._onFollowersOnlyResult, channel, followDelay);
                    if (!isInitial) {
                        _this.emit(_this.onFollowersOnly, channel, true, followDelay);
                    }
                }
            }
        });
        _this.onMessage(UserNotice_1.default, function (userNotice) {
            var _a = userNotice.params, channel = _a.channel, message = _a.message, tags = userNotice.tags;
            var messageType = tags.get('msg-id');
            switch (messageType) {
                case 'sub':
                case 'resub': {
                    var event_1 = messageType === 'sub' ? _this.onSub : _this.onResub;
                    var plan = tags.get('msg-param-sub-plan');
                    var streakMonths = tags.get('msg-param-streak-months');
                    var subInfo = {
                        userId: tags.get('user-id'),
                        displayName: tags.get('display-name'),
                        plan: plan,
                        planName: tags.get('msg-param-sub-plan-name'),
                        isPrime: plan === 'Prime',
                        months: Number(tags.get('msg-param-cumulative-months')),
                        streak: streakMonths ? Number(streakMonths) : undefined,
                        message: message
                    };
                    _this.emit(event_1, channel, tags.get('login'), subInfo, userNotice);
                    break;
                }
                case 'subgift':
                case 'anonsubgift': {
                    var plan = tags.get('msg-param-sub-plan');
                    var gifter = tags.get('login');
                    var isAnon = messageType === 'anonsubgift' || gifter === 'ananonymousgifter';
                    var subInfo = {
                        userId: tags.get('msg-param-recipient-id'),
                        displayName: tags.get('msg-param-recipient-display-name'),
                        gifter: isAnon ? undefined : gifter,
                        gifterUserId: isAnon ? undefined : tags.get('user-id'),
                        gifterDisplayName: isAnon ? undefined : tags.get('display-name'),
                        gifterGiftCount: isAnon ? undefined : Number(tags.get('msg-param-sender-count')),
                        plan: plan,
                        planName: tags.get('msg-param-sub-plan-name'),
                        isPrime: plan === 'Prime',
                        months: Number(tags.get('msg-param-months'))
                    };
                    _this.emit(_this.onSubGift, channel, tags.get('msg-param-recipient-user-name'), subInfo, userNotice);
                    break;
                }
                case 'anonsubmysterygift':
                case 'submysterygift': {
                    var gifter = tags.get('login');
                    var isAnon = messageType === 'anonsubmysterygift' || gifter === 'ananonymousgifter';
                    var communitySubInfo = {
                        gifter: isAnon ? undefined : gifter,
                        gifterUserId: isAnon ? undefined : tags.get('user-id'),
                        gifterDisplayName: isAnon ? undefined : tags.get('display-name'),
                        gifterGiftCount: isAnon ? undefined : Number(tags.get('msg-param-sender-count')),
                        count: Number(tags.get('msg-param-mass-gift-count')),
                        plan: tags.get('msg-param-sub-plan')
                    };
                    _this.emit(_this.onCommunitySub, channel, tags.get('login'), communitySubInfo, userNotice);
                    break;
                }
                case 'primepaidupgrade': {
                    var upgradeInfo = {
                        userId: tags.get('user-id'),
                        displayName: tags.get('display-name'),
                        plan: tags.get('msg-param-sub-plan')
                    };
                    _this.emit(_this.onPrimePaidUpgrade, channel, tags.get('login'), upgradeInfo, userNotice);
                    break;
                }
                case 'giftpaidupgrade': {
                    var upgradeInfo = {
                        userId: tags.get('user-id'),
                        displayName: tags.get('display-name'),
                        plan: tags.get('msg-param-sub-plan'),
                        gifter: tags.get('msg-param-sender-login'),
                        gifterDisplayName: tags.get('msg-param-sender-name')
                    };
                    _this.emit(_this.onGiftPaidUpgrade, channel, tags.get('login'), upgradeInfo, userNotice);
                    break;
                }
                case 'standardpayforward': {
                    var wasAnon = tags.get('msg-param-prior-gifter-anonymous') === 'true';
                    var forwardInfo = {
                        userId: tags.get('user-id'),
                        displayName: tags.get('display-name'),
                        originalGifterUserId: wasAnon ? undefined : tags.get('msg-param-prior-gifter-id'),
                        originalGifterDisplayName: wasAnon
                            ? undefined
                            : tags.get('msg-param-prior-gifter-display-name'),
                        recipientUserId: tags.get('msg-param-recipient-id'),
                        recipientDisplayName: tags.get('msg-param-recipient-display-name')
                    };
                    _this.emit(_this.onStandardPayForward, channel, tags.get('login'), forwardInfo, userNotice);
                    break;
                }
                case 'communitypayforward': {
                    var wasAnon = tags.get('msg-param-prior-gifter-anonymous') === 'true';
                    var forwardInfo = {
                        userId: tags.get('user-id'),
                        displayName: tags.get('display-name'),
                        originalGifterUserId: wasAnon ? undefined : tags.get('msg-param-prior-gifter-id'),
                        originalGifterDisplayName: wasAnon
                            ? undefined
                            : tags.get('msg-param-prior-gifter-display-name')
                    };
                    _this.emit(_this.onCommunityPayForward, channel, tags.get('login'), forwardInfo, userNotice);
                    break;
                }
                case 'primecommunitygiftreceived': {
                    var giftInfo = {
                        name: tags.get('msg-param-gift-name'),
                        gifter: tags.get('login'),
                        gifterDisplayName: tags.get('display-name')
                    };
                    _this.emit(_this.onPrimeCommunityGift, channel, tags.get('msg-param-recipient'), giftInfo, userNotice);
                    break;
                }
                case 'raid': {
                    var raidInfo = {
                        displayName: tags.get('msg-param-displayName'),
                        viewerCount: Number(tags.get('msg-param-viewerCount'))
                    };
                    _this.emit(_this.onRaid, channel, tags.get('login'), raidInfo, userNotice);
                    break;
                }
                case 'unraid': {
                    _this.emit(_this.onRaidCancel, channel, userNotice);
                    break;
                }
                case 'ritual': {
                    var ritualInfo = {
                        ritualName: tags.get('msg-param-ritual-name'),
                        message: message
                    };
                    _this.emit(_this.onRitual, channel, tags.get('login'), ritualInfo, userNotice);
                    break;
                }
                case 'bitsbadgetier': {
                    var badgeUpgradeInfo = {
                        displayName: tags.get('display-name'),
                        threshold: Number(tags.get('msg-param-threshold'))
                    };
                    _this.emit(_this.onBitsBadgeUpgrade, channel, tags.get('login'), badgeUpgradeInfo, userNotice);
                    break;
                }
                case 'extendsub': {
                    var extendInfo = {
                        userId: tags.get('user-id'),
                        displayName: tags.get('display-name'),
                        plan: tags.get('msg-param-sub-plan'),
                        months: Number(tags.get('msg-param-cumulative-months')),
                        endMonth: Number(tags.get('msg-param-sub-benefit-end-month'))
                    };
                    _this.emit(_this.onSubExtend, channel, tags.get('login'), extendInfo, userNotice);
                    break;
                }
                default: {
                    _this._chatLogger.warn("Unrecognized usernotice ID: " + messageType);
                }
            }
        });
        _this.onMessage(Whisper_1.default, function (whisper) {
            _this.emit(_this.onWhisper, whisper.prefix.nick, whisper.params.message, whisper);
        });
        _this.onMessage(Commands_1.Notice, function (_a) {
            var _b = _a.params, channel = _b.target, message = _b.message, tags = _a.tags;
            var messageType = tags.get('msg-id');
            // this event handler involves a lot of parsing strings you shouldn't parse...
            // but Twitch doesn't give us the required info in tags ( 
            // (this code also might not do the right thing with foreign character display names...)
            switch (messageType) {
                // ban
                case 'already_banned': {
                    var match = message.split(' ');
                    var user = match && /^\w+$/.test(match[0]) ? match[0] : undefined;
                    if (user) {
                        _this.emit(_this._onBanResult, channel, user, messageType);
                    }
                    break;
                }
                case 'bad_ban_self': {
                    _this.emit(_this._onBanResult, channel, _this._credentials.nick, messageType);
                    break;
                }
                case 'bad_ban_broadcaster': {
                    _this.emit(_this._onBanResult, channel, UserTools_1.toUserName(channel), messageType);
                    break;
                }
                case 'bad_ban_admin':
                case 'bad_ban_global_mod':
                case 'bad_ban_staff': {
                    var match = message.match(/^You cannot ban (?:\w+ )+?(\w+)\.$/);
                    if (match) {
                        _this.emit(_this._onBanResult, channel, match[1].toLowerCase(), messageType);
                    }
                    break;
                }
                case 'ban_success': {
                    var match = message.split(' ');
                    var user = match && /^\w+$/.test(match[0]) ? match[0] : undefined;
                    if (user) {
                        _this.emit(_this._onBanResult, channel, user);
                    }
                    break;
                }
                // unban
                case 'bad_unban_no_ban': {
                    var match = message.split(' ');
                    var user = match && /^\w+$/.test(match[0]) ? match[0] : undefined;
                    if (user) {
                        _this.emit(_this._onUnbanResult, channel, user, messageType);
                    }
                    break;
                }
                case 'unban_success': {
                    var match = message.split(' ');
                    var user = match && /^\w+$/.test(match[0]) ? match[0] : undefined;
                    if (user) {
                        _this.emit(_this._onUnbanResult, channel, user);
                    }
                    break;
                }
                // color
                case 'turbo_only_color': {
                    _this.emit(_this._onColorResult, messageType);
                    break;
                }
                case 'color_changed': {
                    _this.emit(_this._onColorResult);
                    break;
                }
                // commercial
                case 'bad_commercial_error': {
                    _this.emit(_this._onCommercialResult, channel, messageType);
                    break;
                }
                case 'commercial_success': {
                    _this.emit(_this._onCommercialResult, channel);
                    break;
                }
                // delete message
                case 'bad_delete_message_error':
                case 'bad_delete_message_broadcaster':
                case 'bad_delete_message_mod': {
                    _this.emit(_this._onDeleteMessageResult, channel, messageType);
                    break;
                }
                case 'delete_message_success': {
                    _this.emit(_this._onDeleteMessageResult, channel);
                    break;
                }
                // emote only
                case 'already_emote_only_on': {
                    _this.emit(_this._onEmoteOnlyResult, channel, messageType);
                    break;
                }
                case 'emote_only_on': {
                    _this.emit(_this._onEmoteOnlyResult, channel);
                    _this.emit(_this.onEmoteOnly, channel, true);
                    break;
                }
                // emote only off
                case 'already_emote_only_off': {
                    _this.emit(_this._onEmoteOnlyOffResult, channel, messageType);
                    break;
                }
                case 'emote_only_off': {
                    _this.emit(_this._onEmoteOnlyOffResult, channel);
                    _this.emit(_this.onEmoteOnly, channel, false);
                    break;
                }
                // host
                case 'bad_host_hosting':
                case 'bad_host_rate_exceeded':
                case 'bad_host_error': {
                    _this.emit(_this._onHostResult, channel, messageType);
                    break;
                }
                case 'hosts_remaining': {
                    var remainingHostsFromChar = +message[0];
                    var remainingHosts = isNaN(remainingHostsFromChar) ? 0 : Number(remainingHostsFromChar);
                    _this.emit(_this._onHostResult, channel);
                    _this.emit(_this.onHostsRemaining, channel, remainingHosts);
                    break;
                }
                // unhost (only fails, success is handled by HOSTTARGET)
                case 'not_hosting': {
                    _this.emit(_this._onUnhostResult, channel, messageType);
                    break;
                }
                // join (success is handled when ROOMSTATE comes in)
                case 'msg_channel_suspended': {
                    _this.emit(_this._onJoinResult, channel, undefined, messageType);
                    break;
                }
                // mod
                case 'bad_mod_banned':
                case 'bad_mod_mod': {
                    var match = message.split(' ');
                    var user = match && /^\w+$/.test(match[0]) ? match[0] : undefined;
                    if (user) {
                        _this.emit(_this._onModResult, channel, user, messageType);
                    }
                    break;
                }
                case 'mod_success': {
                    var match = message.match(/^You have added (\w+) /);
                    if (match) {
                        _this.emit(_this._onModResult, channel, match[1]);
                    }
                    break;
                }
                // unmod
                case 'bad_unmod_mod': {
                    var match = message.split(' ');
                    var user = match && /^\w+$/.test(match[0]) ? match[0] : undefined;
                    if (user) {
                        _this.emit(_this._onUnmodResult, channel, user, messageType);
                    }
                    break;
                }
                case 'unmod_success': {
                    var match = message.match(/^You have removed (\w+) /);
                    if (match) {
                        _this.emit(_this._onUnmodResult, channel, match[1]);
                    }
                    break;
                }
                // mods
                case 'no_mods': {
                    _this.emit(_this._onModsResult, channel, []);
                    break;
                }
                case 'room_mods': {
                    var _c = tslib_1.__read(message.split(': '), 2), modList = _c[1];
                    var mods = modList.split(', ');
                    _this.emit(_this._onModsResult, channel, mods);
                    break;
                }
                // r9k
                case 'already_r9k_on': {
                    _this.emit(_this._onR9kResult, channel, messageType);
                    break;
                }
                case 'r9k_on': {
                    _this.emit(_this._onR9kResult, channel);
                    _this.emit(_this.onR9k, channel, true);
                    break;
                }
                // r9k off
                case 'already_r9k_off': {
                    _this.emit(_this._onR9kOffResult, channel, messageType);
                    break;
                }
                case 'r9k_off': {
                    _this.emit(_this._onR9kOffResult, channel);
                    _this.emit(_this.onR9k, channel, false);
                    break;
                }
                // subs only
                case 'already_subs_on': {
                    _this.emit(_this._onSubsOnlyResult, channel, messageType);
                    break;
                }
                case 'subs_on': {
                    _this.emit(_this._onSubsOnlyResult, channel);
                    _this.emit(_this.onSubsOnly, channel, true);
                    break;
                }
                // subs only off
                case 'already_subs_off': {
                    _this.emit(_this._onSubsOnlyOffResult, channel, messageType);
                    break;
                }
                case 'subs_off': {
                    _this.emit(_this._onSubsOnlyOffResult, channel);
                    _this.emit(_this.onSubsOnly, channel, false);
                    break;
                }
                // timeout (only fails, success is handled by CLEARCHAT)
                case 'bad_timeout_self': {
                    _this.emit(_this._onTimeoutResult, channel, _this._credentials.nick, undefined, messageType);
                    break;
                }
                case 'bad_timeout_broadcaster': {
                    _this.emit(_this._onTimeoutResult, channel, UserTools_1.toUserName(channel), undefined, messageType);
                    break;
                }
                case 'bad_timeout_admin':
                case 'bad_timeout_global_mod':
                case 'bad_timeout_staff': {
                    var match = message.match(/^You cannot ban (?:\w+ )+?(\w+)\.$/);
                    if (match) {
                        _this.emit(_this._onTimeoutResult, channel, match[1].toLowerCase(), undefined, messageType);
                    }
                    break;
                }
                // vip
                case 'bad_vip_grantee_banned':
                case 'bad_vip_grantee_already_vip': {
                    var match = message.split(' ');
                    var user = match && /^\w+$/.test(match[0]) ? match[0] : undefined;
                    if (user) {
                        _this.emit(_this._onVipResult, channel, user, messageType);
                    }
                    break;
                }
                case 'vip_success': {
                    var match = message.match(/^You have added (\w+) /);
                    if (match) {
                        _this.emit(_this._onVipResult, channel, match[1]);
                    }
                    break;
                }
                // unvip
                case 'bad_unvip_grantee_not_vip': {
                    var match = message.split(' ');
                    var user = match && /^\w+$/.test(match[0]) ? match[0] : undefined;
                    if (user) {
                        _this.emit(_this._onUnvipResult, channel, user, messageType);
                    }
                    break;
                }
                case 'unvip_success': {
                    var match = message.match(/^You have removed (\w+) /);
                    if (match) {
                        _this.emit(_this._onUnvipResult, channel, match[1]);
                    }
                    break;
                }
                // vips
                case 'no_vips': {
                    _this.emit(_this._onVipsResult, channel, []);
                    break;
                }
                case 'vips_success': {
                    var _d = tslib_1.__read(message.split(': '), 2), vipList = _d[1];
                    var vips = vipList.split(', ');
                    _this.emit(_this._onVipsResult, channel, vips);
                    break;
                }
                case 'cmds_available': {
                    // do we really care?
                    break;
                }
                // there's other messages that show us the following things...
                // ...like ROOMSTATE...
                case 'followers_on':
                case 'followers_on_zero':
                case 'followers_off':
                case 'slow_on':
                case 'slow_off': {
                    break;
                }
                // ...and CLEARCHAT...
                case 'timeout_success': {
                    break;
                }
                // ...and HOSTTARGET
                case 'host_off':
                case 'host_on':
                case 'host_target_went_offline': {
                    break;
                }
                case 'unrecognized_cmd': {
                    break;
                }
                case 'no_permission': {
                    _this.emit(_this.onNoPermission, channel, message);
                    break;
                }
                case 'msg_ratelimit': {
                    _this.emit(_this.onMessageRatelimit, channel, message);
                    break;
                }
                case 'msg_banned': {
                    _this.emit(_this.onMessageFailed, channel, messageType);
                    break;
                }
                case undefined: {
                    // this might be one of these weird authentication error notices that don't have a msg-id...
                    if (message === 'Login authentication failed' ||
                        message === 'Improperly formatted AUTH' ||
                        message === 'Invalid NICK') {
                        _this._authVerified = false;
                        _this._authFailureMessage = message;
                        _this.emit(_this.onAuthenticationFailure, message);
                        _this._connection.disconnect(false);
                    }
                    break;
                }
                default: {
                    if (!messageType || messageType.substr(0, 6) !== 'usage_') {
                        _this._chatLogger.warn("Unrecognized notice ID: '" + messageType + "'");
                    }
                }
            }
        });
        return _this;
    }
    /**
     * Creates a new Twitch chat client with the user info from the TwitchClient instance.
     *
     * @expandParams
     *
     * @param twitchClient The TwitchClient instance to use for user info and API requests.
     * @param options
     */
    ChatClient.forTwitchClient = function (twitchClient, options) {
        if (options === void 0) { options = {}; }
        return new this(twitchClient, options);
    };
    /**
     * Creates a new anonymous Twitch chat client.
     *
     * @expandParams
     *
     * @param options
     */
    ChatClient.anonymous = function (options) {
        if (options === void 0) { options = {}; }
        return new this(undefined, options);
    };
    ChatClient.prototype.connect = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._twitchClient) {
                            this._updateCredentials({
                                nick: ChatClient._generateJustinfanNick(),
                                password: undefined
                            });
                        }
                        return [4 /*yield*/, _super.prototype.connect.call(this)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Hosts a channel on another channel.
     *
     * @param target The host target, i.e. the channel that is being hosted.
     * @param channel The host source, i.e. the channel that is hosting. Defaults to the channel of the connected user.
     */
    ChatClient.prototype.host = function (channel, target) {
        if (channel === void 0) { channel = this._credentials.nick; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onHostResult(function (chan, error) {
                            if (UserTools_1.toUserName(chan) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, "/host " + target);
                    })];
            });
        });
    };
    /**
     * Ends any host on a channel.
     *
     * This only works when in the channel that was hosted in order to provide feedback about success of the command.
     *
     * If you don't need this feedback, consider using {@ChatClient#unhostOutside} instead.
     *
     * @param channel The channel to end the host on. Defaults to the channel of the connected user.
     */
    ChatClient.prototype.unhost = function (channel) {
        if (channel === void 0) { channel = this._credentials.nick; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onUnhostResult(function (chan, error) {
                            if (UserTools_1.toUserName(chan) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, '/unhost');
                    })];
            });
        });
    };
    /**
     * Ends any host on a channel.
     *
     * This works even when not in the channel that was hosted, but provides no feedback about success of the command.
     *
     * If you need feedback about success, use {@ChatClient#unhost} (but make sure you're in the channel you are hosting).
     *
     * @param channel The channel to end the host on. Defaults to the channel of the connected user.
     */
    ChatClient.prototype.unhostOutside = function (channel) {
        if (channel === void 0) { channel = this._credentials.nick; }
        this.say(channel, '/unhost');
    };
    /**
     * Bans a user from a channel.
     *
     * @param channel The channel to ban the user from. Defaults to the channel of the connected user.
     * @param user The user to ban from the channel.
     * @param reason The reason for the ban.
     */
    ChatClient.prototype.ban = function (channel, user, reason) {
        if (channel === void 0) { channel = this._credentials.nick; }
        if (reason === void 0) { reason = ''; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                user = UserTools_1.toUserName(user);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onBanResult(function (_channel, _user, error) {
                            if (UserTools_1.toUserName(_channel) === channel && UserTools_1.toUserName(_user) === user) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, "/ban " + user + " " + reason);
                    })];
            });
        });
    };
    /**
     * Clears all messages in a channel.
     *
     * @param channel The channel to ban the user from. Defaults to the channel of the connected user.
     */
    ChatClient.prototype.clear = function (channel) {
        if (channel === void 0) { channel = this._credentials.nick; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve) {
                        var e = _this.onChatClear(function (_channel) {
                            if (UserTools_1.toUserName(_channel) === channel) {
                                resolve();
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, '/clear');
                    })];
            });
        });
    };
    /**
     * Changes your username color.
     *
     * @param color The hexadecimal code (prefixed with #) or color name to use for your username.
     *
     * Please note that only Twitch Turbo or Prime users can use hexadecimal codes for arbitrary colors.
     *
     * If you have neither of those, you can only choose from the following color names:
     *
     * Blue, BlueViolet, CadetBlue, Chocolate, Coral, DodgerBlue, Firebrick, GoldenRod, Green, HotPink, OrangeRed, Red, SeaGreen, SpringGreen, YellowGreen
     */
    ChatClient.prototype.changeColor = function (color) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onColorResult(function (error) {
                            if (error) {
                                reject(error);
                            }
                            else {
                                resolve();
                            }
                            _this.removeListener(e);
                        });
                        _this.say(GENERIC_CHANNEL, "/color " + color);
                    })];
            });
        });
    };
    /**
     * Runs a commercial break on a channel.
     *
     * @param channel The channel to run the commercial break on.
     * @param duration The duration of the commercial break.
     */
    ChatClient.prototype.runCommercial = function (channel, duration) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onCommercialResult(function (_channel, error) {
                            if (UserTools_1.toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, "/commercial " + duration);
                    })];
            });
        });
    };
    /**
     * Deletes a message from a channel.
     *
     * @param channel The channel to delete the message from.
     * @param message The message (as message ID or message object) to delete.
     */
    ChatClient.prototype.deleteMessage = function (channel, message) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var messageId;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                messageId = message instanceof Commands_1.PrivateMessage ? message.tags.get('id') : message;
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onDeleteMessageResult(function (_channel, error) {
                            if (UserTools_1.toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, "/delete " + messageId);
                    })];
            });
        });
    };
    /**
     * Enables emote-only mode in a channel.
     *
     * @param channel The channel to enable emote-only mode in.
     */
    ChatClient.prototype.enableEmoteOnly = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onEmoteOnlyResult(function (_channel, error) {
                            if (UserTools_1.toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, '/emoteonly');
                    })];
            });
        });
    };
    /**
     * Disables emote-only mode in a channel.
     *
     * @param channel The channel to disable emote-only mode in.
     */
    ChatClient.prototype.disableEmoteOnly = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onEmoteOnlyOffResult(function (_channel, error) {
                            if (UserTools_1.toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, '/emoteonlyoff');
                    })];
            });
        });
    };
    /**
     * Enables followers-only mode in a channel.
     *
     * @param channel The channel to enable followers-only mode in.
     * @param delay The time (in minutes) a user needs to be following before being able to send messages.
     */
    ChatClient.prototype.enableFollowersOnly = function (channel, delay) {
        if (delay === void 0) { delay = 0; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onFollowersOnlyResult(function (_channel, _delay, error) {
                            if (UserTools_1.toUserName(_channel) === channel && _delay === delay) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, "/followers " + (delay || ''));
                    })];
            });
        });
    };
    /**
     * Disables followers-only mode in a channel.
     *
     * @param channel The channel to disable followers-only mode in.
     */
    ChatClient.prototype.disableFollowersOnly = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onFollowersOnlyOffResult(function (_channel, error) {
                            if (UserTools_1.toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, '/followersoff');
                    })];
            });
        });
    };
    /**
     * Gives a user moderator rights in a channel.
     *
     * @param channel The channel to give the user moderator rights in.
     * @param user The user to give moderator rights.
     */
    ChatClient.prototype.mod = function (channel, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                user = UserTools_1.toUserName(user);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onModResult(function (_channel, _user, error) {
                            if (UserTools_1.toUserName(_channel) === channel && UserTools_1.toUserName(_user) === user) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, "/mod " + user);
                    })];
            });
        });
    };
    /**
     * Takes moderator rights from a user in a channel.
     *
     * @param channel The channel to remove the user's moderator rights in.
     * @param user The user to take moderator rights from.
     */
    ChatClient.prototype.unmod = function (channel, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                user = UserTools_1.toUserName(user);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onUnmodResult(function (_channel, _user, error) {
                            if (UserTools_1.toUserName(_channel) === channel && UserTools_1.toUserName(_user) === user) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, "/unmod " + user);
                    })];
            });
        });
    };
    /**
     * Retrieves a list of moderators in a channel.
     *
     * @param channel The channel to retrieve the moderators of.
     */
    ChatClient.prototype.getMods = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve) {
                        var e = _this._onModsResult(function (_channel, mods) {
                            if (UserTools_1.toUserName(_channel) === channel) {
                                resolve(mods);
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, '/mods');
                    })];
            });
        });
    };
    /**
     * Enables r9k mode in a channel.
     *
     * @param channel The channel to enable r9k mode in.
     */
    ChatClient.prototype.enableR9k = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onR9kResult(function (_channel, error) {
                            if (UserTools_1.toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, '/r9kbeta');
                    })];
            });
        });
    };
    /**
     * Disables r9k mode in a channel.
     *
     * @param channel The channel to disable r9k mode in.
     */
    ChatClient.prototype.disableR9k = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onR9kOffResult(function (_channel, error) {
                            if (UserTools_1.toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, '/r9kbetaoff');
                    })];
            });
        });
    };
    /**
     * Enables slow mode in a channel.
     *
     * @param channel The channel to enable slow mode in.
     * @param delay The time (in seconds) a user needs to wait between messages.
     */
    ChatClient.prototype.enableSlow = function (channel, delay) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onSlowResult(function (_channel, error) {
                            if (UserTools_1.toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, '/slow');
                    })];
            });
        });
    };
    /**
     * Disables slow mode in a channel.
     *
     * @param channel The channel to disable slow mode in.
     */
    ChatClient.prototype.disableSlow = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onSlowOffResult(function (_channel, error) {
                            if (UserTools_1.toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, '/slowoff');
                    })];
            });
        });
    };
    /**
     * Enables subscribers-only mode in a channel.
     *
     * @param channel The channel to enable subscribers-only mode in.
     */
    ChatClient.prototype.enableSubsOnly = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onSubsOnlyResult(function (_channel, error) {
                            if (UserTools_1.toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, '/subscribers');
                    })];
            });
        });
    };
    /**
     * Disables subscribers-only mode in a channel.
     *
     * @param channel The channel to disable subscribers-only mode in.
     */
    ChatClient.prototype.disableSubsOnly = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onSubsOnlyOffResult(function (_channel, error) {
                            if (UserTools_1.toUserName(_channel) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, '/subscribersoff');
                    })];
            });
        });
    };
    /**
     * Times out a user in a channel and removes all their messages.
     *
     * @param channel The channel to time out the user in.
     * @param user The user to time out.
     * @param duration The time (in seconds) until the user can send messages again. Defaults to 1 minute.
     * @param reason
     */
    ChatClient.prototype.timeout = function (channel, user, duration, reason) {
        if (duration === void 0) { duration = 60; }
        if (reason === void 0) { reason = ''; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onTimeoutResult(function (_channel, _user, error) {
                            if (UserTools_1.toUserName(_channel) === channel && UserTools_1.toUserName(_user) === user) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, "/timeout " + user + " " + duration + " " + reason);
                    })];
            });
        });
    };
    /**
     * Removes all messages of a user from a channel.
     *
     * @param channel The channel to purge the user's messages from.
     * @param user The user to purge.
     * @param reason The reason for the purge.
     */
    ChatClient.prototype.purge = function (channel, user, reason) {
        if (reason === void 0) { reason = ''; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.timeout(channel, user, 1, reason)];
            });
        });
    };
    /**
     * Gives a user VIP status in a channel.
     *
     * @param channel The channel to give the user VIP status in.
     * @param user The user to give VIP status.
     */
    ChatClient.prototype.addVIP = function (channel, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                user = UserTools_1.toUserName(user);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onVipResult(function (_channel, _user, error) {
                            if (UserTools_1.toUserName(_channel) === channel && UserTools_1.toUserName(_user) === user) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, "/vip " + user);
                    })];
            });
        });
    };
    /**
     * Takes VIP status from a user in a channel.
     *
     * @param channel The channel to remove the user's VIP status in.
     * @param user The user to take VIP status from.
     */
    ChatClient.prototype.removeVIP = function (channel, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                user = UserTools_1.toUserName(user);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onUnvipResult(function (_channel, _user, error) {
                            if (UserTools_1.toUserName(_channel) === channel && UserTools_1.toUserName(_user) === user) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, "/unvip " + user);
                    })];
            });
        });
    };
    /**
     * Retrieves a list of moderators in a channel.
     *
     * @param channel The channel to retrieve the moderators of.
     */
    ChatClient.prototype.getVIPs = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve) {
                        var e = _this._onVipsResult(function (_channel, vips) {
                            if (UserTools_1.toUserName(_channel) === channel) {
                                resolve(vips);
                                _this.removeListener(e);
                            }
                        });
                        _this.say(channel, '/vips');
                    })];
            });
        });
    };
    /**
     * Sends a message to a channel.
     *
     * @param channel The channel to send the message to.
     * @param message The message to send.
     */
    ChatClient.prototype.say = function (channel, message) {
        _super.prototype.say.call(this, UserTools_1.toChannelName(channel), message);
    };
    /**
     * Sends an action message (/me) to a channel.
     *
     * @param channel The channel to send the message to.
     * @param message The message to send.
     */
    ChatClient.prototype.action = function (channel, message) {
        _super.prototype.action.call(this, UserTools_1.toChannelName(channel), message);
    };
    /**
     * Sends a whisper message to another user.
     *
     * @param user The user to send the message to.
     * @param message The message to send.
     */
    ChatClient.prototype.whisper = function (user, message) {
        _super.prototype.say.call(this, GENERIC_CHANNEL, "/w " + UserTools_1.toUserName(user) + " " + message);
    };
    /**
     * Joins a channel.
     *
     * @param channel The channel to join.
     */
    ChatClient.prototype.join = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                channel = UserTools_1.toChannelName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var timer;
                        var e = _this._onJoinResult(function (chan, state, error) {
                            if (chan === channel) {
                                clearTimeout(timer);
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        timer = setTimeout(function () {
                            _this.removeListener(e);
                            reject(new Error("Did not receive a reply to join " + channel + " in time; assuming that the join failed"));
                        }, 10000);
                        _super.prototype.join.call(_this, channel);
                    })];
            });
        });
    };
    /**
     * Leaves a channel ("part" in IRC terms).
     *
     * @param channel The channel to leave.
     */
    ChatClient.prototype.part = function (channel) {
        _super.prototype.part.call(this, UserTools_1.toChannelName(channel));
    };
    /**
     * Disconnects from the chat server.
     */
    ChatClient.prototype.quit = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve) {
                        if (_this._connection) {
                            var thatConnection_1 = _this._connection;
                            var handler_1 = function () {
                                thatConnection_1.removeListener('disconnect', handler_1);
                                resolve();
                            };
                            thatConnection_1.addListener('disconnect', handler_1);
                            thatConnection_1.disconnect();
                        }
                    })];
            });
        });
    };
    /**
     * Waits for authentication (or "registration" in IRC terms) to finish.
     *
     * @deprecated Use the `onRegister` event instead. To join channels after connecting, use the `channels` option.
     */
    ChatClient.prototype.waitForRegistration = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var authListener;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        deprecate('[twitch-chat-client] ChatClient#waitForRegistration', 'Use the `onRegister` event instead. To join channels after connecting, use the `channels` option.');
                        if (this._registered) {
                            return [2 /*return*/];
                        }
                        if (this._authFailureMessage) {
                            throw new Error("Registration failed. Response from Twitch: " + this._authFailureMessage);
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, , 3, 4]);
                        return [4 /*yield*/, Promise.race([
                                new Promise(function (resolve, reject) {
                                    authListener = _this.onAuthenticationFailure(function (message) {
                                        reject(Error("Registration failed. Response from Twitch: " + message));
                                    });
                                }),
                                _super.prototype.waitForRegistration.call(this)
                            ])];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        if (authListener) {
                            this.removeListener(authListener);
                        }
                        return [7 /*endfinally*/];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    ChatClient.prototype.registerCoreMessageTypes = function () {
        _super.prototype.registerCoreMessageTypes.call(this);
        this.registerMessageType(TwitchPrivateMessage_1.default);
    };
    ChatClient.prototype.getPassword = function (currentPassword) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var scopes, lastTokenError, accessToken, token, e_1, newToken, token, e_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._twitchClient) {
                            return [2 /*return*/, undefined];
                        }
                        if (currentPassword && this._authVerified) {
                            this._chatLogger.debug2('Password assumed to be correct from last connection');
                            return [2 /*return*/, currentPassword];
                        }
                        if (this._useLegacyScopes) {
                            scopes = ['chat_login'];
                        }
                        else if (this._readOnly) {
                            scopes = ['chat:read'];
                        }
                        else {
                            scopes = ['chat:read', 'chat:edit'];
                        }
                        lastTokenError = undefined;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 5, , 6]);
                        return [4 /*yield*/, this._twitchClient.getAccessToken(scopes)];
                    case 2:
                        accessToken = _a.sent();
                        if (!accessToken) return [3 /*break*/, 4];
                        return [4 /*yield*/, this._twitchClient.getTokenInfo()];
                    case 3:
                        token = _a.sent();
                        this._updateCredentials({
                            nick: token.userName
                        });
                        return [2 /*return*/, "oauth:" + accessToken.accessToken];
                    case 4: return [3 /*break*/, 6];
                    case 5:
                        e_1 = _a.sent();
                        if (e_1 instanceof twitch_1.InvalidTokenError) {
                            lastTokenError = e_1;
                        }
                        else {
                            this._chatLogger.err("Retrieving an access token failed: " + e_1.message);
                        }
                        return [3 /*break*/, 6];
                    case 6:
                        this._chatLogger.warning('No valid token available; trying to refresh');
                        _a.label = 7;
                    case 7:
                        _a.trys.push([7, 11, , 12]);
                        return [4 /*yield*/, this._twitchClient.refreshAccessToken()];
                    case 8:
                        newToken = _a.sent();
                        if (!newToken) return [3 /*break*/, 10];
                        return [4 /*yield*/, this._twitchClient.getTokenInfo()];
                    case 9:
                        token = _a.sent();
                        this._updateCredentials({
                            nick: token.userName
                        });
                        return [2 /*return*/, "oauth:" + newToken.accessToken];
                    case 10: return [3 /*break*/, 12];
                    case 11:
                        e_2 = _a.sent();
                        if (e_2 instanceof twitch_1.InvalidTokenError) {
                            lastTokenError = e_2;
                        }
                        else {
                            this._chatLogger.err("Refreshing the access token failed: " + e_2.message);
                        }
                        return [3 /*break*/, 12];
                    case 12:
                        this._authVerified = false;
                        throw lastTokenError || new Error('Could not retrieve a valid token');
                }
            });
        });
    };
    ChatClient._generateJustinfanNick = function () {
        var randomSuffix = Math.floor(Math.random() * 100000)
            .toString()
            .padStart(5, '0');
        return "justinfan" + randomSuffix;
    };
    ChatClient.HOST_MESSAGE_REGEX = /(\w+) is now ((?:auto[- ])?)hosting you(?: for (?:up to )?(\d+))?/;
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatClient.prototype, "_twitchClient", void 0);
    return ChatClient;
}(ircv3_1.default));
exports.default = ChatClient;

},{"./Capabilities/TwitchCommandsCapability":225,"./Capabilities/TwitchCommandsCapability/MessageTypes/ClearChat":218,"./Capabilities/TwitchCommandsCapability/MessageTypes/HostTarget":219,"./Capabilities/TwitchCommandsCapability/MessageTypes/RoomState":221,"./Capabilities/TwitchCommandsCapability/MessageTypes/UserNotice":222,"./Capabilities/TwitchCommandsCapability/MessageTypes/Whisper":224,"./Capabilities/TwitchMembershipCapability":226,"./Capabilities/TwitchTagsCapability":229,"./Capabilities/TwitchTagsCapability/MessageTypes/ClearMsg":227,"./StandardCommands/TwitchPrivateMessage":232,"./Toolkit/UserTools":234,"@d-fischer/logger":16,"@d-fischer/shared-utils":36,"deprecate":52,"ircv3":191,"ircv3/lib/Message/MessageTypes/Commands/":150,"tslib":217,"twitch":322}],231:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A user in chat.
 */
var ChatUser = /** @class */ (function () {
    /** @private */
    function ChatUser(userName, userData) {
        this._userName = userName.toLowerCase();
        this._userData = userData ? new Map(userData) : new Map();
    }
    ChatUser.prototype._parseBadgesLike = function (badgesLikeStr) {
        if (!badgesLikeStr) {
            return new Map();
        }
        return new Map(badgesLikeStr.split(',').map(function (badge) { return badge.split('/', 2); }));
    };
    Object.defineProperty(ChatUser.prototype, "userName", {
        /**
         * The name of the user.
         */
        get: function () {
            return this._userName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatUser.prototype, "displayName", {
        /**
         * The display name of the user.
         */
        get: function () {
            return this._userData.get('display-name') || this._userName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatUser.prototype, "color", {
        /**
         * The color the user chose to display in chat.
         *
         * Returns null if the user didn't choose a color. In this case, you should generate your own color.
         */
        get: function () {
            return this._userData.get('color');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatUser.prototype, "badges", {
        /**
         * The badges of the user. Returned as a map that maps the badge category to the detail.
         */
        get: function () {
            var badgesStr = this._userData.get('badges');
            return this._parseBadgesLike(badgesStr);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatUser.prototype, "badgeInfo", {
        /**
         * The badge info of the user. Returned as a map that maps the badge category to the detail.
         */
        get: function () {
            var badgeInfoStr = this._userData.get('badge-info');
            return this._parseBadgesLike(badgeInfoStr);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatUser.prototype, "userId", {
        /**
         * The ID of the user.
         */
        get: function () {
            return this._userData.get('user-id') || undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatUser.prototype, "userType", {
        /**
         * The type of the user.
         * Possible values are undefined, 'mod', 'global_mod', 'admin' and 'staff'.
         */
        get: function () {
            return this._userData.get('user-type') || undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatUser.prototype, "isSubscriber", {
        /**
         * Whether the user is subscribed to the channel.
         */
        get: function () {
            return this.badges.has('subscriber') || this.isFounder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatUser.prototype, "isFounder", {
        /**
         * Whether the user is a Founder of the channel.
         */
        get: function () {
            return this.badges.has('founder');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatUser.prototype, "isMod", {
        /**
         * Whether the user is a moderator of the channel.
         */
        get: function () {
            return this.badges.has('moderator');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatUser.prototype, "isVip", {
        /**
         * Whether the user is a VIP in the channel.
         */
        get: function () {
            return this.badges.has('vip');
        },
        enumerable: true,
        configurable: true
    });
    return ChatUser;
}());
exports.default = ChatUser;

},{}],232:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Commands_1 = require("ircv3/lib/Message/MessageTypes/Commands/");
var ChatUser_1 = require("../ChatUser");
var EmoteTools_1 = require("../Toolkit/EmoteTools");
var TwitchPrivateMessage = /** @class */ (function (_super) {
    tslib_1.__extends(TwitchPrivateMessage, _super);
    function TwitchPrivateMessage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TwitchPrivateMessage.prototype, "userInfo", {
        get: function () {
            return new ChatUser_1.default(this._prefix.nick, this._tags);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchPrivateMessage.prototype, "channelId", {
        get: function () {
            if (!this._tags) {
                return null;
            }
            return this._tags.get('room-id') || null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchPrivateMessage.prototype, "isCheer", {
        get: function () {
            if (!this._tags) {
                return false;
            }
            return this._tags.has('bits');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchPrivateMessage.prototype, "totalBits", {
        get: function () {
            if (!this._tags) {
                return 0;
            }
            return Number(this._tags.get('bits'));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchPrivateMessage.prototype, "emoteOffsets", {
        get: function () {
            var _a;
            return EmoteTools_1.parseEmoteOffsets((_a = this._tags) === null || _a === void 0 ? void 0 : _a.get('emotes'));
        },
        enumerable: true,
        configurable: true
    });
    TwitchPrivateMessage.prototype.parseEmotes = function () {
        var messageText = this.params.message;
        var foundEmotes = EmoteTools_1.parseEmotePositions(messageText, this.emoteOffsets);
        return EmoteTools_1.fillTextPositions(messageText, foundEmotes);
    };
    TwitchPrivateMessage.prototype.parseEmotesAndBits = function (cheermotes) {
        var messageText = this.params.message;
        var foundCheermotes = cheermotes.parseMessage(messageText);
        var foundEmotesAndCheermotes = tslib_1.__spread(EmoteTools_1.parseEmotePositions(messageText, this.emoteOffsets), foundCheermotes.map(function (cheermote) { return ({
            type: 'cheer',
            position: cheermote.position,
            length: cheermote.length,
            name: cheermote.name,
            amount: cheermote.amount,
            displayInfo: cheermote.displayInfo
        }); }));
        foundEmotesAndCheermotes.sort(function (a, b) { return a.position - b.position; });
        return EmoteTools_1.fillTextPositions(messageText, foundEmotesAndCheermotes);
    };
    return TwitchPrivateMessage;
}(Commands_1.PrivateMessage));
exports.default = TwitchPrivateMessage;

},{"../ChatUser":231,"../Toolkit/EmoteTools":233,"ircv3/lib/Message/MessageTypes/Commands/":150,"tslib":217}],233:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
/** @private */
function parseEmoteOffsets(emotes) {
    if (!emotes) {
        return new Map();
    }
    return new Map(emotes.split('/').map(function (emote) {
        var _a = tslib_1.__read(emote.split(':', 2), 2), emoteId = _a[0], placements = _a[1];
        return [emoteId, placements.split(',')];
    }));
}
exports.parseEmoteOffsets = parseEmoteOffsets;
/** @private */
function parseEmotePositions(message, emoteOffsets) {
    return tslib_1.__spread(emoteOffsets.entries()).flatMap(function (_a) {
        var _b = tslib_1.__read(_a, 2), emote = _b[0], placements = _b[1];
        return placements.map(function (placement) {
            var _a = tslib_1.__read(placement.split('-'), 2), startStr = _a[0], endStr = _a[1];
            var start = +startStr;
            var end = +endStr;
            return {
                type: 'emote',
                position: start,
                length: end - start + 1,
                id: emote,
                name: shared_utils_1.utf8Substring(message, start, end + 1)
            };
        });
    })
        .sort(function (a, b) { return a.position - b.position; });
}
exports.parseEmotePositions = parseEmotePositions;
/** @private */
function fillTextPositions(message, otherPositions) {
    var e_1, _a;
    var messageLength = shared_utils_1.utf8Length(message);
    if (!otherPositions.length) {
        return [
            {
                type: 'text',
                position: 0,
                length: messageLength,
                text: message
            }
        ];
    }
    var result = [];
    var currentPosition = 0;
    try {
        for (var otherPositions_1 = tslib_1.__values(otherPositions), otherPositions_1_1 = otherPositions_1.next(); !otherPositions_1_1.done; otherPositions_1_1 = otherPositions_1.next()) {
            var token = otherPositions_1_1.value;
            if (token.position > currentPosition) {
                result.push({
                    type: 'text',
                    position: currentPosition,
                    length: token.position - currentPosition,
                    text: shared_utils_1.utf8Substring(message, currentPosition, token.position)
                });
            }
            result.push(token);
            currentPosition = token.position + token.length;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (otherPositions_1_1 && !otherPositions_1_1.done && (_a = otherPositions_1.return)) _a.call(otherPositions_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    if (currentPosition < messageLength) {
        result.push({
            type: 'text',
            position: currentPosition,
            length: messageLength - currentPosition,
            text: shared_utils_1.utf8Substring(message, currentPosition)
        });
    }
    return result;
}
exports.fillTextPositions = fillTextPositions;

},{"@d-fischer/shared-utils":36,"tslib":217}],234:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** @private */
function toUserName(channel) {
    // it's okay if this is already a user name, we only remove the first character if it's a pound
    return channel.replace(/^#/, '').toLowerCase();
}
exports.toUserName = toUserName;
/** @private */
function toChannelName(user) {
    // remove leading pound first - in case it already is a channel name
    return "#" + toUserName(user);
}
exports.toChannelName = toChannelName;

},{}],235:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable filenames/match-exported */
var ChatClient_1 = require("./ChatClient");
exports.default = ChatClient_1.default;
var TwitchPrivateMessage_1 = require("./StandardCommands/TwitchPrivateMessage");
exports.PrivateMessage = TwitchPrivateMessage_1.default;
var ChatUser_1 = require("./ChatUser");
exports.ChatUser = ChatUser_1.default;
var logger_1 = require("@d-fischer/logger");
exports.LogLevel = logger_1.LogLevel;
var UserTools_1 = require("./Toolkit/UserTools");
exports.toChannelName = UserTools_1.toChannelName;
exports.toUserName = UserTools_1.toUserName;

},{"./ChatClient":230,"./ChatUser":231,"./StandardCommands/TwitchPrivateMessage":232,"./Toolkit/UserTools":234,"@d-fischer/logger":16}],236:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents the data of an OAuth access token returned by Twitch.
 */
var AccessToken = /** @class */ (function () {
    /** @private */
    function AccessToken(_data, obtainmentDate) {
        this._data = _data;
        this._obtainmentDate = obtainmentDate || new Date();
    }
    Object.defineProperty(AccessToken.prototype, "accessToken", {
        /**
         * The access token which is necessary for every request to the Twitch API.
         */
        get: function () {
            return this._data.access_token;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccessToken.prototype, "refreshToken", {
        /**
         * The refresh token which is necessary to refresh the access token once it expires.
         */
        get: function () {
            return this._data.refresh_token;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccessToken.prototype, "expiryDate", {
        /**
         * The time when the access token will expire.
         *
         * May be `null`, in which case the token does not expire.
         * This can only be the case with very old Client IDs.
         */
        get: function () {
            if (!this._data.expires_in) {
                return null;
            }
            return new Date(this._obtainmentDate.getTime() + this._data.expires_in * 1000);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccessToken.prototype, "isExpired", {
        get: function () {
            if (!this._data.expires_in) {
                return false;
            }
            return Date.now() > this._obtainmentDate.getTime() + this._data.expires_in * 1000;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AccessToken.prototype, "scope", {
        /**
         * The scope the access token is valid for, i.e. what this token enables you to do.
         */
        get: function () {
            return this._data.scope || [];
        },
        enumerable: true,
        configurable: true
    });
    return AccessToken;
}());
exports.default = AccessToken;

},{}],237:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var cache_decorators_1 = require("@d-fischer/cache-decorators");
var UserTools_1 = require("../../Toolkit/UserTools");
var TwitchClient_1 = require("../../TwitchClient");
var BaseAPI_1 = require("../BaseAPI");
var ChatBadgeList_1 = require("./ChatBadgeList");
/**
 * The API methods that deal with badges.
 *
 * Can be accessed using `client.badges` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const cheermotes = await client.badges.getGlobalBadges();
 * ```
 */
var BadgesAPI = /** @class */ (function (_super) {
    tslib_1.__extends(BadgesAPI, _super);
    function BadgesAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves all globally applicable chat badges.
     */
    BadgesAPI.prototype.getGlobalBadges = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: 'https://badges.twitch.tv/v1/badges/global/display',
                            type: TwitchClient_1.TwitchAPICallType.Custom
                        })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new ChatBadgeList_1.default(data.badge_sets, this._client)];
                }
            });
        });
    };
    /**
     * Retrieves all applicable chat badges for a given channel.
     *
     * @param channel The channel to retrieve the chat badges for.
     * @param includeGlobal Whether to include global badges in the result list.
     */
    BadgesAPI.prototype.getChannelBadges = function (channel, includeGlobal) {
        if (includeGlobal === void 0) { includeGlobal = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data, channelBadges;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: "https://badges.twitch.tv/v1/badges/channels/" + UserTools_1.extractUserId(channel) + "/display",
                            type: TwitchClient_1.TwitchAPICallType.Custom
                        })];
                    case 1:
                        data = _a.sent();
                        channelBadges = new ChatBadgeList_1.default(data.badge_sets, this._client);
                        if (!includeGlobal) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.getGlobalBadges()];
                    case 2: return [2 /*return*/, (_a.sent())._merge(channelBadges)];
                    case 3: return [2 /*return*/, channelBadges];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], BadgesAPI.prototype, "getGlobalBadges", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], BadgesAPI.prototype, "getChannelBadges", null);
    BadgesAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], BadgesAPI);
    return BadgesAPI;
}(BaseAPI_1.default));
exports.default = BadgesAPI;

},{"../../Toolkit/UserTools":320,"../../TwitchClient":321,"../BaseAPI":241,"./ChatBadgeList":238,"@d-fischer/cache-decorators":6,"tslib":217}],238:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var ChatBadgeSet_1 = require("./ChatBadgeSet");
/**
 * A list of badge sets.
 */
var ChatBadgeList = /** @class */ (function () {
    /** @private */
    function ChatBadgeList(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChatBadgeList.prototype, "badgeSetNames", {
        /**
         * Names of all badge sets in the list.
         */
        get: function () {
            return Object.keys(this._data);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets a specific badge set by name.
     *
     * @param name The name of the badge set.
     */
    ChatBadgeList.prototype.getBadgeSet = function (name) {
        return new ChatBadgeSet_1.default(this._data[name], this._client);
    };
    /** @private */
    ChatBadgeList.prototype._merge = function (additionalData) {
        if (additionalData instanceof ChatBadgeList) {
            additionalData = additionalData._data;
        }
        return new ChatBadgeList(tslib_1.__assign(tslib_1.__assign({}, this._data), additionalData), this._client);
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatBadgeList.prototype, "_client", void 0);
    return ChatBadgeList;
}());
exports.default = ChatBadgeList;

},{"./ChatBadgeSet":239,"@d-fischer/shared-utils":36,"tslib":217}],239:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var ChatBadgeVersion_1 = require("./ChatBadgeVersion");
/**
 * A set of badges.
 */
var ChatBadgeSet = /** @class */ (function () {
    /** @private */
    function ChatBadgeSet(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChatBadgeSet.prototype, "versionNames", {
        /**
         * Names of all versions of the badge set.
         */
        get: function () {
            return Object.keys(this._data.versions);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets a specific version of a badge by name.
     *
     * @param name The name of the version.
     */
    ChatBadgeSet.prototype.getVersion = function (name) {
        return new ChatBadgeVersion_1.default(this._data.versions[name], this._client);
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatBadgeSet.prototype, "_client", void 0);
    return ChatBadgeSet;
}());
exports.default = ChatBadgeSet;

},{"./ChatBadgeVersion":240,"@d-fischer/shared-utils":36,"tslib":217}],240:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
/**
 * A version of a badge.
 */
var ChatBadgeVersion = /** @class */ (function () {
    /** @private */
    function ChatBadgeVersion(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChatBadgeVersion.prototype, "clickAction", {
        /**
         * The action to execute when the badge is clicked.
         */
        get: function () {
            return this._data.click_action;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatBadgeVersion.prototype, "clickUrl", {
        /**
         * The URL to visit when the badge is clicked.
         *
         * Only applies if clickAction === 'visit_url'.
         */
        get: function () {
            return this._data.click_url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatBadgeVersion.prototype, "description", {
        /**
         * The description of the badge.
         */
        get: function () {
            return this._data.description;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets an image URL for the given scale.
     *
     * @param scale The scale of the badge image.
     */
    ChatBadgeVersion.prototype.getImageUrl = function (scale) {
        return this._data["image_url_" + scale + "x"];
    };
    Object.defineProperty(ChatBadgeVersion.prototype, "title", {
        /**
         * The title of the badge.
         */
        get: function () {
            return this._data.title;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatBadgeVersion.prototype, "_client", void 0);
    return ChatBadgeVersion;
}());
exports.default = ChatBadgeVersion;

},{"@d-fischer/shared-utils":36,"tslib":217}],241:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
/** @private */
var BaseAPI = /** @class */ (function () {
    function BaseAPI(client) {
        this._client = client;
    }
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], BaseAPI.prototype, "_client", void 0);
    return BaseAPI;
}());
exports.default = BaseAPI;

},{"@d-fischer/shared-utils":36,"tslib":217}],242:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var BaseAPI_1 = require("../../BaseAPI");
var TwitchClient_1 = require("../../../TwitchClient");
var HelixBitsLeaderboard_1 = require("./HelixBitsLeaderboard");
/**
 * The Helix API methods that deal with bits.
 *
 * Can be accessed using `client.helix.bits` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const leaderboard = await client.helix.bits.getLeaderboard({ period: 'day' });
 * ```
 */
var HelixBitsAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixBitsAPI, _super);
    function HelixBitsAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets a bits leaderboard of your channel.
     *
     * @expandParams
     */
    HelixBitsAPI.prototype.getLeaderboard = function (params) {
        if (params === void 0) { params = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, count, _b, period, startDate, contextUserId, result;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = params.count, count = _a === void 0 ? 10 : _a, _b = params.period, period = _b === void 0 ? 'all' : _b, startDate = params.startDate, contextUserId = params.contextUserId;
                        return [4 /*yield*/, this._client.callAPI({
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                url: 'bits/leaderboard',
                                scope: 'bits:read',
                                query: {
                                    count: count.toString(),
                                    period: period,
                                    started_at: startDate ? startDate.toISOString() : undefined,
                                    user_id: contextUserId
                                }
                            })];
                    case 1:
                        result = _c.sent();
                        return [2 /*return*/, new HelixBitsLeaderboard_1.default(result, this._client)];
                }
            });
        });
    };
    return HelixBitsAPI;
}(BaseAPI_1.default));
exports.default = HelixBitsAPI;

},{"../../../TwitchClient":321,"../../BaseAPI":241,"./HelixBitsLeaderboard":243,"tslib":217}],243:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var cache_decorators_1 = require("@d-fischer/cache-decorators");
var shared_utils_1 = require("@d-fischer/shared-utils");
var HelixBitsLeaderboardEntry_1 = require("./HelixBitsLeaderboardEntry");
/**
 * A leaderboard where the users who used the most bits to a broadcaster are listed.
 */
var HelixBitsLeaderboard = /** @class */ (function () {
    /** @private */
    function HelixBitsLeaderboard(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixBitsLeaderboard.prototype, "entries", {
        /**
         * The entries of the leaderboard.
         */
        get: function () {
            var _this = this;
            return this._data.data.map(function (entry) { return new HelixBitsLeaderboardEntry_1.default(entry, _this._client); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBitsLeaderboard.prototype, "totalCount", {
        /**
         * The total amount of people on the requested leaderboard.
         */
        get: function () {
            return this._data.total;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixBitsLeaderboard.prototype, "_client", void 0);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixBitsLeaderboard.prototype, "entries", null);
    HelixBitsLeaderboard = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], HelixBitsLeaderboard);
    return HelixBitsLeaderboard;
}());
exports.default = HelixBitsLeaderboard;

},{"./HelixBitsLeaderboardEntry":244,"@d-fischer/cache-decorators":6,"@d-fischer/shared-utils":36,"tslib":217}],244:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
/**
 * A Bits leaderboard entry.
 */
var HelixBitsLeaderboardEntry = /** @class */ (function () {
    /** @private */
    function HelixBitsLeaderboardEntry(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixBitsLeaderboardEntry.prototype, "userId", {
        /**
         * The ID of the user on the leaderboard.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBitsLeaderboardEntry.prototype, "userDisplayName", {
        /**
         * The display name of the user on the leaderboard.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBitsLeaderboardEntry.prototype, "rank", {
        /**
         * The position of the user on the leaderboard.
         */
        get: function () {
            return this._data.rank;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBitsLeaderboardEntry.prototype, "amount", {
        /**
         * The amount of bits used in the given period of time.
         */
        get: function () {
            return this._data.score;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the user that's on this place on the leaderboard.
     */
    HelixBitsLeaderboardEntry.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.user_id)];
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixBitsLeaderboardEntry.prototype, "_client", void 0);
    return HelixBitsLeaderboardEntry;
}());
exports.default = HelixBitsLeaderboardEntry;

},{"@d-fischer/shared-utils":36,"tslib":217}],245:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var HelixClip = /** @class */ (function () {
    /** @private */
    function HelixClip(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixClip.prototype, "id", {
        /**
         * The clip ID.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "url", {
        /**
         * The URL of the clip.
         */
        get: function () {
            return this._data.url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "embedUrl", {
        /**
         * The embed URL of the clip.
         */
        get: function () {
            return this._data.embed_url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "broadcasterId", {
        /**
         * The user ID of the broadcaster of the stream where the clip was created.
         */
        get: function () {
            return this._data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "broadcasterDisplayName", {
        /**
         * The display name of the broadcaster of the stream where the clip was created.
         */
        get: function () {
            return this._data.broadcaster_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the broadcaster of the stream where the clip was created.
     */
    HelixClip.prototype.getBroadcaster = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.broadcaster_id)];
            });
        });
    };
    Object.defineProperty(HelixClip.prototype, "creatorId", {
        /**
         * The user ID of the creator of the clip.
         */
        get: function () {
            return this._data.creator_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "creatorDisplayName", {
        /**
         * The display name of the creator of the clip.
         */
        get: function () {
            return this._data.creator_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the creator of the clip.
     */
    HelixClip.prototype.getCreator = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.creator_id)];
            });
        });
    };
    Object.defineProperty(HelixClip.prototype, "videoId", {
        /**
         * The ID of the video the clip is taken from.
         */
        get: function () {
            return this._data.video_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the video the clip is taken from.
     */
    HelixClip.prototype.getVideo = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.videos.getVideoById(this._data.video_id)];
            });
        });
    };
    Object.defineProperty(HelixClip.prototype, "gameId", {
        /**
         * The ID of the game that was being played when the clip was created.
         */
        get: function () {
            return this._data.game_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the game that was being played when the clip was created.
     */
    HelixClip.prototype.getGame = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.games.getGameById(this._data.game_id)];
            });
        });
    };
    Object.defineProperty(HelixClip.prototype, "language", {
        /**
         * The language of the stream where the clip was created.
         */
        get: function () {
            return this._data.language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "title", {
        /**
         * The title of the clip.
         */
        get: function () {
            return this._data.title;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "views", {
        /**
         * The number of views of the clip.
         */
        get: function () {
            return this._data.view_count;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "creationDate", {
        /**
         * The date when the clip was created.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixClip.prototype, "thumbnailUrl", {
        /**
         * The URL of the thumbnail of the clip.
         */
        get: function () {
            return this._data.thumbnail_url;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixClip.prototype, "_client", void 0);
    return HelixClip;
}());
exports.default = HelixClip;

},{"@d-fischer/shared-utils":36,"tslib":217}],246:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var TwitchClient_1 = require("../../../TwitchClient");
var BaseAPI_1 = require("../../BaseAPI");
var HelixPaginatedRequest_1 = require("../HelixPaginatedRequest");
var HelixPaginatedResult_1 = require("../HelixPaginatedResult");
var HelixClip_1 = require("./HelixClip");
/**
 * The Helix API methods that deal with clips.
 *
 * Can be accessed using `client.helix.clips` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const clipId = await client.helix.clips.createClip({ channelId: '125328655' });
 * ```
 */
var HelixClipAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixClipAPI, _super);
    function HelixClipAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves the latest clips for the specified broadcaster.
     *
     * @param userId The broadcaster's user ID.
     * @param filter
     *
     * @expandParams
     */
    HelixClipAPI.prototype.getClipsForBroadcaster = function (userId, filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getClips(tslib_1.__assign(tslib_1.__assign({}, filter), { filterType: 'broadcaster_id', ids: userId }))];
            });
        });
    };
    /**
     * Creates a paginator for the latest clips for the specified broadcaster.
     *
     * @param userId The broadcaster's user ID.
     * @param filter
     *
     * @expandParams
     */
    HelixClipAPI.prototype.getClipsForBroadcasterPaginated = function (userId, filter) {
        if (filter === void 0) { filter = {}; }
        return this._getClipsPaginated(tslib_1.__assign(tslib_1.__assign({}, filter), { filterType: 'broadcaster_id', ids: userId }));
    };
    /**
     * Retrieves the latest clips for the specified game.
     *
     * @param gameId The game ID.
     * @param filter
     *
     * @expandParams
     */
    HelixClipAPI.prototype.getClipsForGame = function (gameId, filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getClips(tslib_1.__assign(tslib_1.__assign({}, filter), { filterType: 'game_id', ids: gameId }))];
            });
        });
    };
    /**
     * Creates a paginator for the latest clips for the specified game.
     *
     * @param gameId The game ID.
     * @param filter
     *
     * @expandParams
     */
    HelixClipAPI.prototype.getClipsForGamePaginated = function (gameId, filter) {
        if (filter === void 0) { filter = {}; }
        return this._getClipsPaginated(tslib_1.__assign(tslib_1.__assign({}, filter), { filterType: 'game_id', ids: gameId }));
    };
    /**
     * Retrieves the clips identified by the given IDs.
     *
     * @param ids The clip IDs.
     */
    HelixClipAPI.prototype.getClipsByIds = function (ids) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getClips({
                            filterType: 'id',
                            ids: ids
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data];
                }
            });
        });
    };
    /**
     * Retrieves the clip identified by the given ID.
     *
     * @param id The clip ID.
     */
    HelixClipAPI.prototype.getClipById = function (id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var clips;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getClipsByIds([id])];
                    case 1:
                        clips = _a.sent();
                        return [2 /*return*/, clips.length ? clips[0] : null];
                }
            });
        });
    };
    /**
     * Creates a clip of a running stream.
     *
     * Returns the ID of the clip.
     *
     * @expandParams
     */
    HelixClipAPI.prototype.createClip = function (params) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, _a, createAfterDelay, result;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        channelId = params.channelId, _a = params.createAfterDelay, createAfterDelay = _a === void 0 ? false : _a;
                        return [4 /*yield*/, this._client.callAPI({
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                url: 'clips',
                                method: 'POST',
                                scope: 'clips:edit',
                                query: {
                                    broadcaster_id: channelId,
                                    has_delay: createAfterDelay.toString()
                                }
                            })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, result.data[0].id];
                }
            });
        });
    };
    HelixClipAPI.prototype._getClips = function (params) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var filterType, ids, startDate, endDate, _a, limit, result;
            var _b;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        filterType = params.filterType, ids = params.ids, startDate = params.startDate, endDate = params.endDate, _a = params.limit, limit = _a === void 0 ? 20 : _a;
                        return [4 /*yield*/, this._client.callAPI({
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                url: 'clips',
                                query: (_b = {},
                                    _b[filterType] = ids,
                                    _b.started_at = startDate,
                                    _b.ended_at = endDate,
                                    _b.first = limit.toString(),
                                    _b)
                            })];
                    case 1:
                        result = _c.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixClip_1.default, this._client)];
                }
            });
        });
    };
    HelixClipAPI.prototype._getClipsPaginated = function (params) {
        var _a;
        var _this = this;
        var filterType = params.filterType, ids = params.ids, startDate = params.startDate, endDate = params.endDate;
        return new HelixPaginatedRequest_1.default({
            url: 'clips',
            query: (_a = {},
                _a[filterType] = ids,
                _a.started_at = startDate,
                _a.ended_at = endDate,
                _a)
        }, this._client, function (data) { return new HelixClip_1.default(data, _this._client); });
    };
    return HelixClipAPI;
}(BaseAPI_1.default));
exports.default = HelixClipAPI;

},{"../../../TwitchClient":321,"../../BaseAPI":241,"../HelixPaginatedRequest":252,"../HelixPaginatedResult":254,"./HelixClip":245,"tslib":217}],247:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
/**
 * A bits transaction made inside an extension.
 */
var HelixExtensionTransaction = /** @class */ (function () {
    /** @private */
    function HelixExtensionTransaction(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixExtensionTransaction.prototype, "id", {
        /**
         * The ID of the transaction.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "transactionDate", {
        /**
         * The time when the transaction was made.
         */
        get: function () {
            return new Date(this._data.timestamp);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "broadcasterId", {
        /**
         * The ID of the broadcaster that runs the extension on their channel.
         */
        get: function () {
            return this._data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "broadcasterDisplayName", {
        /**
         * The display name of the broadcaster that runs the extension on their channel.
         */
        get: function () {
            return this._data.broadcaster_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the broadcaster that runs the extension on their channel.
     */
    HelixExtensionTransaction.prototype.getBroadcaster = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.broadcaster_id)];
            });
        });
    };
    Object.defineProperty(HelixExtensionTransaction.prototype, "userId", {
        /**
         * The ID of the user that made the transaction.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "userDisplayName", {
        /**
         * The display name of the user that made the transaction.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the user that made the transaction.
     */
    HelixExtensionTransaction.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.user_id)];
            });
        });
    };
    Object.defineProperty(HelixExtensionTransaction.prototype, "productType", {
        /**
         * The product type. Currently always BITS_IN_EXTENSION.
         */
        get: function () {
            return this._data.product_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "productSKU", {
        /**
         * The product SKU.
         */
        get: function () {
            return this._data.product_data.sku;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "productCost", {
        /**
         * The cost of the product, in bits.
         */
        get: function () {
            return this._data.product_data.cost.amount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "productDisplayName", {
        /**
         * The display name of the product.
         */
        get: function () {
            return this._data.product_data.displayName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixExtensionTransaction.prototype, "productInDevelopment", {
        /**
         * Whether the product is in development.
         */
        get: function () {
            return this._data.product_data.inDevelopment;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixExtensionTransaction.prototype, "_client", void 0);
    return HelixExtensionTransaction;
}());
exports.default = HelixExtensionTransaction;

},{"@d-fischer/shared-utils":36,"tslib":217}],248:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var TwitchClient_1 = require("../../../TwitchClient");
var BaseAPI_1 = require("../../BaseAPI");
var HelixPaginatedRequest_1 = require("../HelixPaginatedRequest");
var HelixPaginatedResult_1 = require("../HelixPaginatedResult");
var HelixPagination_1 = require("../HelixPagination");
var HelixExtensionTransaction_1 = require("./HelixExtensionTransaction");
/**
 * The Helix API methods that deal with extensions.
 *
 * Can be accessed using `client.helix.extensions` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const transactions = await client.helix.extionsions.getExtensionTransactions('abcd');
 * ```
 */
var HelixExtensionsAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixExtensionsAPI, _super);
    function HelixExtensionsAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of transactions for the given extension.
     *
     * @param extensionId The ID of the extension to retrieve transactions for.
     * @param filter Additional filters.
     */
    HelixExtensionsAPI.prototype.getExtensionTransactions = function (extensionId, filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'extensions/transactions',
                            query: tslib_1.__assign({ extension_id: extensionId, id: filter.transactionIds }, HelixPagination_1.makePaginationQuery(filter))
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixExtensionTransaction_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for transactions for the given extension.
     *
     * @param extensionId The ID of the extension to retrieve transactions for.
     * @param filter Additional filters.
     */
    HelixExtensionsAPI.prototype.getExtensionTransactionsPaginated = function (extensionId, filter) {
        var _this = this;
        if (filter === void 0) { filter = {}; }
        return new HelixPaginatedRequest_1.default({
            url: 'extensions/transactions',
            query: {
                extension_id: extensionId,
                id: filter.transactionIds
            }
        }, this._client, function (data) { return new HelixExtensionTransaction_1.default(data, _this._client); });
    };
    return HelixExtensionsAPI;
}(BaseAPI_1.default));
exports.default = HelixExtensionsAPI;

},{"../../../TwitchClient":321,"../../BaseAPI":241,"../HelixPaginatedRequest":252,"../HelixPaginatedResult":254,"../HelixPagination":255,"./HelixExtensionTransaction":247,"tslib":217}],249:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
/**
 * A game as displayed on Twitch.
 */
var HelixGame = /** @class */ (function () {
    /** @private */
    function HelixGame(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixGame.prototype, "id", {
        /**
         * The ID of the game.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixGame.prototype, "name", {
        /**
         * The name of the game.
         */
        get: function () {
            return this._data.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixGame.prototype, "boxArtUrl", {
        /**
         * The URL of the box art of the game.
         */
        get: function () {
            return this._data.box_art_url;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixGame.prototype, "_client", void 0);
    return HelixGame;
}());
exports.default = HelixGame;

},{"@d-fischer/shared-utils":36,"tslib":217}],250:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var TwitchClient_1 = require("../../../TwitchClient");
var BaseAPI_1 = require("../../BaseAPI");
var HelixPaginatedRequest_1 = require("../HelixPaginatedRequest");
var HelixPaginatedResult_1 = require("../HelixPaginatedResult");
var HelixPagination_1 = require("../HelixPagination");
var HelixGame_1 = require("./HelixGame");
/**
 * The Helix API methods that deal with games.
 *
 * Can be accessed using `client.helix.games` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const game = await client.helix.games.getGameByName('Hearthstone');
 * ```
 */
var HelixGameAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixGameAPI, _super);
    function HelixGameAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves the game data for the given list of game IDs.
     *
     * @param ids The game IDs you want to look up.
     */
    HelixGameAPI.prototype.getGamesByIds = function (ids) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getGames('id', ids)];
            });
        });
    };
    /**
     * Retrieves the game data for the given list of game names.
     *
     * @param names The game names you want to look up.
     */
    HelixGameAPI.prototype.getGamesByNames = function (names) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getGames('name', names)];
            });
        });
    };
    /**
     * Retrieves the game data for the given game ID.
     *
     * @param id The game ID you want to look up.
     */
    HelixGameAPI.prototype.getGameById = function (id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var games;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getGames('id', id)];
                    case 1:
                        games = _a.sent();
                        return [2 /*return*/, games.length ? games[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves the game data for the given game name.
     *
     * @param name The game name you want to look up.
     */
    HelixGameAPI.prototype.getGameByName = function (name) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var games;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getGames('name', name)];
                    case 1:
                        games = _a.sent();
                        return [2 /*return*/, games.length ? games[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves a list of the most viewed games at the moment.
     *
     * @param pagination Pagination info.
     */
    HelixGameAPI.prototype.getTopGames = function (pagination) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'games/top',
                            query: HelixPagination_1.makePaginationQuery(pagination)
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixGame_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for the most viewed games at the moment.
     */
    HelixGameAPI.prototype.getTopGamesPaginated = function () {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'games/top'
        }, this._client, function (data) { return new HelixGame_1.default(data, _this._client); });
    };
    HelixGameAPI.prototype._getGames = function (filterType, filterValues) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            var _a;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'games',
                            query: (_a = {},
                                _a[filterType] = filterValues,
                                _a)
                        })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, result.data.map(function (entry) { return new HelixGame_1.default(entry, _this._client); })];
                }
            });
        });
    };
    return HelixGameAPI;
}(BaseAPI_1.default));
exports.default = HelixGameAPI;

},{"../../../TwitchClient":321,"../../BaseAPI":241,"../HelixPaginatedRequest":252,"../HelixPaginatedResult":254,"../HelixPagination":255,"./HelixGame":249,"tslib":217}],251:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var cache_decorators_1 = require("@d-fischer/cache-decorators");
var BaseAPI_1 = require("../BaseAPI");
var HelixBitsAPI_1 = require("./Bits/HelixBitsAPI");
var HelixClipAPI_1 = require("./Clip/HelixClipAPI");
var HelixExtensionsAPI_1 = require("./Extensions/HelixExtensionsAPI");
var HelixGameAPI_1 = require("./Game/HelixGameAPI");
var HelixModerationAPI_1 = require("./Moderation/HelixModerationAPI");
var HelixStreamAPI_1 = require("./Stream/HelixStreamAPI");
var HelixSubscriptionAPI_1 = require("./Subscriptions/HelixSubscriptionAPI");
var HelixUserAPI_1 = require("./User/HelixUserAPI");
var HelixVideoAPI_1 = require("./Video/HelixVideoAPI");
var HelixWebHooksAPI_1 = require("./WebHooks/HelixWebHooksAPI");
/**
 * Groups all API calls available in Helix a.k.a. the "New Twitch API".
 *
 * Can be accessed using {@TwitchClient#helix}.
 */
var HelixAPIGroup = /** @class */ (function (_super) {
    tslib_1.__extends(HelixAPIGroup, _super);
    function HelixAPIGroup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(HelixAPIGroup.prototype, "bits", {
        /**
         * The Helix bits API methods.
         */
        get: function () {
            return new HelixBitsAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "clips", {
        /**
         * The Helix clips API methods.
         */
        get: function () {
            return new HelixClipAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "extensions", {
        /**
         * The Helix extensions API methods.
         */
        get: function () {
            return new HelixExtensionsAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "games", {
        /**
         * The Helix game API methods.
         */
        get: function () {
            return new HelixGameAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "moderation", {
        /**
         * The Helix moderation API methods.
         */
        get: function () {
            return new HelixModerationAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "streams", {
        /**
         * The Helix stream API methods.
         */
        get: function () {
            return new HelixStreamAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "subscriptions", {
        /**
         * The Helix subscription API methods.
         */
        get: function () {
            return new HelixSubscriptionAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "users", {
        /**
         * The Helix user API methods.
         */
        get: function () {
            return new HelixUserAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "webHooks", {
        /**
         * The Helix WebHook API methods.
         */
        get: function () {
            return new HelixWebHooksAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixAPIGroup.prototype, "videos", {
        /**
         * The Helix video API methods.
         */
        get: function () {
            return new HelixVideoAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "bits", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "clips", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "extensions", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "games", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "moderation", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "streams", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "subscriptions", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "users", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "webHooks", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixAPIGroup.prototype, "videos", null);
    HelixAPIGroup = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], HelixAPIGroup);
    return HelixAPIGroup;
}(BaseAPI_1.default));
exports.default = HelixAPIGroup;

},{"../BaseAPI":241,"./Bits/HelixBitsAPI":242,"./Clip/HelixClipAPI":246,"./Extensions/HelixExtensionsAPI":248,"./Game/HelixGameAPI":250,"./Moderation/HelixModerationAPI":259,"./Stream/HelixStreamAPI":263,"./Subscriptions/HelixSubscriptionAPI":267,"./User/HelixUserAPI":272,"./Video/HelixVideoAPI":274,"./WebHooks/HelixWebHooksAPI":276,"@d-fischer/cache-decorators":6,"tslib":217}],252:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var TwitchClient_1 = require("../../TwitchClient");
if (!Object.prototype.hasOwnProperty.call(Symbol, 'asyncIterator')) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    Symbol.asyncIterator = Symbol.asyncIterator || Symbol.for('Symbol.asyncIterator');
}
/**
 * Represents a request to the new Twitch API (Helix) that utilizes a cursor to paginate through its results.
 *
 * Aside from the methods described below, you can also utilize the async iterator using `for await .. of`:
 *
 * ```ts
 * const result = client.helix.videos.getVideosByUser('125328655');
 * for await (const video of result) {
 *     console.log(video.title);
 * }
 * ```
 */
var HelixPaginatedRequest = /** @class */ (function () {
    /** @private */
    function HelixPaginatedRequest(_callOptions, client, _mapper) {
        this._callOptions = _callOptions;
        this._mapper = _mapper;
        /** @private */
        this._isFinished = false;
        this._client = client;
    }
    Object.defineProperty(HelixPaginatedRequest.prototype, "current", {
        /**
         * The last retrieved page of data associated to the requested resource.
         *
         * Only works with {@HelixPaginatedRequest#getNext} and not with any other methods of data retrieval.
         */
        get: function () {
            return this._currentData ? this._currentData.data : undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves and returns the next available page of data associated to the requested resource, or an empty array if there are no more available pages.
     */
    HelixPaginatedRequest.prototype.getNext = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._isFinished) {
                            return [2 /*return*/, []];
                        }
                        return [4 /*yield*/, this._fetchData()];
                    case 1:
                        result = _a.sent();
                        if (!result.data.length) {
                            this._isFinished = true;
                            return [2 /*return*/, []];
                        }
                        return [2 /*return*/, this._processResult(result)];
                }
            });
        });
    };
    /**
     * Retrieves and returns all data associated to the requested resource.
     *
     * Be aware that this makes multiple calls to the Twitch API. Due to this, you might be more suspectible to rate limits.
     *
     * Also be aware that this resets the internal cursor, so avoid using this and {@HelixPaginatedRequest#getNext} together.
     */
    HelixPaginatedRequest.prototype.getAll = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.reset();
                        result = [];
                        _a.label = 1;
                    case 1: return [4 /*yield*/, this.getNext()];
                    case 2:
                        data = _a.sent();
                        if (!data.length) {
                            return [3 /*break*/, 4];
                        }
                        result.push.apply(result, tslib_1.__spread(data));
                        _a.label = 3;
                    case 3:
                        if (this._currentCursor) return [3 /*break*/, 1];
                        _a.label = 4;
                    case 4:
                        this.reset();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    Object.defineProperty(HelixPaginatedRequest.prototype, "currentCursor", {
        /**
         * Retrieves the current cursor.
         *
         * Only useful if you want to make manual requests to the API.
         */
        get: function () {
            return this._currentCursor;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resets the internal cursor.
     *
     * This will make {@HelixPaginatedRequest#getNext} start from the first page again.
     */
    HelixPaginatedRequest.prototype.reset = function () {
        this._currentCursor = undefined;
        this._isFinished = false;
        this._currentData = undefined;
    };
    HelixPaginatedRequest.prototype[Symbol.asyncIterator] = function () {
        return tslib_1.__asyncGenerator(this, arguments, function _a() {
            var data;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.reset();
                        _b.label = 1;
                    case 1:
                        if (!true) return [3 /*break*/, 5];
                        return [4 /*yield*/, tslib_1.__await(this.getNext())];
                    case 2:
                        data = _b.sent();
                        if (!data.length) {
                            return [3 /*break*/, 5];
                        }
                        return [5 /*yield**/, tslib_1.__values(tslib_1.__asyncDelegator(tslib_1.__asyncValues(data[Symbol.iterator]())))];
                    case 3: return [4 /*yield*/, tslib_1.__await.apply(void 0, [_b.sent()])];
                    case 4:
                        _b.sent();
                        return [3 /*break*/, 1];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /** @private */
    HelixPaginatedRequest.prototype._fetchData = function (additionalOptions) {
        if (additionalOptions === void 0) { additionalOptions = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.callAPI(tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({ type: TwitchClient_1.TwitchAPICallType.Helix }, this._callOptions), additionalOptions), { query: tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, this._callOptions.query), { after: this._currentCursor, first: '100' }), additionalOptions.query) }))];
            });
        });
    };
    /** @private */
    HelixPaginatedRequest.prototype._processResult = function (result) {
        var _this = this;
        this._currentCursor = result.pagination ? result.pagination.cursor : undefined;
        if (this._currentCursor === undefined) {
            this._isFinished = true;
        }
        this._currentData = result;
        return result.data.reduce(function (acc, elem) {
            var mapped = _this._mapper(elem);
            return Array.isArray(mapped) ? tslib_1.__spread(acc, mapped) : tslib_1.__spread(acc, [mapped]);
        }, []);
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixPaginatedRequest.prototype, "_client", void 0);
    return HelixPaginatedRequest;
}());
exports.default = HelixPaginatedRequest;

},{"../../TwitchClient":321,"@d-fischer/shared-utils":36,"tslib":217}],253:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var HelixPaginatedRequest_1 = require("./HelixPaginatedRequest");
/**
 * A special case of {@HelixPaginatedRequest} with support for fetching the total number of entities, whenever an endpoint supports it.
 */
var HelixPaginatedRequestWithTotal = /** @class */ (function (_super) {
    tslib_1.__extends(HelixPaginatedRequestWithTotal, _super);
    function HelixPaginatedRequestWithTotal() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves and returns the total number of entities existing in the queried result set.
     */
    HelixPaginatedRequestWithTotal.prototype.getTotalCount = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this._currentData;
                        if (_a) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._fetchData({ query: { after: undefined } })];
                    case 1:
                        _a = (_b.sent());
                        _b.label = 2;
                    case 2:
                        data = _a;
                        return [2 /*return*/, data.total];
                }
            });
        });
    };
    return HelixPaginatedRequestWithTotal;
}(HelixPaginatedRequest_1.default));
exports.default = HelixPaginatedRequestWithTotal;

},{"./HelixPaginatedRequest":252,"tslib":217}],254:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** @private */
function createPaginatedResult(response, type, client) {
    var _a;
    return {
        data: response.data.map(function (data) { return new type(data, client); }),
        cursor: (_a = response.pagination) === null || _a === void 0 ? void 0 : _a.cursor
    };
}
exports.createPaginatedResult = createPaginatedResult;
/** @private */
function createPaginatedResultWithTotal(response, type, client) {
    return {
        data: response.data.map(function (data) { return new type(data, client); }),
        cursor: response.pagination.cursor,
        total: response.total
    };
}
exports.createPaginatedResultWithTotal = createPaginatedResultWithTotal;

},{}],255:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** @private */
function makePaginationQuery(_a) {
    var _b = _a === void 0 ? {} : _a, after = _b.after, before = _b.before, limit = _b.limit;
    return {
        after: after,
        before: before,
        first: limit
    };
}
exports.makePaginationQuery = makePaginationQuery;

},{}],256:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var rate_limiter_1 = require("@d-fischer/rate-limiter");
var TwitchClient_1 = require("../../TwitchClient");
var HelixRateLimiter = /** @class */ (function (_super) {
    tslib_1.__extends(HelixRateLimiter, _super);
    function HelixRateLimiter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HelixRateLimiter.prototype.doRequest = function (_a) {
        var options = _a.options, clientId = _a.clientId, accessToken = _a.accessToken;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_b) {
                return [2 /*return*/, TwitchClient_1.default._callAPIRaw(options, clientId, accessToken)];
            });
        });
    };
    HelixRateLimiter.prototype.needsToRetryAfter = function (res) {
        if (res.status === 429) {
            return +res.headers.get('ratelimit-reset') * 1000 - Date.now();
        }
        return null;
    };
    HelixRateLimiter.prototype.getParametersFromResponse = function (res) {
        var headers = res.headers;
        return {
            limit: +headers.get('ratelimit-limit'),
            remaining: +headers.get('ratelimit-remaining'),
            resetsAt: +headers.get('ratelimit-reset') * 1000
        };
    };
    return HelixRateLimiter;
}(rate_limiter_1.ResponseBasedRateLimiter));
exports.default = HelixRateLimiter;

},{"../../TwitchClient":321,"@d-fischer/rate-limiter":20,"tslib":217}],257:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
/**
 * Information about the ban of a user.
 */
var HelixBan = /** @class */ (function () {
    /** @private */
    function HelixBan(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixBan.prototype, "userId", {
        /**
         * The ID of the user.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the user.
     */
    HelixBan.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.user_id)];
            });
        });
    };
    Object.defineProperty(HelixBan.prototype, "userName", {
        /**
         * The name of the user.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBan.prototype, "expiryDate", {
        /**
         * The date when the ban will expire; null for permanent bans.
         */
        get: function () {
            return this._data.expires_at ? new Date(this._data.expires_at) : null;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixBan.prototype, "_client", void 0);
    return HelixBan;
}());
exports.default = HelixBan;

},{"@d-fischer/shared-utils":36,"tslib":217}],258:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var HelixBan_1 = require("./HelixBan");
/**
 * The different types a ban event can have.
 */
var HelixBanEventType;
(function (HelixBanEventType) {
    /**
     * Sent when a user gets banned.
     */
    HelixBanEventType["Ban"] = "moderation.user.ban";
    /**
     * Sent when a user gets unbanned.
     */
    HelixBanEventType["Unban"] = "moderation.user.unban";
})(HelixBanEventType = exports.HelixBanEventType || (exports.HelixBanEventType = {}));
/**
 * An event that indicates the change of a ban status, i.e. banning or unbanning a user.
 */
var HelixBanEvent = /** @class */ (function (_super) {
    tslib_1.__extends(HelixBanEvent, _super);
    /** @private */
    function HelixBanEvent(_eventData, client) {
        var _this = _super.call(this, _eventData.event_data, client) || this;
        _this._eventData = _eventData;
        return _this;
    }
    Object.defineProperty(HelixBanEvent.prototype, "eventId", {
        /**
         * The unique ID of the ban event.
         */
        get: function () {
            return this._eventData.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBanEvent.prototype, "eventType", {
        /**
         * The type of the ban event.
         */
        get: function () {
            return this._eventData.event_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBanEvent.prototype, "eventDate", {
        /**
         * The date of the ban event.
         */
        get: function () {
            return new Date(this._eventData.event_timestamp);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBanEvent.prototype, "eventVersion", {
        /**
         * The version of the ban event.
         */
        get: function () {
            return this._eventData.version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixBanEvent.prototype, "broadcasterId", {
        /**
         * The id of the broadcaster from whose chat the user was banned/unbanned.
         */
        get: function () {
            return this._eventData.event_data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the broadcaster.
     */
    HelixBanEvent.prototype.getBroadcaster = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._eventData.event_data.broadcaster_id)];
            });
        });
    };
    Object.defineProperty(HelixBanEvent.prototype, "broadcasterName", {
        /**
         * The name of the broadcaster from whose chat the user was banned/unbanned.
         */
        get: function () {
            return this._eventData.event_data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    return HelixBanEvent;
}(HelixBan_1.default));
exports.default = HelixBanEvent;

},{"./HelixBan":257,"tslib":217}],259:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var UserTools_1 = require("../../../Toolkit/UserTools");
var TwitchClient_1 = require("../../../TwitchClient");
var BaseAPI_1 = require("../../BaseAPI");
var HelixPaginatedRequest_1 = require("../HelixPaginatedRequest");
var HelixPaginatedResult_1 = require("../HelixPaginatedResult");
var HelixPagination_1 = require("../HelixPagination");
var HelixBan_1 = require("./HelixBan");
var HelixBanEvent_1 = require("./HelixBanEvent");
var HelixModerator_1 = require("./HelixModerator");
var HelixModeratorEvent_1 = require("./HelixModeratorEvent");
/**
 * The Helix API methods that deal with moderation.
 *
 * Can be accessed using `client.helix.moderation` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const game = await client.helix.moderation.getBannedUsers('61369223');
 * ```
 */
var HelixModerationAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixModerationAPI, _super);
    function HelixModerationAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of banned users in a given channel.
     *
     * @param channel The channel to retrieve the banned users from.
     * @param filter Additional filters for the result set.
     */
    HelixModerationAPI.prototype.getBannedUsers = function (channel, filter) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'moderation/banned',
                            scope: 'moderation:read',
                            query: tslib_1.__assign({ broadcaster_id: UserTools_1.extractUserId(channel), user_id: (_a = filter) === null || _a === void 0 ? void 0 : _a.userId }, HelixPagination_1.makePaginationQuery(filter))
                        })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixBan_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for banned users in a given channel.
     *
     * @param channel The channel to retrieve the banned users from.
     */
    HelixModerationAPI.prototype.getBannedUsersPaginated = function (channel) {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'moderation/banned',
            scope: 'moderation:read',
            query: {
                broadcaster_id: UserTools_1.extractUserId(channel)
            }
        }, this._client, function (data) { return new HelixBan_1.default(data, _this._client); });
    };
    /**
     * Checks whether a given user is banned in a given channel.
     *
     * @param channel The channel to check for a ban of the given user.
     * @param user The user to check for a ban in the given channel.
     */
    HelixModerationAPI.prototype.checkUserBan = function (channel, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        return [4 /*yield*/, this.getBannedUsers(channel, { userId: userId })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data.some(function (ban) { return ban.userId === userId; })];
                }
            });
        });
    };
    /**
     * Retrieves a list of ban events for a given channel.
     *
     * @param channel The channel to retrieve the ban events from.
     * @param filter Additional filters for the result set.
     */
    HelixModerationAPI.prototype.getBanEvents = function (channel, filter) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            var _this = this;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'moderation/banned/events',
                            scope: 'moderation:read',
                            query: tslib_1.__assign({ broadcaster_id: UserTools_1.extractUserId(channel), user_id: (_a = filter) === null || _a === void 0 ? void 0 : _a.userId }, HelixPagination_1.makePaginationQuery(filter))
                        })];
                    case 1:
                        result = _c.sent();
                        return [2 /*return*/, {
                                data: result.data.map(function (data) { return new HelixBanEvent_1.default(data, _this._client); }),
                                cursor: (_b = result.pagination) === null || _b === void 0 ? void 0 : _b.cursor
                            }];
                }
            });
        });
    };
    /**
     * Creates a paginator for ban events for a given channel.
     *
     * @param channel The channel to retrieve the ban events from.
     */
    HelixModerationAPI.prototype.getBanEventsPaginated = function (channel) {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'moderation/banned/events',
            scope: 'moderation:read',
            query: {
                broadcaster_id: UserTools_1.extractUserId(channel)
            }
        }, this._client, function (data) { return new HelixBanEvent_1.default(data, _this._client); });
    };
    /**
     * Retrieves a list of moderators in a given channel.
     *
     * @param channel The channel to retrieve moderators from.
     * @param filter Additional filters for the result set.
     */
    HelixModerationAPI.prototype.getModerators = function (channel, filter) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'moderation/moderators',
                            scope: 'moderation:read',
                            query: tslib_1.__assign({ broadcaster_id: UserTools_1.extractUserId(channel), user_id: (_a = filter) === null || _a === void 0 ? void 0 : _a.userId }, HelixPagination_1.makePaginationQuery(filter))
                        })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixModerator_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for moderators in a given channel.
     *
     * @param channel The channel to retrieve moderators from.
     */
    HelixModerationAPI.prototype.getModeratorsPaginated = function (channel) {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'moderation/moderators',
            scope: 'moderation:read',
            query: {
                broadcaster_id: UserTools_1.extractUserId(channel)
            }
        }, this._client, function (data) { return new HelixModerator_1.default(data, _this._client); });
    };
    /**
     * Checks whether a given user is a moderator of a given channel.
     *
     * @param channel The channel to check.
     * @param user The user to check.
     */
    HelixModerationAPI.prototype.checkUserMod = function (channel, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        return [4 /*yield*/, this.getModerators(channel, { userId: userId })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data.some(function (mod) { return mod.userId === userId; })];
                }
            });
        });
    };
    /**
     * Retrieves a list of moderator events for a given channel.
     *
     * @param channel The channel to retrieve the moderator events from.
     * @param filter Additional filters for the result set.
     */
    HelixModerationAPI.prototype.getModeratorEvents = function (channel, filter) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'moderation/moderators/events',
                            scope: 'moderation:read',
                            query: tslib_1.__assign({ broadcaster_id: UserTools_1.extractUserId(channel), user_id: (_a = filter) === null || _a === void 0 ? void 0 : _a.userId }, HelixPagination_1.makePaginationQuery(filter))
                        })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixModeratorEvent_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for moderator events for a given channel.
     *
     * @param channel The channel to retrieve the moderator events from.
     */
    HelixModerationAPI.prototype.getModeratorEventsPaginated = function (channel) {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'moderation/moderators/events',
            scope: 'moderation:read',
            query: {
                broadcaster_id: UserTools_1.extractUserId(channel)
            }
        }, this._client, function (data) { return new HelixModeratorEvent_1.default(data, _this._client); });
    };
    return HelixModerationAPI;
}(BaseAPI_1.default));
exports.default = HelixModerationAPI;

},{"../../../Toolkit/UserTools":320,"../../../TwitchClient":321,"../../BaseAPI":241,"../HelixPaginatedRequest":252,"../HelixPaginatedResult":254,"../HelixPagination":255,"./HelixBan":257,"./HelixBanEvent":258,"./HelixModerator":260,"./HelixModeratorEvent":261,"tslib":217}],260:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
/**
 * Information about the moderator status of a user.
 */
var HelixModerator = /** @class */ (function () {
    /** @private */
    function HelixModerator(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixModerator.prototype, "userId", {
        /**
         * The ID of the user.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the user.
     */
    HelixModerator.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.user_id)];
            });
        });
    };
    Object.defineProperty(HelixModerator.prototype, "userName", {
        /**
         * The name of the user.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixModerator.prototype, "_client", void 0);
    return HelixModerator;
}());
exports.default = HelixModerator;

},{"@d-fischer/shared-utils":36,"tslib":217}],261:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var HelixModerator_1 = require("./HelixModerator");
/**
 * The different types a moderator event can have.
 */
var HelixModeratorEventType;
(function (HelixModeratorEventType) {
    /**
     * Sent when a user gains moderation privileges.
     */
    HelixModeratorEventType["Add"] = "moderation.moderator.add";
    /**
     * Sent when a user loses moderation privileges.
     */
    HelixModeratorEventType["Remove"] = "moderation.moderator.remove";
})(HelixModeratorEventType = exports.HelixModeratorEventType || (exports.HelixModeratorEventType = {}));
/**
 * An event that indicates the change of a moderator status, i.e. gaining or losing moderation privileges.
 */
var HelixModeratorEvent = /** @class */ (function (_super) {
    tslib_1.__extends(HelixModeratorEvent, _super);
    /** @private */
    function HelixModeratorEvent(_eventData, client) {
        var _this = _super.call(this, _eventData.event_data, client) || this;
        _this._eventData = _eventData;
        return _this;
    }
    Object.defineProperty(HelixModeratorEvent.prototype, "eventId", {
        /**
         * The unique ID of the moderator event.
         */
        get: function () {
            return this._eventData.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixModeratorEvent.prototype, "eventType", {
        /**
         * The type of the moderator event.
         */
        get: function () {
            return this._eventData.event_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixModeratorEvent.prototype, "eventDate", {
        /**
         * The date of the moderator event.
         */
        get: function () {
            return new Date(this._eventData.event_timestamp);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixModeratorEvent.prototype, "eventVersion", {
        /**
         * The version of the moderator event.
         */
        get: function () {
            return this._eventData.version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixModeratorEvent.prototype, "broadcasterId", {
        /**
         * The id of the broadcaster where the user gained/lost moderation privileges.
         */
        get: function () {
            return this._eventData.event_data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the broadcaster.
     */
    HelixModeratorEvent.prototype.getBroadcaster = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._eventData.event_data.broadcaster_id)];
            });
        });
    };
    Object.defineProperty(HelixModeratorEvent.prototype, "broadcasterName", {
        /**
         * The name of the broadcaster where the user gained/lost moderation privileges.
         */
        get: function () {
            return this._eventData.event_data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    return HelixModeratorEvent;
}(HelixModerator_1.default));
exports.default = HelixModeratorEvent;

},{"./HelixModerator":260,"tslib":217}],262:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
/**
 * The type of a stream.
 */
var HelixStreamType;
(function (HelixStreamType) {
    /**
     * Returned by Twitch in case of an error.
     */
    HelixStreamType["None"] = "";
    /**
     * A live stream.
     */
    HelixStreamType["Live"] = "live";
    /**
     * A vodcast.
     *
     * Currently not supported by Twitch - but one can only hope and leave it in here.
     */
    HelixStreamType["Vodcast"] = "vodcast";
})(HelixStreamType = exports.HelixStreamType || (exports.HelixStreamType = {}));
/**
 * A Twitch stream.
 */
var HelixStream = /** @class */ (function () {
    /** @private */
    function HelixStream(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixStream.prototype, "id", {
        /**
         * The stream ID.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "userId", {
        /**
         * The user ID.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "userDisplayName", {
        /**
         * The user's display name.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the user broadcasting the stream.
     */
    HelixStream.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.user_id)];
            });
        });
    };
    Object.defineProperty(HelixStream.prototype, "gameId", {
        /**
         * The game ID.
         */
        get: function () {
            return this._data.game_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the game that is being played on this stream.
     */
    HelixStream.prototype.getGame = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.games.getGameById(this._data.game_id)];
            });
        });
    };
    Object.defineProperty(HelixStream.prototype, "type", {
        /**
         * The type of the stream.
         */
        get: function () {
            return this._data.type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "title", {
        /**
         * The title of the stream.
         */
        get: function () {
            return this._data.title;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "viewers", {
        /**
         * The number of viewers the stream currently has.
         */
        get: function () {
            return this._data.viewer_count;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "startDate", {
        /**
         * The time when the stream started.
         */
        get: function () {
            return new Date(this._data.started_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "language", {
        /**
         * The language of the stream.
         */
        get: function () {
            return this._data.language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStream.prototype, "thumbnailUrl", {
        /**
         * The URL of the thumbnail of the stream.
         */
        get: function () {
            return this._data.thumbnail_url;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixStream.prototype, "_client", void 0);
    return HelixStream;
}());
exports.default = HelixStream;

},{"@d-fischer/shared-utils":36,"tslib":217}],263:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var HTTPStatusCodeError_1 = require("../../../Errors/HTTPStatusCodeError");
var StreamNotLiveError_1 = require("../../../Errors/StreamNotLiveError");
var UserTools_1 = require("../../../Toolkit/UserTools");
var TwitchClient_1 = require("../../../TwitchClient");
var BaseAPI_1 = require("../../BaseAPI");
var HelixPaginatedRequest_1 = require("../HelixPaginatedRequest");
var HelixPaginatedResult_1 = require("../HelixPaginatedResult");
var HelixPagination_1 = require("../HelixPagination");
var HelixStream_1 = require("./HelixStream");
var HelixStreamMarker_1 = require("./HelixStreamMarker");
var HelixStreamMarkerWithVideo_1 = require("./HelixStreamMarkerWithVideo");
/**
 * The Helix API methods that deal with streams.
 *
 * Can be accessed using `client.helix.streams` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const stream = await client.helix.streams.getStreamByUserId('125328655');
 * ```
 */
var HelixStreamAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixStreamAPI, _super);
    function HelixStreamAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of streams.
     *
     * @expandParams
     */
    HelixStreamAPI.prototype.getStreams = function (filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: 'streams',
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            query: tslib_1.__assign(tslib_1.__assign({}, HelixPagination_1.makePaginationQuery(filter)), { community_id: filter.community, game_id: filter.game, language: filter.language, type: filter.type, user_id: filter.userId, user_login: filter.userName })
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixStream_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for streams.
     *
     * @expandParams
     */
    HelixStreamAPI.prototype.getStreamsPaginated = function (filter) {
        var _this = this;
        if (filter === void 0) { filter = {}; }
        return new HelixPaginatedRequest_1.default({
            url: 'streams',
            query: {
                community_id: filter.community,
                game_id: filter.game,
                language: filter.language,
                type: filter.type,
                user_id: filter.userId,
                user_login: filter.userName
            }
        }, this._client, function (data) { return new HelixStream_1.default(data, _this._client); });
    };
    /**
     * Retrieves the current stream for the given user name.
     *
     * @param user The user name to retrieve the stream for.
     */
    HelixStreamAPI.prototype.getStreamByUserName = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getStreams({ userName: UserTools_1.extractUserName(user) })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data.length ? result.data[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves the current stream for the given user ID.
     *
     * @param user The user ID to retrieve the stream for.
     */
    HelixStreamAPI.prototype.getStreamByUserId = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getStreams({ userId: UserTools_1.extractUserId(user) })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data.length ? result.data[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves a list of all stream markers for an user.
     *
     * @param user The user to list the stream markers for.
     */
    HelixStreamAPI.prototype.getStreamMarkersForUser = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getStreamMarkers('user_id', UserTools_1.extractUserId(user))];
            });
        });
    };
    /**
     * Creates a paginator for all stream markers for an user.
     *
     * @param user The user to list the stream markers for.
     */
    HelixStreamAPI.prototype.getStreamMarkersForUserPaginated = function (user) {
        return this._getStreamMarkersPaginated('user_id', UserTools_1.extractUserId(user));
    };
    /**
     * Retrieves a list of all stream markers for a video.
     *
     * @param videoId The video to list the stream markers for.
     */
    HelixStreamAPI.prototype.getStreamMarkersForVideo = function (videoId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getStreamMarkers('video_id', videoId)];
            });
        });
    };
    /**
     * Creates a paginator for all stream markers for a video.
     *
     * @param videoId The video to list the stream markers for.
     */
    HelixStreamAPI.prototype.getStreamMarkersForVideoPaginated = function (videoId) {
        return this._getStreamMarkersPaginated('video_id', videoId);
    };
    /**
     * Creates a new stream marker.
     *
     * Only works while your stream is live.
     */
    HelixStreamAPI.prototype.createStreamMarker = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result, e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this._client.callAPI({
                                url: 'streams/markers',
                                method: 'POST',
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                scope: 'user:edit:broadcast'
                            })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, new HelixStreamMarker_1.default(result.data[0], this._client)];
                    case 2:
                        e_1 = _a.sent();
                        if (e_1 instanceof HTTPStatusCodeError_1.default && e_1.statusCode === 404) {
                            throw new StreamNotLiveError_1.default();
                        }
                        throw e_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    HelixStreamAPI.prototype._getStreamMarkers = function (queryType, id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: 'streams/markers',
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            query: (_a = {},
                                _a[queryType] = id,
                                _a),
                            scope: 'user:read:broadcast'
                        })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, {
                                data: shared_utils_1.flatten(result.data.map(HelixStreamAPI._mapGetStreamMarkersResult.bind(this._client))),
                                cursor: result.pagination && result.pagination.cursor
                            }];
                }
            });
        });
    };
    HelixStreamAPI.prototype._getStreamMarkersPaginated = function (queryType, id) {
        var _a;
        return new HelixPaginatedRequest_1.default({
            url: 'streams/markers',
            query: (_a = {},
                _a[queryType] = id,
                _a),
            scope: 'user:read:broadcast'
        }, this._client, HelixStreamAPI._mapGetStreamMarkersResult.bind(this._client));
    };
    HelixStreamAPI._mapGetStreamMarkersResult = function (data) {
        var _this = this;
        return data.videos.reduce(function (result, video) { return tslib_1.__spread(result, video.markers.map(function (marker) { return new HelixStreamMarkerWithVideo_1.default(marker, video.video_id, _this); })); }, []);
    };
    return HelixStreamAPI;
}(BaseAPI_1.default));
exports.default = HelixStreamAPI;

},{"../../../Errors/HTTPStatusCodeError":314,"../../../Errors/StreamNotLiveError":318,"../../../Toolkit/UserTools":320,"../../../TwitchClient":321,"../../BaseAPI":241,"../HelixPaginatedRequest":252,"../HelixPaginatedResult":254,"../HelixPagination":255,"./HelixStream":262,"./HelixStreamMarker":264,"./HelixStreamMarkerWithVideo":265,"@d-fischer/shared-utils":36,"tslib":217}],264:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var HelixStreamMarker = /** @class */ (function () {
    /** @private */
    function HelixStreamMarker(/** @private */ _data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixStreamMarker.prototype, "id", {
        /**
         * The ID of the marker.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStreamMarker.prototype, "creationDate", {
        /**
         * The date and time when the marker was created.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStreamMarker.prototype, "description", {
        /**
         * The description of the marker.
         */
        get: function () {
            return this._data.description;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStreamMarker.prototype, "positionInSeconds", {
        /**
         * The position in the stream when the marker was created, in seconds.
         */
        get: function () {
            return this._data.position_seconds;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixStreamMarker.prototype, "_client", void 0);
    return HelixStreamMarker;
}());
exports.default = HelixStreamMarker;

},{"@d-fischer/shared-utils":36,"tslib":217}],265:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var HelixStreamMarker_1 = require("./HelixStreamMarker");
var HelixStreamMarkerWithVideo = /** @class */ (function (_super) {
    tslib_1.__extends(HelixStreamMarkerWithVideo, _super);
    /** @private */
    function HelixStreamMarkerWithVideo(data, _videoId, client) {
        var _this = _super.call(this, data, client) || this;
        _this._videoId = _videoId;
        return _this;
    }
    Object.defineProperty(HelixStreamMarkerWithVideo.prototype, "url", {
        /**
         * The URL of the video, which will start playing at the position of the stream marker.
         */
        get: function () {
            return this._data.URL;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixStreamMarkerWithVideo.prototype, "videoId", {
        /**
         * The ID of the video.
         */
        get: function () {
            return this._videoId;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the video data of the video the marker was set in.
     */
    HelixStreamMarkerWithVideo.prototype.getVideo = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.videos.getVideoById(this._videoId)];
            });
        });
    };
    return HelixStreamMarkerWithVideo;
}(HelixStreamMarker_1.default));
exports.default = HelixStreamMarkerWithVideo;

},{"./HelixStreamMarker":264,"tslib":217}],266:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
/**
 * A (paid) subscription of a user to a broadcaster.
 */
var HelixSubscription = /** @class */ (function () {
    /** @private */
    function HelixSubscription(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixSubscription.prototype, "broadcasterId", {
        /**
         * The user ID of the broadcaster.
         */
        get: function () {
            return this._data.broadcaster_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscription.prototype, "broadcasterDisplayName", {
        /**
         * The display name of the broadcaster.
         */
        get: function () {
            return this._data.broadcaster_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the broadcaster.
     */
    HelixSubscription.prototype.getBroadcaster = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this.broadcasterId)];
            });
        });
    };
    Object.defineProperty(HelixSubscription.prototype, "isGift", {
        /**
         * Whether the subscription has been gifted by another user.
         */
        get: function () {
            return this._data.is_gift;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscription.prototype, "tier", {
        /**
         * The tier of the subscription.
         */
        get: function () {
            return this._data.tier;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscription.prototype, "userId", {
        /**
         * The user ID of the subscribed user.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscription.prototype, "userDisplayName", {
        /**
         * The display name of the subscribed user.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the subscribed user.
     */
    HelixSubscription.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this.userId)];
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixSubscription.prototype, "_client", void 0);
    return HelixSubscription;
}());
exports.default = HelixSubscription;

},{"@d-fischer/shared-utils":36,"tslib":217}],267:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var UserTools_1 = require("../../../Toolkit/UserTools");
var TwitchClient_1 = require("../../../TwitchClient");
var BaseAPI_1 = require("../../BaseAPI");
var HelixPaginatedRequest_1 = require("../HelixPaginatedRequest");
var HelixPaginatedResult_1 = require("../HelixPaginatedResult");
var HelixSubscription_1 = require("./HelixSubscription");
var HelixSubscriptionEvent_1 = require("./HelixSubscriptionEvent");
/**
 * The Helix API methods that deal with subscriptions.
 *
 * Can be accessed using `client.helix.subscriptions` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const subscriptions = await client.helix.subscriptions.getSubscriptionsForUsers('61369223', '125328655');
 * ```
 */
var HelixSubscriptionAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixSubscriptionAPI, _super);
    function HelixSubscriptionAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of all subscriptions to a given broadcaster.
     *
     * @param broadcaster The broadcaster to list subscriptions to.
     */
    HelixSubscriptionAPI.prototype.getSubscriptions = function (broadcaster) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: 'subscriptions',
                            scope: 'channel:read:subscriptions',
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            query: {
                                broadcaster_id: UserTools_1.extractUserId(broadcaster)
                            }
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixSubscription_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for all subscriptions to a given broadcaster.
     *
     * @param broadcaster The broadcaster to list subscriptions to.
     */
    HelixSubscriptionAPI.prototype.getSubscriptionsPaginated = function (broadcaster) {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'subscriptions',
            scope: 'channel:read:subscriptions',
            query: {
                broadcaster_id: UserTools_1.extractUserId(broadcaster)
            }
        }, this._client, function (data) { return new HelixSubscription_1.default(data, _this._client); });
    };
    /**
     * Retrieves the subset of the given user list that is subscribed to the given broadcaster.
     *
     * @param broadcaster The broadcaster to find subscriptions to.
     * @param users The users that should be checked for subscriptions.
     */
    HelixSubscriptionAPI.prototype.getSubscriptionsForUsers = function (broadcaster, users) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: 'subscriptions',
                            scope: 'channel:read:subscriptions',
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            query: {
                                broadcaster_id: UserTools_1.extractUserId(broadcaster),
                                user_id: users.map(UserTools_1.extractUserId)
                            }
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data.map(function (data) { return new HelixSubscription_1.default(data, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves the subscription data for a given user to a given broadcaster.
     *
     * @param broadcaster The broadcaster to check.
     * @param user The user to check.
     */
    HelixSubscriptionAPI.prototype.getSubscriptionForUser = function (broadcaster, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var list;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getSubscriptionsForUsers(broadcaster, [user])];
                    case 1:
                        list = _a.sent();
                        return [2 /*return*/, list.length ? list[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves the most recent subscription events for a given broadcaster.
     *
     * @param broadcaster The broadcaster to retrieve subscription events for.
     */
    HelixSubscriptionAPI.prototype.getSubscriptionEventsForBroadcaster = function (broadcaster) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getSubscriptionEvents('broadcaster_id', UserTools_1.extractUserId(broadcaster))];
            });
        });
    };
    /**
     * Creates a paginator for the recent subscription events for a given broadcaster.
     *
     * @param broadcaster The broadcaster to retrieve subscription events for.
     */
    HelixSubscriptionAPI.prototype.getSubscriptionEventsForBroadcasterPaginated = function (broadcaster) {
        var _this = this;
        return new HelixPaginatedRequest_1.default({
            url: 'subscriptions/events',
            scope: 'channel:read:subscriptions',
            query: {
                broadcaster_id: UserTools_1.extractUserId(broadcaster)
            }
        }, this._client, function (data) { return new HelixSubscriptionEvent_1.default(data, _this._client); });
    };
    /**
     * Retrieves a single subscription event by ID.
     *
     * @param id The event ID.
     */
    HelixSubscriptionAPI.prototype.getSubscriptionEventById = function (id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getSubscriptionEvents('id', id)];
            });
        });
    };
    HelixSubscriptionAPI.prototype._getSubscriptionEvents = function (by, id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'subscriptions/events',
                            scope: 'channel:read:subscriptions',
                            query: (_a = {},
                                _a[by] = id,
                                _a)
                        })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResult(result, HelixSubscriptionEvent_1.default, this._client)];
                }
            });
        });
    };
    return HelixSubscriptionAPI;
}(BaseAPI_1.default));
exports.default = HelixSubscriptionAPI;

},{"../../../Toolkit/UserTools":320,"../../../TwitchClient":321,"../../BaseAPI":241,"../HelixPaginatedRequest":252,"../HelixPaginatedResult":254,"./HelixSubscription":266,"./HelixSubscriptionEvent":268,"tslib":217}],268:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var HelixSubscription_1 = require("./HelixSubscription");
/**
 * The different types a subscription event can have.
 */
var HelixSubscriptionEventType;
(function (HelixSubscriptionEventType) {
    /**
     * Sent when a new user subscribes.
     */
    HelixSubscriptionEventType["Subscribe"] = "subscriptions.subscribe";
    /**
     * Sent when a previous subscriber stops subscribing.
     */
    HelixSubscriptionEventType["Unsubscribe"] = "subscriptions.unsubscribe";
    /**
     * Sent when a new or recurring subscriber sends their monthly notification.
     */
    HelixSubscriptionEventType["Notification"] = "subscriptions.notification";
})(HelixSubscriptionEventType = exports.HelixSubscriptionEventType || (exports.HelixSubscriptionEventType = {}));
/**
 * An event that indicates the change of a subscription status, i.e. subscribing, unsubscribing or sending the monthly notification.
 */
var HelixSubscriptionEvent = /** @class */ (function (_super) {
    tslib_1.__extends(HelixSubscriptionEvent, _super);
    /** @private */
    function HelixSubscriptionEvent(_eventData, client) {
        var _this = _super.call(this, _eventData.event_data, client) || this;
        _this._eventData = _eventData;
        return _this;
    }
    Object.defineProperty(HelixSubscriptionEvent.prototype, "eventId", {
        /**
         * The unique ID of the subscription event.
         */
        get: function () {
            return this._eventData.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscriptionEvent.prototype, "eventType", {
        /**
         * The type of the subscription event.
         */
        get: function () {
            return this._eventData.event_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscriptionEvent.prototype, "eventDate", {
        /**
         * The date of the subscription event.
         */
        get: function () {
            return new Date(this._eventData.event_timestamp);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscriptionEvent.prototype, "eventVersion", {
        /**
         * The version of the subscription event.
         */
        get: function () {
            return this._eventData.version;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixSubscriptionEvent.prototype, "eventMessage", {
        /**
         * The message sent with the subscription event.
         */
        get: function () {
            return this._eventData.event_data.message || '';
        },
        enumerable: true,
        configurable: true
    });
    return HelixSubscriptionEvent;
}(HelixSubscription_1.default));
exports.default = HelixSubscriptionEvent;

},{"./HelixSubscription":266,"tslib":217}],269:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
/**
 * A relation of a user following a broadcaster.
 */
var HelixFollow = /** @class */ (function () {
    /** @private */
    function HelixFollow(/** @private */ _data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixFollow.prototype, "userId", {
        /**
         * The user ID of the following user.
         */
        get: function () {
            return this._data.from_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixFollow.prototype, "userDisplayName", {
        /**
         * The display name of the following user.
         */
        get: function () {
            return this._data.from_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the data of the following user.
     */
    HelixFollow.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.from_id)];
            });
        });
    };
    Object.defineProperty(HelixFollow.prototype, "followedUserId", {
        /**
         * The user ID of the followed broadcaster.
         */
        get: function () {
            return this._data.to_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixFollow.prototype, "followedUserDisplayName", {
        /**
         * The display name of the followed user.
         */
        get: function () {
            return this._data.to_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the data of the followed broadcaster.
     */
    HelixFollow.prototype.getFollowedUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.to_id)];
            });
        });
    };
    Object.defineProperty(HelixFollow.prototype, "followDate", {
        /**
         * The date when the user followed the broadcaster.
         */
        get: function () {
            return new Date(this._data.followed_at);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixFollow.prototype, "_client", void 0);
    return HelixFollow;
}());
exports.default = HelixFollow;

},{"@d-fischer/shared-utils":36,"tslib":217}],270:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var HelixUser_1 = require("./HelixUser");
/**
 * A user you have extended privilges for, i.e. yourself.
 */
var HelixPrivilegedUser = /** @class */ (function (_super) {
    tslib_1.__extends(HelixPrivilegedUser, _super);
    function HelixPrivilegedUser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(HelixPrivilegedUser.prototype, "email", {
        /**
         * The email address of the user.
         */
        get: function () {
            return this._data.email;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Changes the description of the user.
     *
     * @param description The new description.
     */
    HelixPrivilegedUser.prototype.setDescription = function (description) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.updateUser({ description: description })];
            });
        });
    };
    return HelixPrivilegedUser;
}(HelixUser_1.default));
exports.default = HelixPrivilegedUser;

},{"./HelixUser":271,"tslib":217}],271:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var NoSubscriptionProgramError_1 = require("../../../Errors/NoSubscriptionProgramError");
/**
 * The type of a broadcaster.
 */
var HelixBroadcasterType;
(function (HelixBroadcasterType) {
    /**
     * A Twitch Partner.
     */
    HelixBroadcasterType["Partner"] = "partner";
    /**
     * A Twitch Affiliate.
     */
    HelixBroadcasterType["Affiliate"] = "affiliate";
    /**
     * A user that's neither a partner nor an affiliate.
     */
    HelixBroadcasterType["None"] = "";
})(HelixBroadcasterType = exports.HelixBroadcasterType || (exports.HelixBroadcasterType = {}));
/**
 * The type of a user.
 */
var HelixUserType;
(function (HelixUserType) {
    /**
     * A Twitch staff member.
     */
    HelixUserType["Staff"] = "staff";
    /**
     * A Twitch administrator.
     */
    HelixUserType["Admin"] = "admin";
    /**
     * A global moderator.
     */
    HelixUserType["GlobalMod"] = "global_mod";
    /**
     * A user with no special permissions across Twitch.
     */
    HelixUserType["None"] = "";
})(HelixUserType = exports.HelixUserType || (exports.HelixUserType = {}));
/**
 * A Twitch user.
 */
var HelixUser = /** @class */ (function () {
    /** @private */
    function HelixUser(/** @private */ _data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixUser.prototype, "cacheKey", {
        /** @private */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "id", {
        /**
         * The ID of the user.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "name", {
        /**
         * The user name of the user.
         */
        get: function () {
            return this._data.login;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "displayName", {
        /**
         * The display name of the user.
         */
        get: function () {
            return this._data.display_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "description", {
        /**
         * The description of the user.
         */
        get: function () {
            return this._data.description;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "type", {
        /**
         * The type of the user.
         */
        get: function () {
            return this._data.type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "broadcasterType", {
        /**
         * The type of the user.
         */
        get: function () {
            return this._data.broadcaster_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "profilePictureUrl", {
        /**
         * The URL to the profile picture of the user.
         */
        get: function () {
            return this._data.profile_image_url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "offlinePlaceholderUrl", {
        /**
         * The URL to the offline video placeholder of the user.
         */
        get: function () {
            return this._data.offline_image_url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixUser.prototype, "views", {
        /**
         * The total number of views of the user's channel.
         */
        get: function () {
            return this._data.view_count;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the channel's stream data.
     */
    HelixUser.prototype.getStream = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.streams.getStreamByUserId(this)];
            });
        });
    };
    /**
     * Retrieves a list of broadcasters the user follows.
     */
    HelixUser.prototype.getFollows = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getFollows({ user: this })];
            });
        });
    };
    /**
     * Retrieves the follow data of the user to the given broadcaster.
     *
     * @param broadcaster The broadcaster to check the follow to.
     */
    HelixUser.prototype.getFollowTo = function (broadcaster) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var params, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        params = {
                            user: this.id,
                            followedUser: broadcaster
                        };
                        return [4 /*yield*/, this._client.helix.users.getFollows(params)];
                    case 1:
                        result = (_a.sent()).data;
                        return [2 /*return*/, result.length ? result[0] : null];
                }
            });
        });
    };
    /**
     * Checks whether the user is following the given broadcaster.
     *
     * @param broadcaster The broadcaster to check the user's follow to.
     */
    HelixUser.prototype.follows = function (broadcaster) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getFollowTo(broadcaster)];
                    case 1: return [2 /*return*/, (_a.sent()) !== null];
                }
            });
        });
    };
    /**
     * Follows the broadcaster.
     */
    HelixUser.prototype.follow = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var currentUser;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.kraken.users.getMe()];
                    case 1:
                        currentUser = _a.sent();
                        return [2 /*return*/, currentUser.followChannel(this)];
                }
            });
        });
    };
    /**
     * Unfollows the broadcaster.
     */
    HelixUser.prototype.unfollow = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var currentUser;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.kraken.users.getMe()];
                    case 1:
                        currentUser = _a.sent();
                        return [2 /*return*/, currentUser.unfollowChannel(this)];
                }
            });
        });
    };
    /**
     * Retrieves the subscription data for the user to the given broadcaster, or `null` if the user is not subscribed.
     *
     * @param broadcaster The broadcaster you want to get the subscription data for.
     */
    HelixUser.prototype.getSubscriptionTo = function (broadcaster) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.subscriptions.getSubscriptionForUser(broadcaster, this)];
            });
        });
    };
    /**
     * Checks whether the user is subscribed to the given broadcaster.
     *
     * @param broadcaster The broadcaster you want to check the subscription for.
     */
    HelixUser.prototype.isSubscribedTo = function (broadcaster) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.getSubscriptionTo(broadcaster)];
                    case 1: return [2 /*return*/, (_a.sent()) !== null];
                    case 2:
                        e_1 = _a.sent();
                        if (e_1 instanceof NoSubscriptionProgramError_1.default) {
                            return [2 /*return*/, false];
                        }
                        throw e_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixUser.prototype, "_client", void 0);
    return HelixUser;
}());
exports.default = HelixUser;

},{"../../../Errors/NoSubscriptionProgramError":317,"@d-fischer/shared-utils":36,"tslib":217}],272:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var HellFreezesOverError_1 = require("../../../Errors/HellFreezesOverError");
var UserTools_1 = require("../../../Toolkit/UserTools");
var TwitchClient_1 = require("../../../TwitchClient");
var BaseAPI_1 = require("../../BaseAPI");
var HelixPaginatedRequestWithTotal_1 = require("../HelixPaginatedRequestWithTotal");
var HelixPaginatedResult_1 = require("../HelixPaginatedResult");
var HelixFollow_1 = require("./HelixFollow");
var HelixPrivilegedUser_1 = require("./HelixPrivilegedUser");
var HelixUser_1 = require("./HelixUser");
/** @private */
var UserLookupType;
(function (UserLookupType) {
    UserLookupType["Id"] = "id";
    UserLookupType["Login"] = "login";
})(UserLookupType = exports.UserLookupType || (exports.UserLookupType = {}));
/**
 * The Helix API methods that deal with users.
 *
 * Can be accessed using `client.helix.users` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const user = await client.helix.users.getUserById('125328655');
 * ```
 */
var HelixUserAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixUserAPI, _super);
    function HelixUserAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves the user data for the given list of user IDs.
     *
     * @param userIds The user IDs you want to look up.
     */
    HelixUserAPI.prototype.getUsersByIds = function (userIds) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getUsers(UserLookupType.Id, userIds.map(UserTools_1.extractUserId))];
            });
        });
    };
    /**
     * Retrieves the user data for the given list of user names.
     *
     * @param userNames The user names you want to look up.
     */
    HelixUserAPI.prototype.getUsersByNames = function (userNames) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getUsers(UserLookupType.Login, userNames.map(UserTools_1.extractUserName))];
            });
        });
    };
    /**
     * Retrieves the user data for the given user ID.
     *
     * @param userId The user ID you want to look up.
     */
    HelixUserAPI.prototype.getUserById = function (userId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var users;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getUsers(UserLookupType.Id, UserTools_1.extractUserId(userId))];
                    case 1:
                        users = _a.sent();
                        return [2 /*return*/, users.length ? users[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves the user data for the given user name.
     *
     * @param userName The user name you want to look up.
     */
    HelixUserAPI.prototype.getUserByName = function (userName) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var users;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getUsers(UserLookupType.Login, UserTools_1.extractUserName(userName))];
                    case 1:
                        users = _a.sent();
                        return [2 /*return*/, users.length ? users[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves the user data of the currently authenticated user.
     *
     * @param withEmail Whether you need the user's email address.
     */
    HelixUserAPI.prototype.getMe = function (withEmail) {
        if (withEmail === void 0) { withEmail = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'users',
                            scope: withEmail ? 'user:read:email' : ''
                        })];
                    case 1:
                        result = _a.sent();
                        if (!result.data || !result.data.length) {
                            throw new HellFreezesOverError_1.default('Could not get authenticated user');
                        }
                        return [2 /*return*/, new HelixPrivilegedUser_1.default(result.data[0], this._client)];
                }
            });
        });
    };
    /**
     * Updates the currently authenticated user's data.
     *
     * @param data The data to update.
     */
    HelixUserAPI.prototype.updateUser = function (data) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            url: 'users',
                            method: 'PUT',
                            scope: 'user:edit',
                            query: {
                                description: data.description
                            }
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, new HelixPrivilegedUser_1.default(result.data[0], this._client)];
                }
            });
        });
    };
    /**
     * Retrieves a list of follow relations.
     *
     * @param filter Several filtering and pagination parameters. See the {@HelixFollowFilter} documentation.
     */
    HelixUserAPI.prototype.getFollows = function (filter) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = HelixUserAPI._makeFollowsQuery(filter);
                        return [4 /*yield*/, this._client.callAPI({
                                url: 'users/follows',
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                query: query
                            })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, HelixPaginatedResult_1.createPaginatedResultWithTotal(result, HelixFollow_1.default, this._client)];
                }
            });
        });
    };
    /**
     * Creates a paginator for follow relations.
     *
     * @param filter Several filtering and pagination parameters. See the {@HelixFollowFilter} documentation.
     */
    HelixUserAPI.prototype.getFollowsPaginated = function (filter) {
        var _this = this;
        var query = HelixUserAPI._makeFollowsQuery(filter);
        return new HelixPaginatedRequestWithTotal_1.default({
            url: 'users/follows',
            query: query
        }, this._client, function (data) { return new HelixFollow_1.default(data, _this._client); });
    };
    HelixUserAPI._makeFollowsQuery = function (filter) {
        var query = {};
        var hasUserIdParam = false;
        if (filter.user) {
            query.from_id = UserTools_1.extractUserId(filter.user);
            hasUserIdParam = true;
        }
        if (filter.followedUser) {
            query.to_id = UserTools_1.extractUserId(filter.followedUser);
            hasUserIdParam = true;
        }
        if (!hasUserIdParam) {
            throw new TypeError('At least one of user and followedUser have to be set');
        }
        return query;
    };
    HelixUserAPI.prototype._getUsers = function (lookupType, param) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, result;
            var _a;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        query = (_a = {}, _a[lookupType] = param, _a);
                        return [4 /*yield*/, this._client.callAPI({
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                url: 'users',
                                query: query
                            })];
                    case 1:
                        result = _b.sent();
                        return [2 /*return*/, result.data.map(function (userData) { return new HelixUser_1.default(userData, _this._client); })];
                }
            });
        });
    };
    return HelixUserAPI;
}(BaseAPI_1.default));
exports.default = HelixUserAPI;

},{"../../../Errors/HellFreezesOverError":315,"../../../Toolkit/UserTools":320,"../../../TwitchClient":321,"../../BaseAPI":241,"../HelixPaginatedRequestWithTotal":253,"../HelixPaginatedResult":254,"./HelixFollow":269,"./HelixPrivilegedUser":270,"./HelixUser":271,"tslib":217}],273:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var cache_decorators_1 = require("@d-fischer/cache-decorators");
var shared_utils_1 = require("@d-fischer/shared-utils");
var HellFreezesOverError_1 = require("../../../Errors/HellFreezesOverError");
/**
 * A video on Twitch.
 */
var HelixVideo = /** @class */ (function () {
    /** @private */
    function HelixVideo(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixVideo.prototype, "id", {
        /**
         * The ID of the video.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "userId", {
        /**
         * The ID of the user who created the video.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "userDisplayName", {
        /**
         * The display name of the user who created the video.
         */
        get: function () {
            return this._data.user_name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves information about the user who created the video.
     */
    HelixVideo.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.users.getUserById(this._data.user_id)];
            });
        });
    };
    Object.defineProperty(HelixVideo.prototype, "title", {
        /**
         * The title of the video.
         */
        get: function () {
            return this._data.title;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "description", {
        /**
         * The description of the video.
         */
        get: function () {
            return this._data.description;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "creationDate", {
        /**
         * The date when the video was created.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "publishDate", {
        /**
         * The date when the video was published.
         */
        get: function () {
            return new Date(this._data.published_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "url", {
        /**
         * The URL of the video.
         */
        get: function () {
            return this._data.url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "thumbnailUrl", {
        /**
         * The URL of the thumbnail of the video.
         */
        get: function () {
            return this._data.thumbnail_url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "isPublic", {
        /**
         * Whether the video is public or not.
         */
        get: function () {
            return this._data.viewable === 'public';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "views", {
        /**
         * The number of views of the video.
         */
        get: function () {
            return this._data.view_count;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "language", {
        /**
         * The language of the video.
         */
        get: function () {
            return this._data.language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "type", {
        /**
         * The type of the video.
         */
        get: function () {
            return this._data.type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "duration", {
        /**
         * The duration of the video, as formatted by Twitch.
         */
        get: function () {
            return this._data.duration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixVideo.prototype, "durationInSeconds", {
        /**
         * The duration of the video, in seconds.
         */
        get: function () {
            var parts = this._data.duration.match(/\d+[hms]/g);
            if (!parts) {
                throw new HellFreezesOverError_1.default("Could not parse duration string: " + this._data.duration);
            }
            return parts
                .map(function (part) {
                var partialMatch = part.match(/(\d+)([hms])/);
                if (!partialMatch) {
                    throw new HellFreezesOverError_1.default("Could not parse partial duration string: " + part);
                }
                var _a = tslib_1.__read(partialMatch, 3), num = _a[1], unit = _a[2];
                return parseInt(num, 10) * { h: 3600, m: 60, s: 1 }[unit];
            })
                .reduce(function (a, b) { return a + b; });
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixVideo.prototype, "_client", void 0);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], HelixVideo.prototype, "durationInSeconds", null);
    HelixVideo = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], HelixVideo);
    return HelixVideo;
}());
exports.default = HelixVideo;

},{"../../../Errors/HellFreezesOverError":315,"@d-fischer/cache-decorators":6,"@d-fischer/shared-utils":36,"tslib":217}],274:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var UserTools_1 = require("../../../Toolkit/UserTools");
var TwitchClient_1 = require("../../../TwitchClient");
var BaseAPI_1 = require("../../BaseAPI");
var HelixPaginatedRequest_1 = require("../HelixPaginatedRequest");
var HelixPagination_1 = require("../HelixPagination");
var HelixVideo_1 = require("./HelixVideo");
/**
 * The Helix API methods that deal with videos.
 *
 * Can be accessed using `client.helix.videos` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const videos = await client.helix.videos.getVideosByUser('125328655');
 * ```
 */
var HelixVideoAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixVideoAPI, _super);
    function HelixVideoAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves the video data for the given list of video IDs.
     *
     * @param ids The video IDs you want to look up.
     */
    HelixVideoAPI.prototype.getVideosByIds = function (ids) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getVideos('id', ids)];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.data];
                }
            });
        });
    };
    /**
     * Retrieves the video data for the given video ID.
     *
     * @param id The video ID you want to look up.
     */
    HelixVideoAPI.prototype.getVideoById = function (id) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var videos;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getVideosByIds(id)];
                    case 1:
                        videos = _a.sent();
                        return [2 /*return*/, videos.length ? videos[0] : null];
                }
            });
        });
    };
    /**
     * Retrieves the videos of the given user.
     *
     * @param user The user you want to retrieve videos from.
     * @param filter Additional filters for the result set.
     */
    HelixVideoAPI.prototype.getVideosByUser = function (user, filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = UserTools_1.extractUserId(user);
                return [2 /*return*/, this._getVideos('user_id', userId, filter)];
            });
        });
    };
    /**
     * Creates a paginator for videos of the given user.
     *
     * @param user The user you want to retrieve videos from.
     * @param filter Additional filters for the result set.
     */
    HelixVideoAPI.prototype.getVideosByUserPaginated = function (user, filter) {
        if (filter === void 0) { filter = {}; }
        var userId = UserTools_1.extractUserId(user);
        return this._getVideosPaginated('user_id', userId, filter);
    };
    /**
     * Retrieves the videos of the given game.
     *
     * @param gameId The game you want to retrieve videos from.
     * @param filter Additional filters for the result set.
     */
    HelixVideoAPI.prototype.getVideosByGame = function (gameId, filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._getVideos('game_id', gameId, filter)];
            });
        });
    };
    /**
     * Creates a paginator for videos of the given game.
     *
     * @param gameId The game you want to retrieve videos from.
     * @param filter Additional filters for the result set.
     */
    HelixVideoAPI.prototype.getVideosByGamePaginated = function (gameId, filter) {
        if (filter === void 0) { filter = {}; }
        return this._getVideosPaginated('game_id', gameId, filter);
    };
    HelixVideoAPI.prototype._getVideos = function (filterType, filterValues, filter) {
        if (filter === void 0) { filter = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var result;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: 'videos',
                            type: TwitchClient_1.TwitchAPICallType.Helix,
                            query: tslib_1.__assign(tslib_1.__assign({}, HelixVideoAPI._makeVideosQuery(filterType, filterValues, filter)), HelixPagination_1.makePaginationQuery(filter))
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, {
                                data: result.data.map(function (data) { return new HelixVideo_1.default(data, _this._client); }),
                                cursor: result.pagination && result.pagination.cursor
                            }];
                }
            });
        });
    };
    HelixVideoAPI.prototype._getVideosPaginated = function (filterType, filterValues, filter) {
        var _this = this;
        if (filter === void 0) { filter = {}; }
        return new HelixPaginatedRequest_1.default({
            url: 'videos',
            query: HelixVideoAPI._makeVideosQuery(filterType, filterValues, filter)
        }, this._client, function (data) { return new HelixVideo_1.default(data, _this._client); });
    };
    HelixVideoAPI._makeVideosQuery = function (filterType, filterValues, filter) {
        var _a;
        if (filter === void 0) { filter = {}; }
        var language = filter.language, period = filter.period, orderBy = filter.orderBy, type = filter.type;
        return _a = {},
            _a[filterType] = filterValues,
            _a.language = language,
            _a.period = period,
            _a.sort = orderBy,
            _a.type = type,
            _a;
    };
    return HelixVideoAPI;
}(BaseAPI_1.default));
exports.default = HelixVideoAPI;

},{"../../../Toolkit/UserTools":320,"../../../TwitchClient":321,"../../BaseAPI":241,"../HelixPaginatedRequest":252,"../HelixPagination":255,"./HelixVideo":273,"tslib":217}],275:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
/**
 * A subscription to a Twitch WebHook.
 */
var HelixWebHookSubscription = /** @class */ (function () {
    /** @private */
    function HelixWebHookSubscription(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(HelixWebHookSubscription.prototype, "topicUrl", {
        /**
         * The topic the WebHook is listening to.
         */
        get: function () {
            return this._data.topic;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixWebHookSubscription.prototype, "callbackUrl", {
        /**
         * The URL that will be called for every subscribed event.
         */
        get: function () {
            return this._data.callback;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HelixWebHookSubscription.prototype, "expiryDate", {
        /**
         * The time when the subscription will expire.
         */
        get: function () {
            return new Date(this._data.expires_at);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Unsubscribe from the WebHook.
     */
    HelixWebHookSubscription.prototype.unsubscribe = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.helix.webHooks.sendHubRequest({
                        mode: 'unsubscribe',
                        topicUrl: this.topicUrl,
                        callbackUrl: this.callbackUrl
                    })];
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], HelixWebHookSubscription.prototype, "_client", void 0);
    return HelixWebHookSubscription;
}());
exports.default = HelixWebHookSubscription;

},{"@d-fischer/shared-utils":36,"tslib":217}],276:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var UserTools_1 = require("../../../Toolkit/UserTools");
var TwitchClient_1 = require("../../../TwitchClient");
var BaseAPI_1 = require("../../BaseAPI");
var HelixPaginatedRequestWithTotal_1 = require("../HelixPaginatedRequestWithTotal");
var HelixWebHookSubscription_1 = require("./HelixWebHookSubscription");
/**
 * The API methods that deal with WebHooks.
 *
 * Can be accessed using `client.helix.webHooks` on a {@TwitchClient} instance.
 *
 * ## Before using these methods...
 *
 * All of the methods in this class assume that you are already running a working WebHook listener at the given callback URL.
 *
 * If you don't already have one, we recommend use of the `twitch-webhooks` library, which handles subscribing and unsubscribing to these topics automatically.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const accepted = await client.helix.webHooks.subscribeToUserFollowsTo('125328655', { callbackUrl: 'https://example.com' });
 * ```
 */
var HelixWebHooksAPI = /** @class */ (function (_super) {
    tslib_1.__extends(HelixWebHooksAPI, _super);
    function HelixWebHooksAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves the current WebHook subscriptions for the current client.
     *
     * Requires an app access token to work; does not work with user tokens.
     */
    HelixWebHooksAPI.prototype.getSubscriptions = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, new HelixPaginatedRequestWithTotal_1.default({
                        url: 'webhooks/subscriptions'
                    }, this._client, function (data) { return new HelixWebHookSubscription_1.default(data, _this._client); })];
            });
        });
    };
    /**
     * Sends an arbitrary request to subscribe to or unsubscribe from an event.
     *
     * @expandParams
     */
    HelixWebHooksAPI.prototype.sendHubRequest = function (options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var mode, callbackUrl, topicUrl, _a, validityInSeconds, secret, scope;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        mode = options.mode, callbackUrl = options.callbackUrl, topicUrl = options.topicUrl, _a = options.validityInSeconds, validityInSeconds = _a === void 0 ? 3600 : _a, secret = options.secret, scope = options.scope;
                        return [4 /*yield*/, this._client.callAPI({
                                url: 'webhooks/hub',
                                type: TwitchClient_1.TwitchAPICallType.Helix,
                                method: 'POST',
                                scope: scope,
                                jsonBody: {
                                    'hub.mode': mode,
                                    'hub.topic': topicUrl,
                                    'hub.callback': callbackUrl,
                                    'hub.lease_seconds': mode === 'subscribe' ? validityInSeconds.toString() : undefined,
                                    'hub.secret': secret
                                }
                            })];
                    case 1:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Subscribes to events representing a user following other users.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about the users they will follow.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToUserFollowsFrom = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendUserFollowsHubRequest('subscribe', 'from', user, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a user being followed by other users.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about the users they will be followed by.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToUserFollowsTo = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendUserFollowsHubRequest('subscribe', 'to', user, options)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a user following other users.
     *
     * @expandParams
     *
     * @param user The user for which to not get any more notifications about the users they will follow.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromUserFollowsFrom = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendUserFollowsHubRequest('unsubscribe', 'from', user, options)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a user being followed by other users.
     *
     * @expandParams
     *
     * @param user The user for which to not get any more notifications about the users they will be followed by.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromUserFollowsTo = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendUserFollowsHubRequest('unsubscribe', 'to', user, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a stream changing, e.g. going live, offline or changing its title.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about their streams changing.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToStreamChanges = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendStreamChangeHubRequest('subscribe', user, options)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a stream changing, e.g. going live, offline or changing its title.
     *
     * @expandParams
     *
     * @param user The user for which not to get any more notifications about their streams changing.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromStreamChanges = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendStreamChangeHubRequest('unsubscribe', user, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a user changing a public setting or their email address.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about changing a setting.
     * @param options
     * @param withEmail Whether to subscribe to email address changes. This adds the necessary scope to read the email address to the request.
     */
    HelixWebHooksAPI.prototype.subscribeToUserChanges = function (user, options, withEmail) {
        if (withEmail === void 0) { withEmail = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendUserChangeHubRequest('subscribe', user, options, withEmail)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a user changing a public setting or their email address.
     *
     * @expandParams
     *
     * @param user The user for which not to get any more notifications about changing a setting.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromUserChanges = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendUserChangeHubRequest('unsubscribe', user, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a channel subscription or unsubscription.
     *
     * @expandParams
     *
     * @param user The user for which to get notifications about subscriptions and unsubscriptions to their channel.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToSubscriptionEvents = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendSubscriptionEventsHubRequest('subscribe', user, options)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a channel subscription or unsubscription.
     *
     * @expandParams
     *
     * @param user The user for which not to get any more notifications about subscriptions and unsubscriptions to their channel.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromSubscriptionEvents = function (user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendSubscriptionEventsHubRequest('unsubscribe', user, options)];
            });
        });
    };
    /**
     * Subscribes to extension transactions.
     *
     * @expandParams
     *
     * @param extensionId The extension ID for which to get notifications about transactions.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToExtensionTransactions = function (extensionId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendExtensionTransactionsHubRequest('subscribe', extensionId, options)];
            });
        });
    };
    /**
     * Unsubscribes from extension transactions.
     *
     * @expandParams
     *
     * @param extensionId The extension ID for which not to get any more notifications about transactions.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromExtensionTransactions = function (extensionId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendExtensionTransactionsHubRequest('unsubscribe', extensionId, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a ban or unban.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which to get notifications about bans or unbans in their channel.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToBanEvents = function (broadcaster, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendBanEventsHubRequest('subscribe', broadcaster, options)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a ban or unban.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which not to get any more notifications about bans or unbans in their channel.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromBanEvents = function (broadcaster, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendBanEventsHubRequest('unsubscribe', broadcaster, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a ban or unban.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which to get notifications about bans or unbans in their channel.
     * @param user The user that is being banned or unbanned.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToBanEventsForUser = function (broadcaster, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendBanEventsHubRequest('subscribe', broadcaster, options, user)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a ban or unban.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which not to get any more notifications about bans or unbans in their channel.
     * @param user The user that is being banned or unbanned.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromBanEventsForUser = function (broadcaster, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendBanEventsHubRequest('unsubscribe', broadcaster, options, user)];
            });
        });
    };
    /**
     * Subscribes to events representing a user gaining or losing moderator privileges in a channel.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which to get notifications about moderator changes in their channel.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToModeratorEvents = function (broadcaster, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendModeratorEventsHubRequest('subscribe', broadcaster, options)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a user gaining or losing moderator privileges in a channel.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which not to get any more notifications about moderator changes in their channel.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromModeratorEvents = function (broadcaster, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendModeratorEventsHubRequest('unsubscribe', broadcaster, options)];
            });
        });
    };
    /**
     * Subscribes to events representing a user gaining or losing moderator privileges in a channel.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which to get notifications about moderator changes in their channel.
     * @param user The user that is being banned or unbanned.
     * @param options
     */
    HelixWebHooksAPI.prototype.subscribeToModeratorEventsForUser = function (broadcaster, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendModeratorEventsHubRequest('subscribe', broadcaster, options, user)];
            });
        });
    };
    /**
     * Unsubscribes from events representing a user gaining or losing moderator privileges in a channel.
     *
     * @expandParams
     *
     * @param broadcaster The broadcaster for which not to get any more notifications about moderator changes in their channel.
     * @param user The user that is being banned or unbanned.
     * @param options
     */
    HelixWebHooksAPI.prototype.unsubscribeFromModeratorEventsForUser = function (broadcaster, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendModeratorEventsHubRequest('unsubscribe', broadcaster, options, user)];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendUserFollowsHubRequest = function (mode, direction, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = UserTools_1.extractUserId(user);
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode, topicUrl: "https://api.twitch.tv/helix/users/follows?first=1&" + direction + "_id=" + userId }, options))];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendStreamChangeHubRequest = function (mode, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = UserTools_1.extractUserId(user);
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode, topicUrl: "https://api.twitch.tv/helix/streams?user_id=" + userId }, options))];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendUserChangeHubRequest = function (mode, user, options, withEmail) {
        if (withEmail === void 0) { withEmail = false; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = UserTools_1.extractUserId(user);
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode, topicUrl: "https://api.twitch.tv/helix/users?id=" + userId, scope: withEmail ? 'user:read:email' : undefined }, options))];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendSubscriptionEventsHubRequest = function (mode, user, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId;
            return tslib_1.__generator(this, function (_a) {
                userId = UserTools_1.extractUserId(user);
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode, topicUrl: "https://api.twitch.tv/helix/subscriptions/events?broadcaster_id=" + userId + "&first=1", scope: 'channel:read:subscriptions' }, options))];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendExtensionTransactionsHubRequest = function (mode, extensionId, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode, topicUrl: "https://api.twitch.tv/helix/extensions/transactions?extension_id=" + extensionId + "&first=1" }, options))];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendBanEventsHubRequest = function (mode, broadcaster, options, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var broadcasterId, topicUrl;
            return tslib_1.__generator(this, function (_a) {
                broadcasterId = UserTools_1.extractUserId(broadcaster);
                topicUrl = "https://api.twitch.tv/helix/moderation/banned/events?broadcaster_id=" + broadcasterId + "&first=1";
                if (user) {
                    topicUrl += "&user_id=" + UserTools_1.extractUserId(user);
                }
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode,
                        topicUrl: topicUrl, scope: 'moderation:read' }, options))];
            });
        });
    };
    HelixWebHooksAPI.prototype._sendModeratorEventsHubRequest = function (mode, broadcaster, options, user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var broadcasterId, topicUrl;
            return tslib_1.__generator(this, function (_a) {
                broadcasterId = UserTools_1.extractUserId(broadcaster);
                topicUrl = "https://api.twitch.tv/helix/moderation/moderators/events?broadcaster_id=" + broadcasterId + "&first=1";
                if (user) {
                    topicUrl += "&user_id=" + UserTools_1.extractUserId(user);
                }
                return [2 /*return*/, this.sendHubRequest(tslib_1.__assign({ mode: mode,
                        topicUrl: topicUrl, scope: 'moderation:read' }, options))];
            });
        });
    };
    return HelixWebHooksAPI;
}(BaseAPI_1.default));
exports.default = HelixWebHooksAPI;

},{"../../../Toolkit/UserTools":320,"../../../TwitchClient":321,"../../BaseAPI":241,"../HelixPaginatedRequestWithTotal":253,"./HelixWebHookSubscription":275,"tslib":217}],277:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var cache_decorators_1 = require("@d-fischer/cache-decorators");
var UserTools_1 = require("../../../Toolkit/UserTools");
var BaseAPI_1 = require("../../BaseAPI");
var CheermoteList_1 = require("./CheermoteList");
/**
 * The API methods that deal with Bits/Cheermotes.
 *
 * Can be accessed using `client.kraken.bits` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const cheermotes = await client.kraken.bits.getCheermotes();
 * ```
 */
var BitsAPI = /** @class */ (function (_super) {
    tslib_1.__extends(BitsAPI, _super);
    function BitsAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves global and channel cheermotes.
     *
     * @param channel The channel you want to retrieve the available cheermotes for.
     * If not given, this method retrieves a list of globally available cheermotes.
     * @param includeSponsored Whether to include sponsored cheermotes in the list.
     */
    BitsAPI.prototype.getCheermotes = function (channel, includeSponsored) {
        if (includeSponsored === void 0) { includeSponsored = true; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = {};
                        if (channel) {
                            query.channel_id = UserTools_1.extractUserId(channel);
                        }
                        if (includeSponsored) {
                            query.include_sponsored = 'true';
                        }
                        return [4 /*yield*/, this._client.callAPI({ url: 'bits/actions', query: query })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new CheermoteList_1.default(data.actions, this._client)];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], BitsAPI.prototype, "getCheermotes", null);
    BitsAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], BitsAPI);
    return BitsAPI;
}(BaseAPI_1.default));
exports.default = BitsAPI;

},{"../../../Toolkit/UserTools":320,"../../BaseAPI":241,"./CheermoteList":278,"@d-fischer/cache-decorators":6,"tslib":217}],278:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var HellFreezesOverError_1 = require("../../../Errors/HellFreezesOverError");
/**
 * The type of background a cheermote is supposed to appear on.
 *
 * We will supply a fitting graphic that does not show any artifacts
 * on the given type of background.
 */
var CheermoteBackground;
(function (CheermoteBackground) {
    /**
     * A dark background.
     *
     * Cheermotes might show artifacts on bright backgrounds.
     */
    CheermoteBackground["dark"] = "dark";
    /**
     * A bright background.
     *
     * Cheermotes might show artifacts on dark backgrounds.
     */
    CheermoteBackground["light"] = "light";
})(CheermoteBackground = exports.CheermoteBackground || (exports.CheermoteBackground = {}));
/**
 * The state of a cheermote, i.e. whether it's animated or not.
 */
var CheermoteState;
(function (CheermoteState) {
    /**
     * The cheermote should be animated.
     */
    CheermoteState["animated"] = "animated";
    /**
     * The cheermote should not be animated.
     */
    CheermoteState["static"] = "static";
})(CheermoteState = exports.CheermoteState || (exports.CheermoteState = {}));
/**
 * The scale of the cheermote, which usually relates to the pixel density of the device in use.
 */
var CheermoteScale;
(function (CheermoteScale) {
    /**
     * The cheermote should not be scaled.
     */
    CheermoteScale["x1"] = "1";
    /**
     * The cheermote should be scaled 1.5x.
     */
    CheermoteScale["x1_5"] = "1.5";
    /**
     * The cheermote should be scaled 2x.
     */
    CheermoteScale["x2"] = "2";
    /**
     * The cheermote should be scaled 3x.
     */
    CheermoteScale["x3"] = "3";
    /**
     * The cheermote should be scaled 4x.
     */
    CheermoteScale["x4"] = "4";
})(CheermoteScale = exports.CheermoteScale || (exports.CheermoteScale = {}));
/**
 * A list of cheermotes you can use globally or in a specific channel, depending on how you fetched the list.
 */
var CheermoteList = /** @class */ (function () {
    /** @private */
    function CheermoteList(data, client) {
        this._client = client;
        this._data = shared_utils_1.indexBy(data, function (action) { return action.prefix.toLowerCase(); });
    }
    /**
     * Gets the URL and color needed to properly represent a cheer of the given amount of bits with the given prefix.
     *
     * @param name The name/prefix of the cheermote.
     * @param bits The amount of bits cheered.
     * @param format The format of the cheermote you want to request.
     */
    CheermoteList.prototype.getCheermoteDisplayInfo = function (name, bits, format) {
        if (format === void 0) { format = {}; }
        name = name.toLowerCase();
        var cheermoteDefaults = this._client.cheermoteDefaults;
        var fullOptions = tslib_1.__assign({ background: cheermoteDefaults.defaultBackground, state: cheermoteDefaults.defaultState, scale: cheermoteDefaults.defaultScale }, format);
        var tiers = this._data[name].tiers;
        var correctTier = tiers.sort(function (a, b) { return b.min_bits - a.min_bits; }).find(function (tier) { return tier.min_bits <= bits; });
        if (!correctTier) {
            throw new HellFreezesOverError_1.default("Cheermote \"" + name + "\" does not have an applicable tier for " + bits + " bits");
        }
        return {
            url: correctTier.images[fullOptions.background][fullOptions.state][fullOptions.scale],
            color: correctTier.color
        };
    };
    /**
     * Gets all possible cheermote names.
     */
    CheermoteList.prototype.getPossibleNames = function () {
        return Object.keys(this._data);
    };
    /**
     * Parses all the cheermotes out of a message.
     *
     * @param message The message.
     */
    CheermoteList.prototype.parseMessage = function (message) {
        var result = [];
        var names = this.getPossibleNames();
        // TODO fix this regex so it works in firefox, which does not support lookbehind
        var re = new RegExp('(?<=^|\\s)([a-z0-9]+?)(\\d+)(?=\\s|$)', 'gi');
        var match;
        while ((match = re.exec(message))) {
            var name_1 = match[1].toLowerCase();
            if (names.includes(name_1)) {
                var amount = Number(match[2]);
                result.push({
                    name: name_1,
                    amount: amount,
                    position: shared_utils_1.utf8Length(message.substr(0, match.index)),
                    length: match[0].length,
                    displayInfo: this.getCheermoteDisplayInfo(name_1, amount)
                });
            }
        }
        return result;
    };
    /**
     * Transforms all the cheermotes in a message and returns an array of all the message parts.
     *
     * @param message The message.
     * @param transformer A function that transforms a message part into an arbitrary structure.
     */
    CheermoteList.prototype.transformCheerMessage = function (message, transformer) {
        var e_1, _a;
        var result = [];
        var currentPosition = 0;
        try {
            for (var _b = tslib_1.__values(this.parseMessage(message)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var foundCheermote = _c.value;
                if (currentPosition < foundCheermote.position) {
                    result.push(message.substring(currentPosition, foundCheermote.position));
                }
                result.push(transformer(foundCheermote));
                currentPosition = foundCheermote.position + foundCheermote.length;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (currentPosition < message.length) {
            result.push(message.substr(currentPosition));
        }
        return result;
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], CheermoteList.prototype, "_client", void 0);
    return CheermoteList;
}());
exports.default = CheermoteList;

},{"../../../Errors/HellFreezesOverError":315,"@d-fischer/shared-utils":36,"tslib":217}],279:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ChannelPlaceholder_1 = require("./ChannelPlaceholder");
/**
 * A Twitch Channel.
 */
var Channel = /** @class */ (function (_super) {
    tslib_1.__extends(Channel, _super);
    /** @private */
    function Channel(data, client) {
        var _this = _super.call(this, data._id, client) || this;
        _this._data = data;
        return _this;
    }
    // override parent's method so we avoid the API/cache request here if someone wrongly assumes this is a placeholder
    /** @private */
    Channel.prototype.getChannel = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this];
            });
        });
    };
    /**
     * Updates the game, title or delay of a channel or toggles the channel feed.
     */
    Channel.prototype.update = function (data) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.updateChannel(this, data)];
            });
        });
    };
    Object.defineProperty(Channel.prototype, "name", {
        /**
         * The name of the channel.
         */
        get: function () {
            return this._data.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "displayName", {
        /**
         * The display name of the channel, with proper capitalization or as Asian script.
         */
        get: function () {
            return this._data.display_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "broadcasterLanguage", {
        /**
         * The broadcaster's language.
         */
        get: function () {
            return this._data.broadcaster_language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "broadcasterType", {
        /**
         * The broadcaster's type, i.e. "partner", "affiliate" or "" (empty string, so neither of them).
         */
        get: function () {
            return this._data.broadcaster_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "creationDate", {
        /**
         * The date when the channel was created.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "description", {
        /**
         * The description of the channel.
         */
        get: function () {
            return this._data.description;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "followers", {
        /**
         * The number of people following the channel.
         */
        get: function () {
            return this._data.followers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "game", {
        /**
         * The game that is currently being played on the channel (or was played when it was last online).
         */
        get: function () {
            return this._data.game;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "language", {
        /**
         * The language of the channel.
         */
        get: function () {
            return this._data.language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "logo", {
        /**
         * The URL to the logo of the channel.
         */
        get: function () {
            return this._data.logo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "isMature", {
        /**
         * Whether the channel is flagged as suitable for mature audiences only.
         */
        get: function () {
            return this._data.mature;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "isPartner", {
        /**
         * Whether the channel is partnered.
         */
        get: function () {
            return this._data.partner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "profileBanner", {
        /**
         * The URL to the profile's banner image.
         */
        get: function () {
            return this._data.profile_banner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "profileBannerBackgroundColor", {
        /**
         * The background color of the profile's banner.
         */
        get: function () {
            return this._data.profile_banner_background_color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "status", {
        /**
         * The current status message (i.e. the title) of the channel.
         */
        get: function () {
            return this._data.status;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "updateDate", {
        /**
         * The date when the channel was last updated.
         */
        get: function () {
            return new Date(this._data.updated_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "url", {
        /**
         * The URL to the channel.
         */
        get: function () {
            return this._data.url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "videoBanner", {
        /**
         * The URL to the channel's video banner, i.e. the offline image.
         */
        get: function () {
            return this._data.video_banner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "views", {
        /**
         * The total number of views of the channel.
         */
        get: function () {
            return this._data.views;
        },
        enumerable: true,
        configurable: true
    });
    return Channel;
}(ChannelPlaceholder_1.default));
exports.default = Channel;

},{"./ChannelPlaceholder":282,"tslib":217}],280:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var cache_decorators_1 = require("@d-fischer/cache-decorators");
var HTTPStatusCodeError_1 = require("../../../Errors/HTTPStatusCodeError");
var NoSubscriptionProgramError_1 = require("../../../Errors/NoSubscriptionProgramError");
var UserTools_1 = require("../../../Toolkit/UserTools");
var BaseAPI_1 = require("../../BaseAPI");
var User_1 = require("../User/User");
var Channel_1 = require("./Channel");
var ChannelFollow_1 = require("./ChannelFollow");
var ChannelSubscription_1 = require("./ChannelSubscription");
var PrivilegedChannel_1 = require("./PrivilegedChannel");
/**
 * The API methods that deal with channels.
 *
 * Can be accessed using `client.kraken.channels` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const channel = await client.kraken.channels.getMyChannel();
 * ```
 */
var ChannelAPI = /** @class */ (function (_super) {
    tslib_1.__extends(ChannelAPI, _super);
    function ChannelAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Gets the channel the client is logged in to.
     */
    ChannelAPI.prototype.getMyChannel = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = PrivilegedChannel_1.default.bind;
                        return [4 /*yield*/, this._client.callAPI({ url: 'channel', scope: 'channel_read' })];
                    case 1: return [2 /*return*/, new (_a.apply(PrivilegedChannel_1.default, [void 0, _b.sent(),
                            this._client]))()];
                }
            });
        });
    };
    /**
     * Retrieves the channel for the given user.
     *
     * @param user The user you want to retrieve the channel for.
     */
    ChannelAPI.prototype.getChannel = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = Channel_1.default.bind;
                        return [4 /*yield*/, this._client.callAPI({ url: "channels/" + UserTools_1.extractUserId(user) })];
                    case 1: return [2 /*return*/, new (_a.apply(Channel_1.default, [void 0, _b.sent(), this._client]))()];
                }
            });
        });
    };
    /**
     * Updates the given channel with the given data.
     *
     * @param channel The channel you want to update.
     * @param data The updated channel data.
     */
    ChannelAPI.prototype.updateChannel = function (channel, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "channels/" + channelId,
                                method: 'PUT',
                                jsonBody: { channel: data },
                                scope: 'channel_editor'
                            })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves the list of users that have editor rights to the given channel.
     *
     * @param channel The channel you want to retrieve the list of editors for.
     */
    ChannelAPI.prototype.getChannelEditors = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "channels/" + channelId + "/editors",
                                scope: 'channel_read'
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.users.map(function (userData) { return new User_1.default(userData, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves the list of followers of the given channel.
     *
     * @param channel The channel you want to retrieve the list of followers of.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param orderDirection The direction to order in - ascending or descending.
     */
    ChannelAPI.prototype.getChannelFollowers = function (channel, page, limit, orderDirection) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        query = { limit: limit.toString() };
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        if (orderDirection) {
                            query.direction = orderDirection;
                        }
                        return [4 /*yield*/, this._client.callAPI({
                                url: "channels/" + channelId + "/follows",
                                query: query
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.follows.map(function (follow) { return new ChannelFollow_1.default(follow, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves the list of subscribers of the given channel.
     *
     * @param channel The channel you want to retrieve the list of subscribers of.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param orderDirection The direction to order in - ascending or descending.
     */
    ChannelAPI.prototype.getChannelSubscriptions = function (channel, page, limit, orderDirection) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getChannelSubscriptions(channel, page, limit, orderDirection)];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.subscriptions.map(function (sub) { return new ChannelSubscription_1.default(sub, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves the total number of subscribers for the given channel.
     *
     * @param channel The channel you want to retrieve the number of subscribers for.
     */
    ChannelAPI.prototype.getChannelSubscriptionCount = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getChannelSubscriptions(channel, 0, 1)];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data._total];
                }
            });
        });
    };
    /**
     * Retrieves the subscription data for the given user to a given channel.
     *
     * Throws if the channel doesn't have a subscription program or the user is not subscribed to it.
     *
     * This method requires access to the channel. If you only have access to the user,
     * use {@UserAPI#getSubscriptionData} instead.
     *
     * @param channel The channel to check the subscription to.
     * @param byUser The user to check the subscription for.
     */
    ChannelAPI.prototype.getChannelSubscriptionByUser = function (channel, byUser) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, userId, _a, e_1;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        userId = UserTools_1.extractUserId(byUser);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        _a = ChannelSubscription_1.default.bind;
                        return [4 /*yield*/, this._client.callAPI({
                                url: "channels/" + channelId + "/subscriptions/" + userId,
                                scope: 'channel_check_subscription'
                            })];
                    case 2: return [2 /*return*/, new (_a.apply(ChannelSubscription_1.default, [void 0, _b.sent(),
                            this._client]))()];
                    case 3:
                        e_1 = _b.sent();
                        if (e_1 instanceof HTTPStatusCodeError_1.default) {
                            if (e_1.statusCode === 404) {
                                return [2 /*return*/, null];
                            }
                            else if (e_1.statusCode === 422) {
                                throw new NoSubscriptionProgramError_1.default(channelId);
                            }
                        }
                        throw e_1;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Starts a commercial in the given channel.
     *
     * @param channel The channel to start the commercial in.
     * @param length The length of the commercial.
     */
    ChannelAPI.prototype.startChannelCommercial = function (channel, length) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId;
            return tslib_1.__generator(this, function (_a) {
                channelId = UserTools_1.extractUserId(channel);
                return [2 /*return*/, this._client.callAPI({
                        url: "channels/" + channelId + "/commercial",
                        method: 'POST',
                        jsonBody: { length: length },
                        scope: 'channel_commercial'
                    })];
            });
        });
    };
    /**
     * Resets the given channel's stream key.
     *
     * @param channel The channel to reset the stream key for.
     */
    ChannelAPI.prototype.resetChannelStreamKey = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId;
            return tslib_1.__generator(this, function (_a) {
                channelId = UserTools_1.extractUserId(channel);
                return [2 /*return*/, this._client.callAPI({
                        url: "channels/" + channelId + "/stream_key",
                        method: 'DELETE',
                        scope: 'channel_stream'
                    })];
            });
        });
    };
    ChannelAPI.prototype._getChannelSubscriptions = function (channel, page, limit, orderDirection) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, query, e_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        query = { limit: limit.toString() };
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        if (orderDirection) {
                            query.direction = orderDirection;
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "channels/" + channelId + "/subscriptions",
                                query: query,
                                scope: 'channel_subscriptions'
                            })];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        e_2 = _a.sent();
                        if (e_2 instanceof HTTPStatusCodeError_1.default && e_2.statusCode === 422) {
                            throw new NoSubscriptionProgramError_1.default(channelId);
                        }
                        throw e_2;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], ChannelAPI.prototype, "getMyChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], ChannelAPI.prototype, "getChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.ClearsCache('getChannel', 1)
    ], ChannelAPI.prototype, "updateChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], ChannelAPI.prototype, "getChannelEditors", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(30)
    ], ChannelAPI.prototype, "getChannelFollowers", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(30)
    ], ChannelAPI.prototype, "getChannelSubscriptions", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(30)
    ], ChannelAPI.prototype, "getChannelSubscriptionCount", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], ChannelAPI.prototype, "getChannelSubscriptionByUser", null);
    tslib_1.__decorate([
        cache_decorators_1.ClearsCache('getMyChannel')
    ], ChannelAPI.prototype, "resetChannelStreamKey", null);
    ChannelAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], ChannelAPI);
    return ChannelAPI;
}(BaseAPI_1.default));
exports.default = ChannelAPI;

},{"../../../Errors/HTTPStatusCodeError":314,"../../../Errors/NoSubscriptionProgramError":317,"../../../Toolkit/UserTools":320,"../../BaseAPI":241,"../User/User":299,"./Channel":279,"./ChannelFollow":281,"./ChannelSubscription":283,"./PrivilegedChannel":285,"@d-fischer/cache-decorators":6,"tslib":217}],281:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var User_1 = require("../User/User");
/**
 * A relation of a user following a previously given channel.
 */
var ChannelFollow = /** @class */ (function () {
    /** @private */
    function ChannelFollow(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChannelFollow.prototype, "user", {
        /**
         * The user following the given channel.
         */
        get: function () {
            return new User_1.default(this._data.user, this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChannelFollow.prototype, "hasNotifications", {
        /**
         * Whether the user has notifications enabled for the channel.
         */
        get: function () {
            return this._data.notifications;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChannelFollow.prototype, "followDate", {
        /**
         * The date when the user followed.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChannelFollow.prototype, "_client", void 0);
    return ChannelFollow;
}());
exports.default = ChannelFollow;

},{"../User/User":299,"@d-fischer/shared-utils":36,"tslib":217}],282:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var NoSubscriptionProgramError_1 = require("../../../Errors/NoSubscriptionProgramError");
/**
 * A placeholder for a channel.
 *
 * This is used for example when you only have retrieved user data, but not channel data.
 * This can do anything you can do with only a channel ID, as it's equivalent to the user ID.
 */
var ChannelPlaceholder = /** @class */ (function () {
    /** @private */
    function ChannelPlaceholder(id, client) {
        this._data = { _id: id };
        this._client = client;
    }
    Object.defineProperty(ChannelPlaceholder.prototype, "cacheKey", {
        /** @private */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChannelPlaceholder.prototype, "id", {
        /**
         * The ID of the channel.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the list of cheermotes you can use in the channel.
     */
    ChannelPlaceholder.prototype.getCheermotes = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.bits.getCheermotes(this)];
            });
        });
    };
    /**
     * Retrieves the channel data.
     */
    ChannelPlaceholder.prototype.getChannel = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannel(this)];
            });
        });
    };
    /**
     * Retrieves the channel's stream data.
     */
    ChannelPlaceholder.prototype.getStream = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.streams.getStreamByChannel(this)];
            });
        });
    };
    /**
     * Retrieves the channel's followers.
     */
    ChannelPlaceholder.prototype.getFollowers = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannelFollowers(this)];
            });
        });
    };
    /**
     * Retrieves the channel's subscribers.
     */
    ChannelPlaceholder.prototype.getSubscriptions = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannelSubscriptions(this)];
            });
        });
    };
    /**
     * Retrieves the subscription data for the given user to the channel.
     *
     * Throws if the channel doesn't have a subscription program or the user is not subscribed to it.
     *
     * This method requires access to the channel. If you only have access to the user,
     * use {@User#getSubscriptionTo} instead.
     *
     * @param user The user you want to get the subscription data for.
     */
    ChannelPlaceholder.prototype.getSubscriptionBy = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannelSubscriptionByUser(this, user)];
            });
        });
    };
    /**
     * Checks whether the given user is subscribed to the channel.
     *
     * @param user The user you want to check the subscription for.
     */
    ChannelPlaceholder.prototype.hasSubscriber = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.getSubscriptionBy(user)];
                    case 1: return [2 /*return*/, (_a.sent()) !== null];
                    case 2:
                        e_1 = _a.sent();
                        if (e_1 instanceof NoSubscriptionProgramError_1.default) {
                            return [2 /*return*/, false];
                        }
                        throw e_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChannelPlaceholder.prototype, "_client", void 0);
    return ChannelPlaceholder;
}());
exports.default = ChannelPlaceholder;

},{"../../../Errors/NoSubscriptionProgramError":317,"@d-fischer/shared-utils":36,"tslib":217}],283:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Subscription_1 = require("../Subscription");
var User_1 = require("../User/User");
/**
 * A relation of a user subscribing to a previously given channel.
 */
var ChannelSubscription = /** @class */ (function (_super) {
    tslib_1.__extends(ChannelSubscription, _super);
    function ChannelSubscription() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ChannelSubscription.prototype, "user", {
        /**
         * The user subscribing to the given channel.
         */
        get: function () {
            return new User_1.default(this._data.user, this._client);
        },
        enumerable: true,
        configurable: true
    });
    return ChannelSubscription;
}(Subscription_1.default));
exports.default = ChannelSubscription;

},{"../Subscription":294,"../User/User":299,"tslib":217}],284:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var cache_decorators_1 = require("@d-fischer/cache-decorators");
/**
 * A list of emotes, grouped into emote sets, that a user can use.
 */
var EmoteSetList = /** @class */ (function () {
    /** @private */
    function EmoteSetList(_data) {
        this._data = _data;
    }
    /**
     * Finds the emote ID for the given emote code.
     *
     * @param emoteCode The emote code to check for.
     */
    EmoteSetList.prototype.findEmoteId = function (emoteCode) {
        var e_1, _a, e_2, _b;
        try {
            for (var _c = tslib_1.__values(Object.values(this._data)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var emoteSet = _d.value;
                try {
                    for (var emoteSet_1 = (e_2 = void 0, tslib_1.__values(emoteSet)), emoteSet_1_1 = emoteSet_1.next(); !emoteSet_1_1.done; emoteSet_1_1 = emoteSet_1.next()) {
                        var emote = emoteSet_1_1.value;
                        if (new RegExp(emote.code).test(emoteCode)) {
                            return emote.id;
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (emoteSet_1_1 && !emoteSet_1_1.done && (_b = emoteSet_1.return)) _b.call(emoteSet_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return undefined;
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(Infinity, true)
    ], EmoteSetList.prototype, "findEmoteId", null);
    EmoteSetList = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], EmoteSetList);
    return EmoteSetList;
}());
exports.default = EmoteSetList;

},{"@d-fischer/cache-decorators":6,"tslib":217}],285:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Channel_1 = require("./Channel");
/**
 * A channel you have extended privileges for, i.e. the channel of the currently authenticated user.
 */
var PrivilegedChannel = /** @class */ (function (_super) {
    tslib_1.__extends(PrivilegedChannel, _super);
    function PrivilegedChannel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(PrivilegedChannel.prototype, "streamKey", {
        /**
         * The channel's stream key.
         */
        get: function () {
            return this._data.stream_key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivilegedChannel.prototype, "email", {
        /**
         * The channel's email address.
         */
        get: function () {
            return this._data.email;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the list of editors of the channel.
     */
    PrivilegedChannel.prototype.getEditors = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannelEditors(this)];
            });
        });
    };
    /**
     * Starts a commercial in the channel.
     *
     * @param length The length of the commercial.
     */
    PrivilegedChannel.prototype.startCommercial = function (length) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.startChannelCommercial(this, length)];
            });
        });
    };
    /**
     * Resets the given channel's stream key.
     */
    PrivilegedChannel.prototype.resetStreamKey = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelData, streamKey;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.kraken.channels.resetChannelStreamKey(this)];
                    case 1:
                        channelData = _a.sent();
                        streamKey = channelData.stream_key;
                        this._data.stream_key = streamKey;
                        return [2 /*return*/, streamKey];
                }
            });
        });
    };
    return PrivilegedChannel;
}(Channel_1.default));
exports.default = PrivilegedChannel;

},{"./Channel":279,"tslib":217}],286:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var cache_decorators_1 = require("@d-fischer/cache-decorators");
var UserTools_1 = require("../../../Toolkit/UserTools");
var BaseAPI_1 = require("../../BaseAPI");
var ChatEmoteList_1 = require("./ChatEmoteList");
var ChatRoom_1 = require("./ChatRoom");
/**
 * The API methods that deal with chat and chatrooms.
 *
 * Can be accessed using `client.kraken.chat` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const channel = await client.kraken.chat.getBadges('125328655');
 * ```
 */
var ChatAPI = /** @class */ (function (_super) {
    tslib_1.__extends(ChatAPI, _super);
    function ChatAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of emotes for a given list of enote set IDs.
     *
     * @param emotesets The list of emote set IDs, either as array of strings or as a comma separated string.
     */
    ChatAPI.prototype.getEmotesBySets = function (emotesets) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (typeof emotesets !== 'string') {
                            emotesets = emotesets.join(',');
                        }
                        return [4 /*yield*/, this._client.callAPI({
                                url: 'chat/emoticon_images',
                                query: {
                                    emotesets: emotesets
                                }
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new ChatEmoteList_1.default(data.emoticons, this._client)];
                }
            });
        });
    };
    /**
     * Retrieves a list of chat rooms for a given channel.
     *
     * @param channel The channel to retrieve the chat rooms of.
     */
    ChatAPI.prototype.getChatRoomsForChannel = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({
                            url: "chat/" + UserTools_1.extractUserId(channel) + "/rooms"
                        })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.rooms.map(function (room) { return new ChatRoom_1.default(room, _this._client); })];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], ChatAPI.prototype, "getEmotesBySets", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], ChatAPI.prototype, "getChatRoomsForChannel", null);
    ChatAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], ChatAPI);
    return ChatAPI;
}(BaseAPI_1.default));
exports.default = ChatAPI;

},{"../../../Toolkit/UserTools":320,"../../BaseAPI":241,"./ChatEmoteList":288,"./ChatRoom":289,"@d-fischer/cache-decorators":6,"tslib":217}],287:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
/**
 * A chat emote.
 */
var ChatEmote = /** @class */ (function () {
    /** @private */
    function ChatEmote(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChatEmote.prototype, "id", {
        /**
         * The emote ID.
         */
        get: function () {
            return this._data.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatEmote.prototype, "code", {
        /**
         * The emote code, i.e. how you write it in chat.
         */
        get: function () {
            return this._data.code;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatEmote.prototype, "setId", {
        /**
         * The ID of the emote set.
         */
        get: function () {
            return this._data.emoticon_set;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatEmote.prototype, "_client", void 0);
    return ChatEmote;
}());
exports.default = ChatEmote;

},{"@d-fischer/shared-utils":36,"tslib":217}],288:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var cache_decorators_1 = require("@d-fischer/cache-decorators");
var shared_utils_1 = require("@d-fischer/shared-utils");
var ChatEmote_1 = require("./ChatEmote");
/**
 * A list of emotes.
 */
var ChatEmoteList = /** @class */ (function () {
    /** @private */
    function ChatEmoteList(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChatEmoteList.prototype, "emotes", {
        /**
         * A list of all emotes in the list.
         */
        get: function () {
            var _this = this;
            return this._data.map(function (emote) { return new ChatEmote_1.default(emote, _this._client); });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets all emotes from the list that are from a given emote set.
     *
     * @param setId
     */
    ChatEmoteList.prototype.getAllFromSet = function (setId) {
        var _this = this;
        return this._data
            .filter(function (emote) { return emote.emoticon_set === setId; })
            .map(function (emote) { return new ChatEmote_1.default(emote, _this._client); });
    };
    /**
     * Finds a single emote by its ID.
     *
     * @param id
     */
    ChatEmoteList.prototype.getById = function (id) {
        var data = this._data.find(function (emote) { return emote.id === id; });
        return data ? new ChatEmote_1.default(data, this._client) : null;
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatEmoteList.prototype, "_client", void 0);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], ChatEmoteList.prototype, "emotes", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached()
    ], ChatEmoteList.prototype, "getAllFromSet", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached()
    ], ChatEmoteList.prototype, "getById", null);
    ChatEmoteList = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], ChatEmoteList);
    return ChatEmoteList;
}());
exports.default = ChatEmoteList;

},{"./ChatEmote":287,"@d-fischer/cache-decorators":6,"@d-fischer/shared-utils":36,"tslib":217}],289:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/** @private */
var shared_utils_1 = require("@d-fischer/shared-utils");
var ChatRoom = /** @class */ (function () {
    /** @private */
    function ChatRoom(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChatRoom.prototype, "id", {
        /**
         * The ID of the chat room.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatRoom.prototype, "ownerId", {
        /**
         * The user ID of the chat room owner.
         */
        get: function () {
            return this._data.owner_id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the user data of the chat room owner.
     */
    ChatRoom.prototype.getOwner = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.getUser(this._data.owner_id)];
            });
        });
    };
    Object.defineProperty(ChatRoom.prototype, "name", {
        /**
         * The name of the chat room.
         */
        get: function () {
            return this._data.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatRoom.prototype, "topic", {
        /**
         * The topic of the chat room.
         */
        get: function () {
            return this._data.topic;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatRoom.prototype, "isPreviewable", {
        /**
         * Whether the chat room is previewable.
         */
        get: function () {
            return this._data.is_previewable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatRoom.prototype, "minRole", {
        /**
         * The minimum role allowed to enter this chat room.
         */
        get: function () {
            return this._data.minimum_allowed_role;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChatRoom.prototype, "ircName", {
        /**
         * The name of the IRC channel that corresponds to this chat room.
         */
        get: function () {
            return "#chatrooms:" + this._data.owner_id + ":" + this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChatRoom.prototype, "_client", void 0);
    return ChatRoom;
}());
exports.default = ChatRoom;

},{"@d-fischer/shared-utils":36,"tslib":217}],290:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var cache_decorators_1 = require("@d-fischer/cache-decorators");
var BaseAPI_1 = require("../BaseAPI");
var BitsAPI_1 = require("./Bits/BitsAPI");
var ChannelAPI_1 = require("./Channel/ChannelAPI");
var ChatAPI_1 = require("./Chat/ChatAPI");
var SearchAPI_1 = require("./Search/SearchAPI");
var StreamAPI_1 = require("./Stream/StreamAPI");
var TeamAPI_1 = require("./Team/TeamAPI");
var UserAPI_1 = require("./User/UserAPI");
/**
 * Groups all API calls available in Kraken v5.
 *
 * Can be accessed using {@TwitchClient#kraken}.
 */
var KrakenAPIGroup = /** @class */ (function (_super) {
    tslib_1.__extends(KrakenAPIGroup, _super);
    function KrakenAPIGroup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(KrakenAPIGroup.prototype, "bits", {
        /**
         * The API methods that deal with bits.
         */
        get: function () {
            return new BitsAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KrakenAPIGroup.prototype, "channels", {
        /**
         * The API methods that deal with channels.
         */
        get: function () {
            return new ChannelAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KrakenAPIGroup.prototype, "chat", {
        /**
         * The API methods that deal with chat.
         */
        get: function () {
            return new ChatAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KrakenAPIGroup.prototype, "search", {
        /**
         * The API methods that deal with searching.
         */
        get: function () {
            return new SearchAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KrakenAPIGroup.prototype, "streams", {
        /**
         * The API methods that deal with streams.
         */
        get: function () {
            return new StreamAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KrakenAPIGroup.prototype, "users", {
        /**
         * The API methods that deal with users.
         */
        get: function () {
            return new UserAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(KrakenAPIGroup.prototype, "teams", {
        /**
         * The API methods that deal with teams.
         */
        get: function () {
            return new TeamAPI_1.default(this._client);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "bits", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "channels", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "chat", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "search", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "streams", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "users", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], KrakenAPIGroup.prototype, "teams", null);
    KrakenAPIGroup = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], KrakenAPIGroup);
    return KrakenAPIGroup;
}(BaseAPI_1.default));
exports.default = KrakenAPIGroup;

},{"../BaseAPI":241,"./Bits/BitsAPI":277,"./Channel/ChannelAPI":280,"./Chat/ChatAPI":286,"./Search/SearchAPI":291,"./Stream/StreamAPI":293,"./Team/TeamAPI":296,"./User/UserAPI":300,"@d-fischer/cache-decorators":6,"tslib":217}],291:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var cache_decorators_1 = require("@d-fischer/cache-decorators");
var BaseAPI_1 = require("../../BaseAPI");
var Channel_1 = require("../Channel/Channel");
var Stream_1 = require("../Stream/Stream");
/**
 * The API methods that deal with searching.
 *
 * Can be accessed using `client.kraken.search` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const channel = await client.kraken.search.searchStreams('Hearthstone');
 * ```
 */
var SearchAPI = /** @class */ (function (_super) {
    tslib_1.__extends(SearchAPI, _super);
    function SearchAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of channels that match the given search term.
     *
     * @param term The term you want to search for.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    SearchAPI.prototype.searchChannels = function (term, page, limit) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = { query: term, limit: limit.toString() };
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        return [4 /*yield*/, this._client.callAPI({ url: 'search/channels', query: query })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.channels.map(function (channelData) { return new Channel_1.default(channelData, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves a list of streams that match the given search term.
     *
     * @param term The term you want to search for.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param hls Whether you want only HLS or only non-HLS (RTMP) streams. If not set, finds both types of streams.
     */
    SearchAPI.prototype.searchStreams = function (term, page, limit, hls) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = { query: term, limit: limit.toString() };
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        if (hls !== undefined) {
                            query.hls = hls.toString();
                        }
                        return [4 /*yield*/, this._client.callAPI({ url: 'search/streams', query: query })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.streams.map(function (streamData) { return new Stream_1.default(streamData, _this._client); })];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(300)
    ], SearchAPI.prototype, "searchChannels", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(300)
    ], SearchAPI.prototype, "searchStreams", null);
    SearchAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], SearchAPI);
    return SearchAPI;
}(BaseAPI_1.default));
exports.default = SearchAPI;

},{"../../BaseAPI":241,"../Channel/Channel":279,"../Stream/Stream":292,"@d-fischer/cache-decorators":6,"tslib":217}],292:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var Channel_1 = require("../Channel/Channel");
/**
 * The type of a stream.
 */
var StreamType;
(function (StreamType) {
    /**
     * A live stream.
     */
    StreamType["Live"] = "live";
    /**
     * An upload to the channel (VoD) that is streamed live for the first time.
     */
    StreamType["Premiere"] = "premiere";
    /**
     * A rerun of a past live stream.
     */
    StreamType["ReRun"] = "rerun";
    /**
     * All types of streams. Used for filtering.
     */
    StreamType["All"] = "all";
})(StreamType = exports.StreamType || (exports.StreamType = {}));
/**
 * A Twitch stream.
 */
var Stream = /** @class */ (function () {
    /** @private */
    function Stream(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(Stream.prototype, "id", {
        /**
         * The ID of the stream.
         */
        get: function () {
            return this._data._id.toString();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "game", {
        /**
         * The game played on the stream.
         */
        get: function () {
            return this._data.game;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "viewers", {
        /**
         * The current number of concurrent viewers.
         */
        get: function () {
            return this._data.viewers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "videoHeight", {
        /**
         * The height of the stream video.
         */
        get: function () {
            return this._data.video_height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "averageFPS", {
        /**
         * The average FPS (frames per second) that are shown on the stream.
         */
        get: function () {
            return this._data.average_fps;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "delay", {
        /**
         * The delay of the stream, in seconds.
         */
        get: function () {
            return this._data.delay;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "startDate", {
        /**
         * The time when the stream started.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "isPlaylist", {
        /**
         * Whether the stream is running a playlist.
         */
        get: function () {
            return this._data.is_playlist;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "type", {
        /**
         * The type of the stream.
         */
        get: function () {
            return this._data.stream_type;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Gets the URL of a preview image for the stream
     *
     * @param size The size of the image.
     */
    Stream.prototype.getPreviewUrl = function (size) {
        return this._data.preview[size];
    };
    Object.defineProperty(Stream.prototype, "channel", {
        /**
         * The channel where the stream is shown.
         */
        get: function () {
            return new Channel_1.default(this._data.channel, this._client);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], Stream.prototype, "_client", void 0);
    return Stream;
}());
exports.default = Stream;

},{"../Channel/Channel":279,"@d-fischer/shared-utils":36,"tslib":217}],293:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var cache_decorators_1 = require("@d-fischer/cache-decorators");
var UserTools_1 = require("../../../Toolkit/UserTools");
var BaseAPI_1 = require("../../BaseAPI");
var Stream_1 = require("./Stream");
/**
 * The API methods that deal with streams.
 *
 * Can be accessed using `client.kraken.streams` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const stream = await client.kraken.streams.getStreamByChannel('125328655');
 * ```
 */
var StreamAPI = /** @class */ (function (_super) {
    tslib_1.__extends(StreamAPI, _super);
    function StreamAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves the current stream on the given channel.
     *
     * @param channel
     */
    StreamAPI.prototype.getStreamByChannel = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        return [4 /*yield*/, this._client.callAPI({ url: "streams/" + channelId })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.stream ? new Stream_1.default(data.stream, this._client) : null];
                }
            });
        });
    };
    /**
     * Retrieves a list of streams.
     *
     * @param channels A channel ID or a list thereof.
     * @param game Show only streams playing a certain game.
     * @param languageCode Show only streams in a certain language.
     * @param type Show only streams of a certain type.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    StreamAPI.prototype.getStreams = function (channels, game, languageCode, type, page, limit) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = { limit: limit.toString() };
                        if (channels) {
                            query.channel = typeof channels === 'string' ? channels : channels.join(',');
                        }
                        if (game) {
                            query.game = game;
                        }
                        if (languageCode) {
                            query.broadcaster_language = languageCode;
                        }
                        if (type) {
                            query.stream_type = type;
                        }
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        return [4 /*yield*/, this._client.callAPI({ url: 'streams', query: query })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.streams.map(function (streamData) { return new Stream_1.default(streamData, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves a list of all streams.
     *
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    StreamAPI.prototype.getAllStreams = function (page, limit) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.getStreams(undefined, undefined, undefined, Stream_1.StreamType.All, page, limit)];
            });
        });
    };
    /**
     * Retrieves a list of all live streams.
     *
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    StreamAPI.prototype.getAllLiveStreams = function (page, limit) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.getStreams(undefined, undefined, undefined, Stream_1.StreamType.Live, page, limit)];
            });
        });
    };
    /**
     * Retrieves a list of all streams on channels the currently authenticated user is following.
     *
     * @param type Show only streams of a certain type.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    StreamAPI.prototype.getFollowedStreams = function (type, page, limit) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = { limit: limit.toString() };
                        if (type) {
                            query.type = type;
                        }
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        return [4 /*yield*/, this._client.callAPI({
                                url: 'streams/followed',
                                query: query,
                                scope: 'user_read'
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.streams.map(function (streamData) { return new Stream_1.default(streamData, _this._client); })];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(60)
    ], StreamAPI.prototype, "getStreamByChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(60)
    ], StreamAPI.prototype, "getFollowedStreams", null);
    StreamAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], StreamAPI);
    return StreamAPI;
}(BaseAPI_1.default));
exports.default = StreamAPI;

},{"../../../Toolkit/UserTools":320,"../../BaseAPI":241,"./Stream":292,"@d-fischer/cache-decorators":6,"tslib":217}],294:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
/**
 * A subscription to a Twitch channel.
 */
var Subscription = /** @class */ (function () {
    /** @private */
    function Subscription(/** @private */ _data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(Subscription.prototype, "id", {
        /**
         * The ID of the subscription.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Subscription.prototype, "subPlan", {
        /**
         * The identifier of the subscription plan.
         */
        get: function () {
            return this._data.sub_plan;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Subscription.prototype, "subPlanName", {
        /**
         * The name of the subscription plan.
         */
        get: function () {
            return this._data.sub_plan_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Subscription.prototype, "startDate", {
        /**
         * The date when the subscription was started.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], Subscription.prototype, "_client", void 0);
    return Subscription;
}());
exports.default = Subscription;

},{"@d-fischer/shared-utils":36,"tslib":217}],295:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
/**
 * A Twitch team.
 */
var Team = /** @class */ (function () {
    /** @private */
    function Team(/** @private */ _data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(Team.prototype, "id", {
        /**
         * The ID of the team.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "background", {
        /**
         * The background url of the team.
         */
        get: function () {
            return this._data.background;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "banner", {
        /**
         * The banner url of the team.
         */
        get: function () {
            return this._data.banner;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "creationDate", {
        /**
         * The date when the team was created.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "updateDate", {
        /**
         * The last date when the team changed anything.
         */
        get: function () {
            return new Date(this._data.updated_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "name", {
        /**
         * The name of the team.
         */
        get: function () {
            return this._data.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "info", {
        /**
         * The info of the team.
         */
        get: function () {
            return this._data.info;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "displayName", {
        /**
         * The display name of the team.
         */
        get: function () {
            return this._data.display_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Team.prototype, "logoUrl", {
        /**
         * The URL to the profile picture of the team.
         */
        get: function () {
            return this._data.logo;
        },
        enumerable: true,
        configurable: true
    });
    Team.prototype.getUsers = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var team;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.kraken.teams.getTeamByName(this.name)];
                    case 1:
                        team = _a.sent();
                        return [2 /*return*/, team.getUsers()];
                }
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], Team.prototype, "_client", void 0);
    return Team;
}());
exports.default = Team;

},{"@d-fischer/shared-utils":36,"tslib":217}],296:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var cache_decorators_1 = require("@d-fischer/cache-decorators");
var BaseAPI_1 = require("../../BaseAPI");
var Team_1 = require("./Team");
var TeamWithUsers_1 = require("./TeamWithUsers");
/**
 * The API methods that deal with teams.
 *
 * Can be accessed using `client.kraken.teams` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const team = await client.kraken.teams.getTeamByName('staff');
 * ```
 */
var TeamAPI = /** @class */ (function (_super) {
    tslib_1.__extends(TeamAPI, _super);
    function TeamAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Get a list of teams.
     *
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    TeamAPI.prototype.getTeams = function (page, limit) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        query = {};
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        query.limit = limit.toString();
                        return [4 /*yield*/, this._client.callAPI({
                                url: 'teams',
                                query: query
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.teams.map(function (team) { return new Team_1.default(team, _this._client); })];
                }
            });
        });
    };
    /**
     * Retrieves the team data for the given team name.
     *
     * @param team The team name you want to look up.
     */
    TeamAPI.prototype.getTeamByName = function (team) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var teamData;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({ url: "teams/" + team })];
                    case 1:
                        teamData = _a.sent();
                        return [2 /*return*/, new TeamWithUsers_1.default(teamData, this._client)];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], TeamAPI.prototype, "getTeams", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], TeamAPI.prototype, "getTeamByName", null);
    TeamAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], TeamAPI);
    return TeamAPI;
}(BaseAPI_1.default));
exports.default = TeamAPI;

},{"../../BaseAPI":241,"./Team":295,"./TeamWithUsers":297,"@d-fischer/cache-decorators":6,"tslib":217}],297:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Team_1 = require("./Team");
var User_1 = require("../User/User");
var TeamWithUsers = /** @class */ (function (_super) {
    tslib_1.__extends(TeamWithUsers, _super);
    function TeamWithUsers() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * The list of users in the team.
     */
    TeamWithUsers.prototype.getUsers = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._data.users.map(function (data) { return new User_1.default(data, _this._client); })];
            });
        });
    };
    return TeamWithUsers;
}(Team_1.default));
exports.default = TeamWithUsers;

},{"../User/User":299,"./Team":295,"tslib":217}],298:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var User_1 = require("./User");
/**
 * A user you have extended privileges for, i.e. the currently authenticated user.
 *
 * @inheritDoc
 */
var PrivilegedUser = /** @class */ (function (_super) {
    tslib_1.__extends(PrivilegedUser, _super);
    function PrivilegedUser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(PrivilegedUser.prototype, "email", {
        /**
         * The user's email address.
         */
        get: function () {
            return this._data.email;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivilegedUser.prototype, "isEmailVerified", {
        /**
         * Whether the user's email address is verified.
         */
        get: function () {
            return this._data.email_verified;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivilegedUser.prototype, "hasEmailNotifications", {
        /**
         * Whether the user has email notifications enabled.
         */
        get: function () {
            return this._data.notifications.email;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivilegedUser.prototype, "hasPushNotifications", {
        /**
         * Whether the user has push notifications enabled.
         */
        get: function () {
            return this._data.notifications.push;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivilegedUser.prototype, "isPartnered", {
        /**
         * Whether the user is partnered.
         */
        get: function () {
            return this._data.partnered;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrivilegedUser.prototype, "hasTwitter", {
        /**
         * Whether the user has a Twitter account connected.
         */
        get: function () {
            return this._data.twitter_connected;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Follows a channel.
     *
     * @param channel The channel to follow.
     * @param notifications Whether the user will receive notifications.
     */
    PrivilegedUser.prototype.followChannel = function (channel, notifications) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.followChannel(this, channel, notifications)];
            });
        });
    };
    /**
     * Unfollows a channel.
     *
     * @param channel The channel to unfollow.
     */
    PrivilegedUser.prototype.unfollowChannel = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.unfollowChannel(this, channel)];
            });
        });
    };
    /**
     * Blocks a user.
     *
     * @param userToBlock The user to block.
     */
    PrivilegedUser.prototype.blockUser = function (userToBlock) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.blockUser(this, userToBlock)];
            });
        });
    };
    /**
     * Unblocks a user.
     *
     * @param userToUnblock The user to unblock.
     */
    PrivilegedUser.prototype.unblockUser = function (userToUnblock) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.unblockUser(this, userToUnblock)];
            });
        });
    };
    return PrivilegedUser;
}(User_1.default));
exports.default = PrivilegedUser;

},{"./User":299,"tslib":217}],299:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var NoSubscriptionProgramError_1 = require("../../../Errors/NoSubscriptionProgramError");
var ChannelPlaceholder_1 = require("../Channel/ChannelPlaceholder");
/**
 * A Twitch user.
 */
var User = /** @class */ (function () {
    /** @private */
    function User(/** @private */ _data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(User.prototype, "cacheKey", {
        /** @private */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "id", {
        /**
         * The ID of the user.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "bio", {
        /**
         * The bio of the user.
         */
        get: function () {
            return this._data.bio;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "creationDate", {
        /**
         * The date when the user was created, i.e. when they registered on Twitch.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "updateDate", {
        /**
         * The last date when the user changed anything in their profile, e.g. their description or their profile picture.
         */
        get: function () {
            return new Date(this._data.updated_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "name", {
        /**
         * The user name of the user.
         */
        get: function () {
            return this._data.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "displayName", {
        /**
         * The display name of the user.
         */
        get: function () {
            return this._data.display_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "logoUrl", {
        /**
         * The URL to the profile picture of the user.
         */
        get: function () {
            return this._data.logo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(User.prototype, "type", {
        /**
         * The type of the user.
         */
        get: function () {
            return this._data.type;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves the channel data of the user.
     */
    User.prototype.getChannel = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.channels.getChannel(this)];
            });
        });
    };
    /**
     * Gets a channel placeholder object for the user, which can do anything you can do to a channel with just the ID.
     */
    User.prototype.getChannelPlaceholder = function () {
        return new ChannelPlaceholder_1.default(this._data._id, this._client);
    };
    /**
     * Retrieves the currently running stream of the user.
     */
    User.prototype.getStream = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this.getChannelPlaceholder().getStream()];
            });
        });
    };
    /**
     * Retrieves the subscription data for the user to the given channel.
     *
     * Throws if the channel doesn't have a subscription program or the user is not subscribed to it.
     *
     * This method requires access to the user. If you only have access to the channel,
     * use {@ChannelPlaceholder#getSubscriptionBy} instead.
     *
     * @param channel The channel you want to get the subscription data for.
     */
    User.prototype.getSubscriptionTo = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.getSubscriptionData(this, channel)];
            });
        });
    };
    /**
     * Checks whether the user is subscribed to the given channel.
     *
     * @param channel The channel you want to check the subscription for.
     */
    User.prototype.isSubscribedTo = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.getSubscriptionTo(channel)];
                    case 1: return [2 /*return*/, (_a.sent()) !== null];
                    case 2:
                        e_1 = _a.sent();
                        if (e_1 instanceof NoSubscriptionProgramError_1.default) {
                            return [2 /*return*/, false];
                        }
                        throw e_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves a list of channels followed by the user.
     *
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param orderBy The field to order by.
     * @param orderDirection The direction to order in - ascending or descending.
     */
    User.prototype.getFollows = function (page, limit, orderBy, orderDirection) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.getFollowedChannels(this, page, limit, orderBy, orderDirection)];
            });
        });
    };
    /**
     * Retrieves the follow data of the user to a given channel.
     *
     * @param channel The channel to retrieve the follow data for.
     */
    User.prototype.getFollowTo = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.getFollowedChannel(this, channel)];
            });
        });
    };
    /**
     * Checks whether the user is following the given channel.
     *
     * @param channel The channel to check for the user's follow.
     */
    User.prototype.follows = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var e_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.getFollowTo(channel)];
                    case 1: return [2 /*return*/, (_a.sent()) !== null];
                    case 2:
                        e_2 = _a.sent();
                        throw e_2;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Follows the channel with the authenticated user.
     */
    User.prototype.follow = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var currentUser;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.kraken.users.getMe()];
                    case 1:
                        currentUser = _a.sent();
                        return [2 /*return*/, currentUser.followChannel(this)];
                }
            });
        });
    };
    /**
     * Unfollows the channel with the authenticated user.
     */
    User.prototype.unfollow = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var currentUser;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.kraken.users.getMe()];
                    case 1:
                        currentUser = _a.sent();
                        return [2 /*return*/, currentUser.unfollowChannel(this)];
                }
            });
        });
    };
    /**
     * Retrieves the emotes the user can use.
     */
    User.prototype.getEmotes = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.getUserEmotes(this)];
            });
        });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], User.prototype, "_client", void 0);
    return User;
}());
exports.default = User;

},{"../../../Errors/NoSubscriptionProgramError":317,"../Channel/ChannelPlaceholder":282,"@d-fischer/shared-utils":36,"tslib":217}],300:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var cache_decorators_1 = require("@d-fischer/cache-decorators");
var shared_utils_1 = require("@d-fischer/shared-utils");
var HellFreezesOverError_1 = require("../../../Errors/HellFreezesOverError");
var HTTPStatusCodeError_1 = require("../../../Errors/HTTPStatusCodeError");
var NoSubscriptionProgramError_1 = require("../../../Errors/NoSubscriptionProgramError");
var UserTools_1 = require("../../../Toolkit/UserTools");
var BaseAPI_1 = require("../../BaseAPI");
var EmoteSetList_1 = require("../Channel/EmoteSetList");
var PrivilegedUser_1 = require("./PrivilegedUser");
var User_1 = require("./User");
var UserBlock_1 = require("./UserBlock");
var UserChatInfo_1 = require("./UserChatInfo");
var UserFollow_1 = require("./UserFollow");
var UserSubscription_1 = require("./UserSubscription");
/**
 * The API methods that deal with users.
 *
 * Can be accessed using `client.kraken.users` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const user = await client.kraken.users.getUser('125328655');
 * ```
 */
var UserAPI = /** @class */ (function (_super) {
    tslib_1.__extends(UserAPI, _super);
    function UserAPI() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._userByNameCache = new Map();
        return _this;
    }
    /**
     * Retrieves the user data of the currently authenticated user.
     */
    UserAPI.prototype.getMe = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = PrivilegedUser_1.default.bind;
                        return [4 /*yield*/, this._client.callAPI({ url: 'user', scope: 'user_read' })];
                    case 1: return [2 /*return*/, new (_a.apply(PrivilegedUser_1.default, [void 0, _b.sent(), this._client]))()];
                }
            });
        });
    };
    /**
     * Retrieves the user data for the given user ID.
     *
     * @param userId The user ID you want to look up.
     */
    UserAPI.prototype.getUser = function (userId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userData;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._client.callAPI({ url: "users/" + UserTools_1.extractUserId(userId) })];
                    case 1:
                        userData = _a.sent();
                        if (!userData) {
                            throw new HellFreezesOverError_1.default('Could not get authenticated user');
                        }
                        return [2 /*return*/, new User_1.default(userData, this._client)];
                }
            });
        });
    };
    /**
     * Retrieves the user data for the given user name.
     *
     * @param userName The user name you want to look up.
     */
    UserAPI.prototype.getUserByName = function (userName) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var users, user;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // not using the decorator's cache here as users-by-name is slightly more complex to cache
                        this._cleanUserCache();
                        if (this._userByNameCache.has(userName)) {
                            return [2 /*return*/, this._userByNameCache.get(userName).value];
                        }
                        return [4 /*yield*/, this._client.callAPI({ url: 'users', query: { login: userName } })];
                    case 1:
                        users = (_a.sent()).users;
                        if (users.length === 0) {
                            return [2 /*return*/, null];
                        }
                        user = new User_1.default(users[0], this._client);
                        this._userByNameCache.set(userName, {
                            value: user,
                            expires: Date.now() + 3600 * 1000
                        });
                        return [2 /*return*/, user];
                }
            });
        });
    };
    /**
     * Retrieves the user data for the given user names.
     *
     * @param userNames The user names you want to look up.
     */
    UserAPI.prototype.getUsersByNames = function (userNames) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var cachedEntries, cachedObject, cachedUsers, toFetch, usersData, usersArr, users;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._cleanUserCache();
                        userNames = userNames.map(function (name) { return name.toLowerCase(); });
                        cachedEntries = Array.from(this._userByNameCache.entries()).filter(function (_a) {
                            var _b = tslib_1.__read(_a, 1), key = _b[0];
                            return userNames.includes(key);
                        });
                        cachedObject = shared_utils_1.entriesToObject(cachedEntries);
                        cachedUsers = shared_utils_1.mapObject(cachedObject, function (entry) { return entry.value; });
                        toFetch = userNames.filter(function (name) { return !(name in cachedUsers); });
                        if (!toFetch.length) {
                            return [2 /*return*/, cachedUsers];
                        }
                        return [4 /*yield*/, this._client.callAPI({ url: 'users', query: { login: toFetch.join(',') } })];
                    case 1:
                        usersData = _a.sent();
                        usersArr = usersData.users.map(function (data) { return new User_1.default(data, _this._client); });
                        usersArr.forEach(function (user) {
                            return _this._userByNameCache.set(user.name, {
                                value: user,
                                expires: Date.now() + 3600 * 1000
                            });
                        });
                        users = shared_utils_1.indexBy(usersArr, 'name');
                        return [2 /*return*/, tslib_1.__assign(tslib_1.__assign({}, cachedUsers), users)];
                }
            });
        });
    };
    /**
     * Retrieves information about the user's chat appearance and privileges.
     *
     * @param user The user you want to get chat info for.
     */
    UserAPI.prototype.getChatInfo = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        return [4 /*yield*/, this._client.callAPI({ url: "users/" + userId + "/chat" })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new UserChatInfo_1.default(data, this._client)];
                }
            });
        });
    };
    /**
     * Retrieves the emotes a given user can use.
     *
     * @param user The user you want to get emotes for.
     */
    UserAPI.prototype.getUserEmotes = function (user) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        return [4 /*yield*/, this._client.callAPI({ url: "users/" + userId + "/emotes", scope: 'user_subscriptions' })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new EmoteSetList_1.default(data.emoticon_sets)];
                }
            });
        });
    };
    /**
     * Retrieves the subscription data for a given user to a given channel.
     *
     * @param user The user to retrieve the subscription data of.
     * @param toChannel The channel you want to retrieve the subscription data to.
     */
    UserAPI.prototype.getSubscriptionData = function (user, toChannel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, channelId, _a, e_1;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        channelId = UserTools_1.extractUserId(toChannel);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        _a = UserSubscription_1.default.bind;
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/subscriptions/" + channelId,
                                scope: 'user_subscriptions'
                            })];
                    case 2: return [2 /*return*/, new (_a.apply(UserSubscription_1.default, [void 0, _b.sent(),
                            this._client]))()];
                    case 3:
                        e_1 = _b.sent();
                        if (e_1 instanceof HTTPStatusCodeError_1.default) {
                            if (e_1.statusCode === 404) {
                                return [2 /*return*/, null];
                            }
                            else if (e_1.statusCode === 422) {
                                throw new NoSubscriptionProgramError_1.default(channelId);
                            }
                        }
                        throw e_1;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get a list of channels a given user follows.
     *
     * @param user The user you want to retrieve the follows of.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     * @param orderBy The field to order by.
     * @param orderDirection The direction to order in - ascending or descending.
     */
    UserAPI.prototype.getFollowedChannels = function (user, page, limit, orderBy, orderDirection) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        query = {};
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        query.limit = limit.toString();
                        if (orderBy) {
                            query.sortby = orderBy;
                        }
                        if (orderDirection) {
                            query.direction = orderDirection;
                        }
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/follows/channels",
                                query: query
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.follows.map(function (follow) { return new UserFollow_1.default(follow, _this._client); })];
                }
            });
        });
    };
    /**
     * Get follow data for a given user to a given channel.
     *
     * @param user The user you want to retrieve follow data of.
     * @param channel The channel you want to retrieve follow data to.
     */
    UserAPI.prototype.getFollowedChannel = function (user, channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, channelId, data, e_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        channelId = UserTools_1.extractUserId(channel);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this._client.callAPI({ url: "users/" + userId + "/follows/channels/" + channelId })];
                    case 2:
                        data = _a.sent();
                        return [2 /*return*/, new UserFollow_1.default(data, this._client)];
                    case 3:
                        e_2 = _a.sent();
                        if (e_2 instanceof HTTPStatusCodeError_1.default) {
                            if (e_2.statusCode === 404) {
                                return [2 /*return*/, null];
                            }
                        }
                        throw e_2;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Follows a given channel with a given user.
     *
     * @param user The user you want to follow with.
     * @param channel The channel to follow.
     * @param notifications Whether the user will receive notifications.
     */
    UserAPI.prototype.followChannel = function (user, channel, notifications) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, channelId, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        channelId = UserTools_1.extractUserId(channel);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/follows/channels/" + channelId,
                                method: 'PUT',
                                scope: 'user_follows_edit',
                                body: { notifications: Boolean(notifications).toString() }
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new UserFollow_1.default(data, this._client)];
                }
            });
        });
    };
    /**
     * Unfollows a given channel with a given user.
     *
     * @param user The user you want to unfollow with.
     * @param channel The channel to unfollow.
     */
    UserAPI.prototype.unfollowChannel = function (user, channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, channelId;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        channelId = UserTools_1.extractUserId(channel);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/follows/channels/" + channelId,
                                scope: 'user_follows_edit',
                                method: 'DELETE'
                            })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves a list of users a given user has blocked.
     *
     * @param user The user you want to retrieve the block list of.
     * @param page The result page you want to retrieve.
     * @param limit The number of results you want to retrieve.
     */
    UserAPI.prototype.getBlockedUsers = function (user, page, limit) {
        if (limit === void 0) { limit = 25; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, query, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        query = { limit: limit.toString() };
                        if (page) {
                            query.offset = ((page - 1) * limit).toString();
                        }
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/blocks",
                                query: query,
                                scope: 'user_blocks_read'
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.blocks.map(function (block) { return new UserBlock_1.default(block, _this._client); })];
                }
            });
        });
    };
    /**
     * Blocks a given user with another given user.
     *
     * @param user The user you want to block with.
     * @param userToBlock The user to block.
     */
    UserAPI.prototype.blockUser = function (user, userToBlock) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, userIdToBlock, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        userIdToBlock = UserTools_1.extractUserId(userToBlock);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/blocks/" + userIdToBlock,
                                method: 'PUT',
                                scope: 'user_blocks_edit'
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new UserBlock_1.default(data, this._client)];
                }
            });
        });
    };
    /**
     * Unblocks a given user with another given user.
     *
     * @param user The user you want to unblock with.
     * @param userToUnblock The user to unblock.
     */
    UserAPI.prototype.unblockUser = function (user, userToUnblock) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var userId, userIdToUnblock;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        userId = UserTools_1.extractUserId(user);
                        userIdToUnblock = UserTools_1.extractUserId(userToUnblock);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "users/" + userId + "/blocks/" + userIdToUnblock,
                                method: 'DELETE',
                                scope: 'user_blocks_edit'
                            })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    UserAPI.prototype._cleanUserCache = function () {
        var _this = this;
        var now = Date.now();
        this._userByNameCache.forEach(function (val, key) {
            if (val.expires < now) {
                _this._userByNameCache.delete(key);
            }
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], UserAPI.prototype, "getMe", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], UserAPI.prototype, "getUser", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], UserAPI.prototype, "getChatInfo", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], UserAPI.prototype, "getUserEmotes", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], UserAPI.prototype, "getSubscriptionData", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(300)
    ], UserAPI.prototype, "getFollowedChannels", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(300)
    ], UserAPI.prototype, "getFollowedChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.ClearsCache('getFollowedChannels', 1),
        cache_decorators_1.ClearsCache('getFollowedChannel', 2)
    ], UserAPI.prototype, "followChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.ClearsCache('getFollowedChannels', 1),
        cache_decorators_1.ClearsCache('getFollowedChannel', 2)
    ], UserAPI.prototype, "unfollowChannel", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(3600)
    ], UserAPI.prototype, "getBlockedUsers", null);
    tslib_1.__decorate([
        cache_decorators_1.ClearsCache('getBlockedUsers', 1)
    ], UserAPI.prototype, "blockUser", null);
    tslib_1.__decorate([
        cache_decorators_1.ClearsCache('getBlockedUsers', 1)
    ], UserAPI.prototype, "unblockUser", null);
    UserAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], UserAPI);
    return UserAPI;
}(BaseAPI_1.default));
exports.default = UserAPI;

},{"../../../Errors/HTTPStatusCodeError":314,"../../../Errors/HellFreezesOverError":315,"../../../Errors/NoSubscriptionProgramError":317,"../../../Toolkit/UserTools":320,"../../BaseAPI":241,"../Channel/EmoteSetList":284,"./PrivilegedUser":298,"./User":299,"./UserBlock":301,"./UserChatInfo":302,"./UserFollow":303,"./UserSubscription":304,"@d-fischer/cache-decorators":6,"@d-fischer/shared-utils":36,"tslib":217}],301:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var User_1 = require("./User");
/**
 * A relation of a previously givn user blocking another user.
 */
var UserBlock = /** @class */ (function () {
    /** @private */
    function UserBlock(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(UserBlock.prototype, "blockedUser", {
        /**
         * The blocked user.
         */
        get: function () {
            return new User_1.default(this._data.user, this._client);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], UserBlock.prototype, "_client", void 0);
    return UserBlock;
}());
exports.default = UserBlock;

},{"./User":299,"@d-fischer/shared-utils":36,"tslib":217}],302:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
/**
 * Information about a user's chat appearance and privileges.
 */
var UserChatInfo = /** @class */ (function () {
    /** @private */
    function UserChatInfo(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(UserChatInfo.prototype, "userId", {
        /**
         * The ID of the user.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Retrieves more data about the user.
     */
    UserChatInfo.prototype.getUser = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._client.kraken.users.getUser(this._data._id)];
            });
        });
    };
    Object.defineProperty(UserChatInfo.prototype, "userName", {
        /**
         * The name of the user.
         */
        get: function () {
            return this._data.login;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserChatInfo.prototype, "displayName", {
        /**
         * The display name of the user.
         */
        get: function () {
            return this._data.display_name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserChatInfo.prototype, "color", {
        /**
         * The color that the user appears in in chat.
         */
        get: function () {
            return this._data.color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserChatInfo.prototype, "isKnownBot", {
        /**
         * Whether the user is a known bot.
         */
        get: function () {
            return this._data.is_known_bot;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserChatInfo.prototype, "isVerifiedBot", {
        /**
         * Whether the user is a verified bot.
         */
        get: function () {
            return this._data.is_verified_bot;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserChatInfo.prototype, "isAtLeastKnownBot", {
        /**
         * Whether the user is at least a known bot (i.e. known or verified).
         */
        get: function () {
            return this._data.is_known_bot || this._data.is_verified_bot;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks whether the user has access to a given global badge.
     *
     * @param id The ID of a badge.
     */
    UserChatInfo.prototype.hasBadge = function (id) {
        return this._data.badges.some(function (badge) { return badge.id === id; });
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], UserChatInfo.prototype, "_client", void 0);
    return UserChatInfo;
}());
exports.default = UserChatInfo;

},{"@d-fischer/shared-utils":36,"tslib":217}],303:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var Channel_1 = require("../Channel/Channel");
/**
 * A relation of a previously given user following a channel.
 */
var UserFollow = /** @class */ (function () {
    /** @private */
    function UserFollow(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(UserFollow.prototype, "followDate", {
        /**
         * The date when the user followed the channel.
         */
        get: function () {
            return new Date(this._data.created_at);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserFollow.prototype, "hasNotifications", {
        /**
         * Whether the user has notifications enabled for the channel.
         */
        get: function () {
            return this._data.notifications;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UserFollow.prototype, "channel", {
        /**
         * The followed channel.
         */
        get: function () {
            return new Channel_1.default(this._data.channel, this._client);
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], UserFollow.prototype, "_client", void 0);
    return UserFollow;
}());
exports.default = UserFollow;

},{"../Channel/Channel":279,"@d-fischer/shared-utils":36,"tslib":217}],304:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Subscription_1 = require("../Subscription");
var Channel_1 = require("../Channel/Channel");
/**
 * A relation of a previously given user subscribing to a channel.
 */
var UserSubscription = /** @class */ (function (_super) {
    tslib_1.__extends(UserSubscription, _super);
    function UserSubscription() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(UserSubscription.prototype, "channel", {
        /**
         * The subscribed channel.
         */
        get: function () {
            return new Channel_1.default(this._data.channel, this._client);
        },
        enumerable: true,
        configurable: true
    });
    return UserSubscription;
}(Subscription_1.default));
exports.default = UserSubscription;

},{"../Channel/Channel":279,"../Subscription":294,"tslib":217}],305:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Information about an access token.
 */
var TokenInfo = /** @class */ (function () {
    /** @private */
    function TokenInfo(_data) {
        this._data = _data;
        this._obtainmentDate = new Date();
    }
    Object.defineProperty(TokenInfo.prototype, "clientId", {
        /**
         * The client ID.
         */
        get: function () {
            return this._data.client_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TokenInfo.prototype, "userId", {
        /**
         * The ID of the authenticated user.
         */
        get: function () {
            return this._data.user_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TokenInfo.prototype, "userName", {
        /**
         * The user name of the authenticated user.
         */
        get: function () {
            return this._data.login;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TokenInfo.prototype, "scopes", {
        /**
         * The scopes for which this token is valid.
         */
        get: function () {
            return this._data.scopes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TokenInfo.prototype, "expiryDate", {
        /**
         * The time when the token will expire.
         *
         * If this returns null, it means that the token is either invalid or never expires (happens with old client IDs).
         */
        get: function () {
            if (!this._data.expires_in) {
                return null;
            }
            return new Date(this._obtainmentDate.getTime() + this._data.expires_in * 1000);
        },
        enumerable: true,
        configurable: true
    });
    return TokenInfo;
}());
exports.default = TokenInfo;

},{}],306:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var Channel_1 = require("../Kraken/Channel/Channel");
/**
 * An event held on a Twitch channel.
 */
var ChannelEvent = /** @class */ (function () {
    /** @private */
    function ChannelEvent(_data, client) {
        this._data = _data;
        this._client = client;
    }
    Object.defineProperty(ChannelEvent.prototype, "id", {
        /**
         * The ID of the event.
         */
        get: function () {
            return this._data._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChannelEvent.prototype, "startDate", {
        /**
         * The time when the event starts.
         */
        get: function () {
            return new Date(this._data.start_time);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChannelEvent.prototype, "endDate", {
        /**
         * The time when the event ends.
         */
        get: function () {
            return new Date(this._data.end_time);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChannelEvent.prototype, "timeZoneId", {
        /**
         * The ID of the timezone that the start and end times of the event are local to.
         */
        get: function () {
            return this._data.time_zone_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChannelEvent.prototype, "title", {
        /**
         * The title of the event.
         */
        get: function () {
            return this._data.title;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChannelEvent.prototype, "description", {
        /**
         * The description of the event.
         */
        get: function () {
            return this._data.description;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChannelEvent.prototype, "language", {
        /**
         * The language of the event.
         */
        get: function () {
            return this._data.language;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChannelEvent.prototype, "channel", {
        /**
         * The channel where the event is held.
         */
        get: function () {
            return new Channel_1.default(this._data.channel, this._client);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Generates a URL to the cover image of the event with the given dimensions.
     *
     * @param width The width of the image.
     * @param height The height of the image.
     */
    ChannelEvent.prototype.buildCoverImageUrl = function (width, height) {
        return this._data.cover_image_url.replace('{width}', width.toString()).replace('{height}', height.toString());
    };
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ChannelEvent.prototype, "_client", void 0);
    return ChannelEvent;
}());
exports.default = ChannelEvent;

},{"../Kraken/Channel/Channel":279,"@d-fischer/shared-utils":36,"tslib":217}],307:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
/**
 * A list of chatters in a Twitch chat.
 */
var ChattersList = /** @class */ (function () {
    /** @private */
    function ChattersList(_data) {
        this._data = _data;
    }
    Object.defineProperty(ChattersList.prototype, "allChatters", {
        /**
         * A list of user names of all chatters in the chat.
         */
        get: function () {
            return shared_utils_1.flatten(Object.values(this._data.chatters));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ChattersList.prototype, "allChattersWithStatus", {
        /**
         * A map of user names of all chatters in the chat, mapped to their status in the channel.
         */
        get: function () {
            return new Map(shared_utils_1.flatten(Object.entries(this._data.chatters).map(function (_a) {
                var _b = tslib_1.__read(_a, 2), status = _b[0], names = _b[1];
                return names.map(function (name) { return [name, status]; });
            })));
        },
        enumerable: true,
        configurable: true
    });
    return ChattersList;
}());
exports.default = ChattersList;

},{"@d-fischer/shared-utils":36,"tslib":217}],308:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var cache_decorators_1 = require("@d-fischer/cache-decorators");
var UserTools_1 = require("../../Toolkit/UserTools");
var TwitchClient_1 = require("../../TwitchClient");
var BaseAPI_1 = require("../BaseAPI");
var ChannelEvent_1 = require("./ChannelEvent");
var ChattersList_1 = require("./ChattersList");
/**
 * Different API methods that are not officially supported by Twitch.
 *
 * Can be accessed using `client.unsupported` on a {@TwitchClient} instance.
 *
 * ## Example
 * ```ts
 * const client = TwitchClient.withCredentials(clientId, accessToken);
 * const events = await client.unsupported.getEvents('125328655');
 * ```
 */
var UnsupportedAPI = /** @class */ (function (_super) {
    tslib_1.__extends(UnsupportedAPI, _super);
    function UnsupportedAPI() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Retrieves a list of chatters in the Twitch chat of the given channel.
     *
     * **WARNING**: In contrast to most other methods, this takes a channel *name*, not a user ID.
     *
     * @param channel The channel to retrieve the chatters for.
     */
    UnsupportedAPI.prototype.getChatters = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelName, data;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelName = UserTools_1.extractUserName(channel);
                        return [4 /*yield*/, this._client.callAPI({
                                url: "https://tmi.twitch.tv/group/user/" + channelName + "/chatters",
                                type: TwitchClient_1.TwitchAPICallType.Custom
                            })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new ChattersList_1.default(data)];
                }
            });
        });
    };
    /**
     * Retrieves a list of event planned for the given channel.
     *
     * @param channel The channel to retrieve the events for.
     */
    UnsupportedAPI.prototype.getEvents = function (channel) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var channelId, data;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        channelId = UserTools_1.extractUserId(channel);
                        return [4 /*yield*/, this._client.callAPI({ url: "channels/" + channelId + "/events" })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, data.events.map(function (event) { return new ChannelEvent_1.default(event, _this._client); })];
                }
            });
        });
    };
    tslib_1.__decorate([
        cache_decorators_1.Cached(60)
    ], UnsupportedAPI.prototype, "getChatters", null);
    tslib_1.__decorate([
        cache_decorators_1.Cached(60)
    ], UnsupportedAPI.prototype, "getEvents", null);
    UnsupportedAPI = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], UnsupportedAPI);
    return UnsupportedAPI;
}(BaseAPI_1.default));
exports.default = UnsupportedAPI;

},{"../../Toolkit/UserTools":320,"../../TwitchClient":321,"../BaseAPI":241,"./ChannelEvent":306,"./ChattersList":307,"@d-fischer/cache-decorators":6,"tslib":217}],309:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var TwitchClient_1 = require("../TwitchClient");
/**
 * An auth provider that retrieve tokens using client credentials.
 */
var ClientCredentialsAuthProvider = /** @class */ (function () {
    /**
     * Creates a new auth provider to receive an application token with using the client ID and secret.
     *
     * You don't usually have to create this manually. You should use `TwitchClient.withClientCredentials` instead.
     *
     * @param clientId The client ID of your application.
     * @param clientSecret The client secret of your application.
     *
     * You need to obtain one using one of the [Twitch OAuth flows](https://dev.twitch.tv/docs/authentication/getting-tokens-oauth/).
     */
    function ClientCredentialsAuthProvider(clientId, clientSecret) {
        this._clientId = clientId;
        this._clientSecret = clientSecret;
    }
    /**
     * Retrieves an access token.
     *
     * If any scopes are provided, this throws. The client credentials flow does not support scopes.
     *
     * @param scopes The requested scopes.
     */
    ClientCredentialsAuthProvider.prototype.getAccessToken = function (scopes) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                if (scopes && scopes.length > 0) {
                    throw new Error('The client credentials flow does not support scopes');
                }
                if (!this._token || this._token.isExpired) {
                    return [2 /*return*/, this.refresh()];
                }
                return [2 /*return*/, this._token];
            });
        });
    };
    /**
     * Retrieves a new app access token.
     */
    ClientCredentialsAuthProvider.prototype.refresh = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this;
                        return [4 /*yield*/, TwitchClient_1.default.getAppAccessToken(this._clientId, this._clientSecret)];
                    case 1: return [2 /*return*/, (_a._token = _b.sent())];
                }
            });
        });
    };
    /** @private */
    ClientCredentialsAuthProvider.prototype.setAccessToken = function (token) {
        this._token = token;
    };
    Object.defineProperty(ClientCredentialsAuthProvider.prototype, "clientId", {
        /**
         * The client ID.
         */
        get: function () {
            return this._clientId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientCredentialsAuthProvider.prototype, "currentScopes", {
        /**
         * The scopes that are currently available using the access token.
         */
        get: function () {
            return [];
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ClientCredentialsAuthProvider.prototype, "_clientId", void 0);
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ClientCredentialsAuthProvider.prototype, "_clientSecret", void 0);
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], ClientCredentialsAuthProvider.prototype, "_token", void 0);
    return ClientCredentialsAuthProvider;
}());
exports.default = ClientCredentialsAuthProvider;

},{"../TwitchClient":321,"@d-fischer/shared-utils":36,"tslib":217}],310:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var TwitchClient_1 = require("../TwitchClient");
/**
 * Enhances another auth provider with the ability to make use of refresh
 * tokens, automatically refreshing the access token whenever necessary.
 */
var RefreshableAuthProvider = /** @class */ (function () {
    /**
     * Creates a new auth provider based on the given one that can automatically
     * refresh access tokens.
     *
     * You don't usually have to create this manually. You should use `TwitchClient.withCredentials`
     * with the `refreshConfig` parameter instead.
     *
     * @param childProvider The base auth provider.
     * @param refreshConfig The information necessary to automatically refresh an access token.
     */
    function RefreshableAuthProvider(childProvider, refreshConfig) {
        this._clientSecret = refreshConfig.clientSecret;
        this._refreshToken = refreshConfig.refreshToken;
        this._childProvider = childProvider;
        this._initialExpiry = refreshConfig.expiry;
        this._onRefresh = refreshConfig.onRefresh;
    }
    /**
     * Retrieves an access token.
     *
     * If the current access token does not have the requested scopes, the base auth
     * provider is called.
     *
     * If the current access token is expired, automatically renew it.
     *
     * @param scopes The requested scopes.
     */
    RefreshableAuthProvider.prototype.getAccessToken = function (scopes) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var oldToken, newToken, now, refreshedToken;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (typeof scopes === 'string') {
                            scopes = scopes.split(' ');
                        }
                        return [4 /*yield*/, this._childProvider.getAccessToken()];
                    case 1:
                        oldToken = _a.sent();
                        if (!(oldToken && scopes && scopes.some(function (scope) { return !_this.currentScopes.includes(scope); }))) return [3 /*break*/, 3];
                        return [4 /*yield*/, this._childProvider.getAccessToken(scopes)];
                    case 2:
                        newToken = _a.sent();
                        // ...but if the token doesn't change, carry on
                        if (newToken !== oldToken) {
                            return [2 /*return*/, newToken];
                        }
                        _a.label = 3;
                    case 3:
                        // if we don't have a current token, we just pass this and refresh right away
                        if (oldToken) {
                            if (this._initialExpiry) {
                                now = new Date();
                                if (now < this._initialExpiry) {
                                    return [2 /*return*/, oldToken];
                                }
                            }
                            else if (!oldToken.isExpired) {
                                return [2 /*return*/, oldToken];
                            }
                        }
                        return [4 /*yield*/, this.refresh()];
                    case 4:
                        refreshedToken = _a.sent();
                        if (oldToken) {
                            return [2 /*return*/, refreshedToken];
                        }
                        // need to check again for scopes after refreshing, in case a refresh token was passed without an access token
                        return [2 /*return*/, this._childProvider.getAccessToken(scopes)];
                }
            });
        });
    };
    /**
     * Force a refresh of the access token.
     */
    RefreshableAuthProvider.prototype.refresh = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var tokenData;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, TwitchClient_1.default.refreshAccessToken(this.clientId, this._clientSecret, this._refreshToken)];
                    case 1:
                        tokenData = _a.sent();
                        this.setAccessToken(tokenData);
                        this._refreshToken = tokenData.refreshToken;
                        this._initialExpiry = undefined;
                        if (this._onRefresh) {
                            this._onRefresh(tokenData);
                        }
                        return [2 /*return*/, tokenData];
                }
            });
        });
    };
    /** @private */
    RefreshableAuthProvider.prototype.setAccessToken = function (token) {
        this._childProvider.setAccessToken(token);
    };
    Object.defineProperty(RefreshableAuthProvider.prototype, "clientId", {
        /**
         * The client ID.
         */
        get: function () {
            return this._childProvider.clientId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RefreshableAuthProvider.prototype, "currentScopes", {
        /**
         * The scopes that are currently available using the access token.
         */
        get: function () {
            return this._childProvider.currentScopes;
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], RefreshableAuthProvider.prototype, "_clientSecret", void 0);
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], RefreshableAuthProvider.prototype, "_refreshToken", void 0);
    return RefreshableAuthProvider;
}());
exports.default = RefreshableAuthProvider;

},{"../TwitchClient":321,"@d-fischer/shared-utils":36,"tslib":217}],311:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var AccessToken_1 = require("../API/AccessToken");
var TwitchClient_1 = require("../TwitchClient");
/**
 * An auth provider that always returns the same initially given credentials.
 *
 * You are advised to roll your own auth provider that can handle scope upgrades,
 * or to plan ahead and supply only access tokens that account for all scopes
 * you will ever need.
 */
var StaticAuthProvider = /** @class */ (function () {
    /**
     * Creates a new auth provider with static credentials.
     *
     * You don't usually have to create this manually. You should use `TwitchClient.withCredentials` instead.
     *
     * @param clientId The client ID.
     * @param accessToken The access token to provide.
     *
     * You need to obtain one using one of the [Twitch OAuth flows](https://dev.twitch.tv/docs/authentication/getting-tokens-oauth/).
     * @param scopes The scopes this token has.
     */
    function StaticAuthProvider(clientId, accessToken, scopes) {
        this._clientId = clientId || '';
        if (accessToken) {
            this._accessToken =
                typeof accessToken === 'string'
                    ? new AccessToken_1.default({
                        access_token: accessToken,
                        scope: scopes,
                        refresh_token: ''
                    })
                    : accessToken;
            this._scopes = scopes;
        }
    }
    /**
     * Retrieves an access token.
     *
     * If the current access token does not have the requested scopes, this method throws.
     * This makes supplying an access token with the correct scopes from the beginning necessary.
     *
     * @param scopes The requested scopes.
     */
    StaticAuthProvider.prototype.getAccessToken = function (scopes) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var tokenInfo;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(scopes && scopes.length > 0)) return [3 /*break*/, 3];
                        if (!!this._scopes) return [3 /*break*/, 2];
                        if (!this._accessToken) {
                            throw new Error('Auth provider has not been initialized with a token yet and is requesting scopes');
                        }
                        return [4 /*yield*/, TwitchClient_1.default.getTokenInfo(this._accessToken.accessToken, this._clientId)];
                    case 1:
                        tokenInfo = _a.sent();
                        this._scopes = tokenInfo.scopes;
                        _a.label = 2;
                    case 2:
                        if (typeof scopes === 'string') {
                            scopes = scopes.split(' ');
                        }
                        if (scopes.some(function (scope) { return !_this._scopes.includes(scope); })) {
                            throw new Error("This token does not have the requested scopes (" + scopes.join(', ') + ") and can not be upgraded");
                        }
                        _a.label = 3;
                    case 3: return [2 /*return*/, this._accessToken || null];
                }
            });
        });
    };
    /** @private */
    StaticAuthProvider.prototype.setAccessToken = function (token) {
        this._accessToken = token;
    };
    Object.defineProperty(StaticAuthProvider.prototype, "clientId", {
        /**
         * The client ID.
         */
        get: function () {
            return this._clientId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StaticAuthProvider.prototype, "currentScopes", {
        /**
         * The scopes that are currently available using the access token.
         */
        get: function () {
            return this._scopes || [];
        },
        enumerable: true,
        configurable: true
    });
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], StaticAuthProvider.prototype, "_clientId", void 0);
    tslib_1.__decorate([
        shared_utils_1.NonEnumerable
    ], StaticAuthProvider.prototype, "_accessToken", void 0);
    return StaticAuthProvider;
}());
exports.default = StaticAuthProvider;

},{"../API/AccessToken":236,"../TwitchClient":321,"@d-fischer/shared-utils":36,"tslib":217}],312:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var CustomError_1 = require("./CustomError");
/**
 * Thrown whenever you try using invalid values in the client configuration.
 */
var ConfigError = /** @class */ (function (_super) {
    tslib_1.__extends(ConfigError, _super);
    function ConfigError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ConfigError;
}(CustomError_1.default));
exports.default = ConfigError;

},{"./CustomError":313,"tslib":217}],313:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"dup":17,"tslib":217}],314:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var CustomError_1 = require("./CustomError");
/**
 * Thrown whenever a HTTP error occurs. Some HTTP errors are handled in the library when they're expected.
 */
var HTTPStatusCodeError = /** @class */ (function (_super) {
    tslib_1.__extends(HTTPStatusCodeError, _super);
    /** @private */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function HTTPStatusCodeError(statusCode, statusText, body) {
        var _this = _super.call(this, "Encountered HTTP status code " + statusCode + ": " + statusText + "\n\nBody:\n" + JSON.stringify(body, null, 2)) || this;
        _this._statusCode = statusCode;
        _this._body = body;
        return _this;
    }
    Object.defineProperty(HTTPStatusCodeError.prototype, "statusCode", {
        get: function () {
            return this._statusCode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HTTPStatusCodeError.prototype, "body", {
        get: function () {
            return this._body;
        },
        enumerable: true,
        configurable: true
    });
    return HTTPStatusCodeError;
}(CustomError_1.default));
exports.default = HTTPStatusCodeError;

},{"./CustomError":313,"tslib":217}],315:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var CustomError_1 = require("./CustomError");
/**
 * These are the kind of errors that should never happen.
 *
 * If you see one thrown, please file a bug in the GitHub issue tracker.
 */
var HellFreezesOverError = /** @class */ (function (_super) {
    tslib_1.__extends(HellFreezesOverError, _super);
    function HellFreezesOverError(message) {
        return _super.call(this, message + " - this should never happen, please file a bug in the GitHub issue tracker") || this;
    }
    return HellFreezesOverError;
}(CustomError_1.default));
exports.default = HellFreezesOverError;

},{"./CustomError":313,"tslib":217}],316:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var CustomError_1 = require("./CustomError");
var InvalidTokenError = /** @class */ (function (_super) {
    tslib_1.__extends(InvalidTokenError, _super);
    function InvalidTokenError() {
        return _super.call(this, 'Invalid token supplied') || this;
    }
    return InvalidTokenError;
}(CustomError_1.default));
exports.default = InvalidTokenError;

},{"./CustomError":313,"tslib":217}],317:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var CustomError_1 = require("./CustomError");
/**
 * Thrown whenever you try accessing a subscription-related resource
 * (for example {@ChannelAPI#getChannelSubscriptions})
 * and the given channel does not have a subscription program.
 */
var NoSubscriptionProgramError = /** @class */ (function (_super) {
    tslib_1.__extends(NoSubscriptionProgramError, _super);
    function NoSubscriptionProgramError(channelId) {
        return _super.call(this, "Channel " + channelId + " does not have a subscription program") || this;
    }
    return NoSubscriptionProgramError;
}(CustomError_1.default));
exports.default = NoSubscriptionProgramError;

},{"./CustomError":313,"tslib":217}],318:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var CustomError_1 = require("./CustomError");
/**
 * Thrown whenever you try something that requires your own stream to be live.
 */
var StreamNotLiveError = /** @class */ (function (_super) {
    tslib_1.__extends(StreamNotLiveError, _super);
    function StreamNotLiveError() {
        return _super.call(this, 'Your stream needs to be live to do this') || this;
    }
    return StreamNotLiveError;
}(CustomError_1.default));
exports.default = StreamNotLiveError;

},{"./CustomError":313,"tslib":217}],319:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fetchPonyfill = require("fetch-ponyfill");
var _a = fetchPonyfill(), fetch = _a.fetch, Headers = _a.Headers, Request = _a.Request, Response = _a.Response;
exports.fetch = fetch;
exports.Headers = Headers;
exports.Request = Request;
exports.Response = Response;

},{"fetch-ponyfill":99}],320:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Extracts the user ID from an argument that is possibly an object containing that ID.
 *
 * @param user The user ID or object.
 */
function extractUserId(user) {
    return typeof user === 'string' ? user : user.id;
}
exports.extractUserId = extractUserId;
/**
 * Extracts the user name from an argument that is possibly an object containing that name.
 *
 * @param user The user name or object.
 */
function extractUserName(user) {
    return typeof user === 'string' ? user : user.name;
}
exports.extractUserName = extractUserName;

},{}],321:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var cache_decorators_1 = require("@d-fischer/cache-decorators");
var logger_1 = require("@d-fischer/logger");
var qs = require("qs");
var AccessToken_1 = require("./API/AccessToken");
var BadgesAPI_1 = require("./API/Badges/BadgesAPI");
var HelixAPIGroup_1 = require("./API/Helix/HelixAPIGroup");
var HelixRateLimiter_1 = require("./API/Helix/HelixRateLimiter");
var CheermoteList_1 = require("./API/Kraken/Bits/CheermoteList");
var KrakenAPIGroup_1 = require("./API/Kraken/KrakenAPIGroup");
var TokenInfo_1 = require("./API/TokenInfo");
var UnsupportedAPI_1 = require("./API/Unsupported/UnsupportedAPI");
var ClientCredentialsAuthProvider_1 = require("./Auth/ClientCredentialsAuthProvider");
var RefreshableAuthProvider_1 = require("./Auth/RefreshableAuthProvider");
var StaticAuthProvider_1 = require("./Auth/StaticAuthProvider");
var ConfigError_1 = require("./Errors/ConfigError");
var HTTPStatusCodeError_1 = require("./Errors/HTTPStatusCodeError");
var InvalidTokenError_1 = require("./Errors/InvalidTokenError");
var Fetch_1 = require("./Toolkit/Fetch");
/**
 * The endpoint to call, i.e. /kraken, /helix or a custom (potentially unsupported) endpoint.
 */
var TwitchAPICallType;
(function (TwitchAPICallType) {
    /**
     * Call a Kraken API endpoint.
     */
    TwitchAPICallType[TwitchAPICallType["Kraken"] = 0] = "Kraken";
    /**
     * Call a Helix API endpoint.
     */
    TwitchAPICallType[TwitchAPICallType["Helix"] = 1] = "Helix";
    /**
     * Call an authentication endpoint.
     */
    TwitchAPICallType[TwitchAPICallType["Auth"] = 2] = "Auth";
    /**
     * Call a custom (potentially unsupported) endpoint.
     */
    TwitchAPICallType[TwitchAPICallType["Custom"] = 3] = "Custom";
})(TwitchAPICallType = exports.TwitchAPICallType || (exports.TwitchAPICallType = {}));
/**
 * The main entry point of this library. Manages API calls and the use of access tokens in these.
 */
var TwitchClient = /** @class */ (function () {
    /**
     * Creates a new Twitch client instance.
     *
     * @param config Configuration for the client instance.
     */
    function TwitchClient(config) {
        var authProvider = config.authProvider, restConfig = tslib_1.__rest(config, ["authProvider"]);
        if (!authProvider) {
            throw new ConfigError_1.default('No auth provider given');
        }
        this._helixRateLimiter = new HelixRateLimiter_1.default(config.logLevel || logger_1.LogLevel.CRITICAL);
        this._config = tslib_1.__assign({ preAuth: false, cheermotes: {
                defaultBackground: CheermoteList_1.CheermoteBackground.dark,
                defaultState: CheermoteList_1.CheermoteState.animated,
                defaultScale: CheermoteList_1.CheermoteScale.x1
            }, authProvider: authProvider }, restConfig);
        if (this._config.preAuth) {
            // tslint:disable-next-line:no-floating-promises
            authProvider.getAccessToken(this._config.initialScopes);
        }
    }
    TwitchClient_1 = TwitchClient;
    /**
     * Creates a new instance with fixed credentials.
     *
     * @param clientId The client ID of your application.
     * @param accessToken The access token to call the API with.
     *
     * You need to obtain one using one of the [Twitch OAuth flows](https://dev.twitch.tv/docs/authentication/getting-tokens-oauth/).
     * @param scopes The scopes your supplied token has.
     *
     * If this argument is given, the scopes need to be correct, or weird things might happen. If it's not (i.e. it's `undefined`), we fetch the correct scopes for you.
     *
     * If you can't exactly say which scopes your token has, don't use this parameter/set it to `undefined`.
     * @param refreshConfig Configuration to automatically refresh expired tokens.
     * @param config Additional configuration to pass to the constructor.
     *
     * Note that if you provide a custom `authProvider`, this method will overwrite it. In this case, you should use the constructor directly.
     */
    TwitchClient.withCredentials = function (clientId, accessToken, scopes, refreshConfig, config) {
        if (config === void 0) { config = {}; }
        var authProvider = refreshConfig
            ? new RefreshableAuthProvider_1.default(new StaticAuthProvider_1.default(clientId, accessToken, scopes), refreshConfig)
            : new StaticAuthProvider_1.default(clientId, accessToken, scopes);
        return new this(tslib_1.__assign(tslib_1.__assign({}, config), { authProvider: authProvider }));
    };
    /**
     * Creates a new instance with client credentials.
     *
     * @param clientId The client ID of your application.
     * @param clientSecret The client secret of your application.
     * @param config Additional configuration to pass to the constructor.
     *
     * Note that if you provide a custom `authProvider`, this method will overwrite it. In this case, you should use the constructor directly.
     */
    TwitchClient.withClientCredentials = function (clientId, clientSecret, config) {
        if (config === void 0) { config = {}; }
        var authProvider = clientSecret
            ? new ClientCredentialsAuthProvider_1.default(clientId, clientSecret)
            : new StaticAuthProvider_1.default(clientId);
        return new this(tslib_1.__assign(tslib_1.__assign({}, config), { authProvider: authProvider }));
    };
    /**
     * Makes a call to the Twitch API using given credetials.
     *
     * @param options The configuration of the call.
     * @param clientId The client ID of your application.
     * @param accessToken The access token to call the API with.
     *
     * You need to obtain one using one of the [Twitch OAuth flows](https://dev.twitch.tv/docs/authentication/getting-tokens-oauth/).
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    TwitchClient.callAPI = function (options, clientId, accessToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._callAPIRaw(options, clientId, accessToken)];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, this._transformResponse(response)];
                }
            });
        });
    };
    /**
     * Retrieves an access token with your client credentials and an authorization code.
     *
     * @param clientId The client ID of your application.
     * @param clientSecret The client secret of your application.
     * @param code The authorization code.
     * @param redirectUri The redirect URI. This serves no real purpose here, but must still match with the redirect URI you configured in the Twitch Developer dashboard.
     */
    TwitchClient.getAccessToken = function (clientId, clientSecret, code, redirectUri) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = AccessToken_1.default.bind;
                        return [4 /*yield*/, this.callAPI({
                                type: TwitchAPICallType.Auth,
                                url: 'token',
                                method: 'POST',
                                query: {
                                    grant_type: 'authorization_code',
                                    client_id: clientId,
                                    client_secret: clientSecret,
                                    code: code,
                                    redirect_uri: redirectUri
                                }
                            })];
                    case 1: return [2 /*return*/, new (_a.apply(AccessToken_1.default, [void 0, _b.sent()]))()];
                }
            });
        });
    };
    /**
     * Retrieves an app access token with your client credentials.
     *
     * @param clientId The client ID of your application.
     * @param clientSecret The client secret of your application.
     * @param clientSecret
     */
    TwitchClient.getAppAccessToken = function (clientId, clientSecret) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = AccessToken_1.default.bind;
                        return [4 /*yield*/, this.callAPI({
                                type: TwitchAPICallType.Auth,
                                url: 'token',
                                method: 'POST',
                                query: {
                                    grant_type: 'client_credentials',
                                    client_id: clientId,
                                    client_secret: clientSecret
                                }
                            })];
                    case 1: return [2 /*return*/, new (_a.apply(AccessToken_1.default, [void 0, _b.sent()]))()];
                }
            });
        });
    };
    /**
     * Refreshes an expired access token with your client credentials and the refresh token that was given by the initial authentication.
     *
     * @param clientId The client ID of your application.
     * @param clientSecret The client secret of your application.
     * @param refreshToken The refresh token.
     */
    TwitchClient.refreshAccessToken = function (clientId, clientSecret, refreshToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = AccessToken_1.default.bind;
                        return [4 /*yield*/, this.callAPI({
                                type: TwitchAPICallType.Auth,
                                url: 'token',
                                method: 'POST',
                                query: {
                                    grant_type: 'refresh_token',
                                    client_id: clientId,
                                    client_secret: clientSecret,
                                    refresh_token: refreshToken
                                }
                            })];
                    case 1: return [2 /*return*/, new (_a.apply(AccessToken_1.default, [void 0, _b.sent()]))()];
                }
            });
        });
    };
    /**
     * Retrieves information about an access token.
     *
     * @param clientId The client ID of your application.
     * @param accessToken The access token to get the information of.
     *
     * You need to obtain one using one of the [Twitch OAuth flows](https://dev.twitch.tv/docs/authentication/getting-tokens-oauth/).
     */
    TwitchClient.getTokenInfo = function (accessToken, clientId) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data, e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.callAPI({ type: TwitchAPICallType.Auth, url: 'validate' }, clientId, accessToken)];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new TokenInfo_1.default(data)];
                    case 2:
                        e_1 = _a.sent();
                        if (e_1 instanceof HTTPStatusCodeError_1.default && e_1.statusCode === 401) {
                            throw new InvalidTokenError_1.default();
                        }
                        throw e_1;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @private
     */
    TwitchClient._callAPIRaw = function (options, clientId, accessToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var type, url, params, headers, body, requestOptions;
            return tslib_1.__generator(this, function (_a) {
                type = options.type === undefined ? TwitchAPICallType.Kraken : options.type;
                url = this._getUrl(options.url, type);
                params = qs.stringify(options.query, { arrayFormat: 'repeat' });
                headers = new Fetch_1.Headers({
                    Accept: type === TwitchAPICallType.Kraken
                        ? "application/vnd.twitchtv.v" + (options.version || 5) + "+json"
                        : 'application/json'
                });
                if (options.body) {
                    body = qs.stringify(options.body);
                    headers.append('Content-Type', 'application/x-www-form-urlencoded');
                }
                else if (options.jsonBody) {
                    body = JSON.stringify(options.jsonBody);
                    headers.append('Content-Type', 'application/json');
                }
                if (clientId && type !== TwitchAPICallType.Auth) {
                    headers.append('Client-ID', clientId);
                }
                if (accessToken) {
                    headers.append('Authorization', (type === TwitchAPICallType.Helix ? 'Bearer' : 'OAuth') + " " + accessToken);
                }
                requestOptions = {
                    method: options.method || 'GET',
                    headers: headers,
                    body: body
                };
                return [2 /*return*/, Fetch_1.fetch(params ? url + "?" + params : url, requestOptions)];
            });
        });
    };
    /**
     * Retrieves information about your access token.
     */
    TwitchClient.prototype.getTokenInfo = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var data, e_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.callAPI({ type: TwitchAPICallType.Auth, url: 'validate' })];
                    case 1:
                        data = _a.sent();
                        return [2 /*return*/, new TokenInfo_1.default(data)];
                    case 2:
                        e_2 = _a.sent();
                        if (e_2 instanceof HTTPStatusCodeError_1.default && e_2.statusCode === 401) {
                            throw new InvalidTokenError_1.default();
                        }
                        throw e_2;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves an access token for the authentication provider.
     *
     * @param scopes The scopes to request.
     */
    TwitchClient.prototype.getAccessToken = function (scopes) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._config.authProvider.getAccessToken(scopes)];
            });
        });
    };
    /**
     * Forces the authentication provider to refresh the access token, if possible.
     */
    TwitchClient.prototype.refreshAccessToken = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._config.authProvider.refresh && this._config.authProvider.refresh()];
            });
        });
    };
    /**
     * Makes a call to the Twitch API using your access token.
     *
     * @param options The configuration of the call.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    TwitchClient.prototype.callAPI = function (options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var authProvider, accessToken, response;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        authProvider = this._config.authProvider;
                        return [4 /*yield*/, authProvider.getAccessToken(options.scope ? [options.scope] : undefined)];
                    case 1:
                        accessToken = _a.sent();
                        if (!accessToken) {
                            return [2 /*return*/, TwitchClient_1.callAPI(options, authProvider.clientId)];
                        }
                        if (!(accessToken.isExpired && authProvider.refresh)) return [3 /*break*/, 3];
                        return [4 /*yield*/, authProvider.refresh()];
                    case 2:
                        accessToken = _a.sent();
                        _a.label = 3;
                    case 3: return [4 /*yield*/, this._callAPIInternal(options, authProvider.clientId, accessToken.accessToken)];
                    case 4:
                        response = _a.sent();
                        if (!(response.status === 401 && authProvider.refresh)) return [3 /*break*/, 8];
                        return [4 /*yield*/, authProvider.refresh()];
                    case 5:
                        _a.sent();
                        return [4 /*yield*/, authProvider.getAccessToken(options.scope ? [options.scope] : [])];
                    case 6:
                        accessToken = _a.sent();
                        if (!accessToken) return [3 /*break*/, 8];
                        return [4 /*yield*/, this._callAPIInternal(options, authProvider.clientId, accessToken.accessToken)];
                    case 7:
                        response = _a.sent();
                        _a.label = 8;
                    case 8: return [2 /*return*/, TwitchClient_1._transformResponse(response)];
                }
            });
        });
    };
    Object.defineProperty(TwitchClient.prototype, "cheermoteDefaults", {
        /**
         * The default specs for cheermotes.
         */
        get: function () {
            return this._config.cheermotes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchClient.prototype, "kraken", {
        /**
         * A group of Kraken API methods.
         */
        get: function () {
            return new KrakenAPIGroup_1.default(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchClient.prototype, "helix", {
        /**
         * A group of Helix API methods.
         */
        get: function () {
            return new HelixAPIGroup_1.default(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchClient.prototype, "badges", {
        /**
         * The API methods that deal with badges.
         */
        get: function () {
            return new BadgesAPI_1.default(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TwitchClient.prototype, "unsupported", {
        /**
         * Various API methods that are not officially supported by Twitch.
         */
        get: function () {
            return new UnsupportedAPI_1.default(this);
        },
        enumerable: true,
        configurable: true
    });
    /** @private */
    TwitchClient.prototype._getAuthProvider = function () {
        return this._config.authProvider;
    };
    TwitchClient.prototype._callAPIInternal = function (options, clientId, accessToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                if (options.type === TwitchAPICallType.Helix) {
                    return [2 /*return*/, this._helixRateLimiter.request({ options: options, clientId: clientId, accessToken: accessToken })];
                }
                return [2 /*return*/, TwitchClient_1._callAPIRaw(options, clientId, accessToken)];
            });
        });
    };
    TwitchClient._getUrl = function (url, type) {
        switch (type) {
            case TwitchAPICallType.Kraken:
            case TwitchAPICallType.Helix:
                var typeName = type === TwitchAPICallType.Kraken ? 'kraken' : 'helix';
                return "https://api.twitch.tv/" + typeName + "/" + url.replace(/^\//, '');
            case TwitchAPICallType.Auth:
                return "https://id.twitch.tv/oauth2/" + url.replace(/^\//, '');
            case TwitchAPICallType.Custom:
                return url;
            default:
                return url; // wat
        }
    };
    TwitchClient._transformResponse = function (response) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, _b, text;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!!response.ok) return [3 /*break*/, 2];
                        _a = HTTPStatusCodeError_1.default.bind;
                        _b = [void 0, response.status, response.statusText];
                        return [4 /*yield*/, response.json()];
                    case 1: throw new (_a.apply(HTTPStatusCodeError_1.default, _b.concat([_c.sent()])))();
                    case 2:
                        if (response.status === 204) {
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            return [2 /*return*/, undefined]; // oof
                        }
                        return [4 /*yield*/, response.text()];
                    case 3:
                        text = _c.sent();
                        if (!text) {
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            return [2 /*return*/, undefined]; // mega oof - twitch doesn't return a response when it should
                        }
                        return [2 /*return*/, JSON.parse(text)];
                }
            });
        });
    };
    var TwitchClient_1;
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], TwitchClient.prototype, "kraken", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], TwitchClient.prototype, "helix", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], TwitchClient.prototype, "badges", null);
    tslib_1.__decorate([
        cache_decorators_1.CachedGetter()
    ], TwitchClient.prototype, "unsupported", null);
    TwitchClient = TwitchClient_1 = tslib_1.__decorate([
        cache_decorators_1.Cacheable
    ], TwitchClient);
    return TwitchClient;
}());
exports.default = TwitchClient;

},{"./API/AccessToken":236,"./API/Badges/BadgesAPI":237,"./API/Helix/HelixAPIGroup":251,"./API/Helix/HelixRateLimiter":256,"./API/Kraken/Bits/CheermoteList":278,"./API/Kraken/KrakenAPIGroup":290,"./API/TokenInfo":305,"./API/Unsupported/UnsupportedAPI":308,"./Auth/ClientCredentialsAuthProvider":309,"./Auth/RefreshableAuthProvider":310,"./Auth/StaticAuthProvider":311,"./Errors/ConfigError":312,"./Errors/HTTPStatusCodeError":314,"./Errors/InvalidTokenError":316,"./Toolkit/Fetch":319,"@d-fischer/cache-decorators":6,"@d-fischer/logger":16,"qs":212,"tslib":217}],322:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable filenames/match-exported */
var TwitchClient_1 = require("./TwitchClient");
exports.TwitchAPICallType = TwitchClient_1.TwitchAPICallType;
exports.default = TwitchClient_1.default;
var ConfigError_1 = require("./Errors/ConfigError");
exports.ConfigError = ConfigError_1.default;
var HellFreezesOverError_1 = require("./Errors/HellFreezesOverError");
exports.HellFreezesOverError = HellFreezesOverError_1.default;
var HTTPStatusCodeError_1 = require("./Errors/HTTPStatusCodeError");
exports.HTTPStatusCodeError = HTTPStatusCodeError_1.default;
var InvalidTokenError_1 = require("./Errors/InvalidTokenError");
exports.InvalidTokenError = InvalidTokenError_1.default;
var NoSubscriptionProgramError_1 = require("./Errors/NoSubscriptionProgramError");
exports.NoSubscriptionProgramError = NoSubscriptionProgramError_1.default;
var StreamNotLiveError_1 = require("./Errors/StreamNotLiveError");
exports.StreamNotLiveError = StreamNotLiveError_1.default;
var StaticAuthProvider_1 = require("./Auth/StaticAuthProvider");
exports.StaticAuthProvider = StaticAuthProvider_1.default;
var RefreshableAuthProvider_1 = require("./Auth/RefreshableAuthProvider");
exports.RefreshableAuthProvider = RefreshableAuthProvider_1.default;
var AccessToken_1 = require("./API/AccessToken");
exports.AccessToken = AccessToken_1.default;
var TokenInfo_1 = require("./API/TokenInfo");
exports.TokenInfo = TokenInfo_1.default;
var Subscription_1 = require("./API/Kraken/Subscription");
exports.Subscription = Subscription_1.default;
var CheermoteList_1 = require("./API/Kraken/Bits/CheermoteList");
exports.CheermoteList = CheermoteList_1.default;
exports.CheermoteBackground = CheermoteList_1.CheermoteBackground;
exports.CheermoteScale = CheermoteList_1.CheermoteScale;
exports.CheermoteState = CheermoteList_1.CheermoteState;
var Channel_1 = require("./API/Kraken/Channel/Channel");
exports.Channel = Channel_1.default;
var ChannelFollow_1 = require("./API/Kraken/Channel/ChannelFollow");
exports.ChannelFollow = ChannelFollow_1.default;
var ChannelPlaceholder_1 = require("./API/Kraken/Channel/ChannelPlaceholder");
exports.ChannelPlaceholder = ChannelPlaceholder_1.default;
var ChannelSubscription_1 = require("./API/Kraken/Channel/ChannelSubscription");
exports.ChannelSubscription = ChannelSubscription_1.default;
var EmoteSetList_1 = require("./API/Kraken/Channel/EmoteSetList");
exports.EmoteSetList = EmoteSetList_1.default;
var PrivilegedChannel_1 = require("./API/Kraken/Channel/PrivilegedChannel");
exports.PrivilegedChannel = PrivilegedChannel_1.default;
var Stream_1 = require("./API/Kraken/Stream/Stream");
exports.Stream = Stream_1.default;
exports.StreamType = Stream_1.StreamType;
var ChannelEvent_1 = require("./API/Unsupported/ChannelEvent");
exports.ChannelEvent = ChannelEvent_1.default;
var ChattersList_1 = require("./API/Unsupported/ChattersList");
exports.ChattersList = ChattersList_1.default;
var PrivilegedUser_1 = require("./API/Kraken/User/PrivilegedUser");
exports.PrivilegedUser = PrivilegedUser_1.default;
var User_1 = require("./API/Kraken/User/User");
exports.User = User_1.default;
var UserBlock_1 = require("./API/Kraken/User/UserBlock");
exports.UserBlock = UserBlock_1.default;
var UserFollow_1 = require("./API/Kraken/User/UserFollow");
exports.UserFollow = UserFollow_1.default;
var UserSubscription_1 = require("./API/Kraken/User/UserSubscription");
exports.UserSubscription = UserSubscription_1.default;
var HelixPaginatedRequest_1 = require("./API/Helix/HelixPaginatedRequest");
exports.HelixPaginatedRequest = HelixPaginatedRequest_1.default;
var HelixBitsLeaderboard_1 = require("./API/Helix/Bits/HelixBitsLeaderboard");
exports.HelixBitsLeaderboard = HelixBitsLeaderboard_1.default;
var HelixBitsLeaderboardEntry_1 = require("./API/Helix/Bits/HelixBitsLeaderboardEntry");
exports.HelixBitsLeaderboardEntry = HelixBitsLeaderboardEntry_1.default;
var HelixClip_1 = require("./API/Helix/Clip/HelixClip");
exports.HelixClip = HelixClip_1.default;
var HelixExtensionTransaction_1 = require("./API/Helix/Extensions/HelixExtensionTransaction");
exports.HelixExtensionTransaction = HelixExtensionTransaction_1.default;
var HelixGame_1 = require("./API/Helix/Game/HelixGame");
exports.HelixGame = HelixGame_1.default;
var HelixBan_1 = require("./API/Helix/Moderation/HelixBan");
exports.HelixBan = HelixBan_1.default;
var HelixBanEvent_1 = require("./API/Helix/Moderation/HelixBanEvent");
exports.HelixBanEvent = HelixBanEvent_1.default;
var HelixModerator_1 = require("./API/Helix/Moderation/HelixModerator");
exports.HelixModerator = HelixModerator_1.default;
var HelixModeratorEvent_1 = require("./API/Helix/Moderation/HelixModeratorEvent");
exports.HelixModeratorEvent = HelixModeratorEvent_1.default;
var HelixStream_1 = require("./API/Helix/Stream/HelixStream");
exports.HelixStream = HelixStream_1.default;
exports.HelixStreamType = HelixStream_1.HelixStreamType;
var HelixFollow_1 = require("./API/Helix/User/HelixFollow");
exports.HelixFollow = HelixFollow_1.default;
var HelixPrivilegedUser_1 = require("./API/Helix/User/HelixPrivilegedUser");
exports.HelixPrivilegedUser = HelixPrivilegedUser_1.default;
var HelixUser_1 = require("./API/Helix/User/HelixUser");
exports.HelixUser = HelixUser_1.default;
exports.HelixBroadcasterType = HelixUser_1.HelixBroadcasterType;
exports.HelixUserType = HelixUser_1.HelixUserType;
var HelixVideo_1 = require("./API/Helix/Video/HelixVideo");
exports.HelixVideo = HelixVideo_1.default;
var HelixSubscription_1 = require("./API/Helix/Subscriptions/HelixSubscription");
exports.HelixSubscription = HelixSubscription_1.default;
var HelixSubscriptionEvent_1 = require("./API/Helix/Subscriptions/HelixSubscriptionEvent");
exports.HelixSubscriptionEvent = HelixSubscriptionEvent_1.default;
var ChatBadgeList_1 = require("./API/Badges/ChatBadgeList");
exports.ChatBadgeList = ChatBadgeList_1.default;
var ChatBadgeSet_1 = require("./API/Badges/ChatBadgeSet");
exports.ChatBadgeSet = ChatBadgeSet_1.default;
var ChatBadgeVersion_1 = require("./API/Badges/ChatBadgeVersion");
exports.ChatBadgeVersion = ChatBadgeVersion_1.default;
var UserTools_1 = require("./Toolkit/UserTools");
exports.extractUserId = UserTools_1.extractUserId;
exports.extractUserName = UserTools_1.extractUserName;

},{"./API/AccessToken":236,"./API/Badges/ChatBadgeList":238,"./API/Badges/ChatBadgeSet":239,"./API/Badges/ChatBadgeVersion":240,"./API/Helix/Bits/HelixBitsLeaderboard":243,"./API/Helix/Bits/HelixBitsLeaderboardEntry":244,"./API/Helix/Clip/HelixClip":245,"./API/Helix/Extensions/HelixExtensionTransaction":247,"./API/Helix/Game/HelixGame":249,"./API/Helix/HelixPaginatedRequest":252,"./API/Helix/Moderation/HelixBan":257,"./API/Helix/Moderation/HelixBanEvent":258,"./API/Helix/Moderation/HelixModerator":260,"./API/Helix/Moderation/HelixModeratorEvent":261,"./API/Helix/Stream/HelixStream":262,"./API/Helix/Subscriptions/HelixSubscription":266,"./API/Helix/Subscriptions/HelixSubscriptionEvent":268,"./API/Helix/User/HelixFollow":269,"./API/Helix/User/HelixPrivilegedUser":270,"./API/Helix/User/HelixUser":271,"./API/Helix/Video/HelixVideo":273,"./API/Kraken/Bits/CheermoteList":278,"./API/Kraken/Channel/Channel":279,"./API/Kraken/Channel/ChannelFollow":281,"./API/Kraken/Channel/ChannelPlaceholder":282,"./API/Kraken/Channel/ChannelSubscription":283,"./API/Kraken/Channel/EmoteSetList":284,"./API/Kraken/Channel/PrivilegedChannel":285,"./API/Kraken/Stream/Stream":292,"./API/Kraken/Subscription":294,"./API/Kraken/User/PrivilegedUser":298,"./API/Kraken/User/User":299,"./API/Kraken/User/UserBlock":301,"./API/Kraken/User/UserFollow":303,"./API/Kraken/User/UserSubscription":304,"./API/TokenInfo":305,"./API/Unsupported/ChannelEvent":306,"./API/Unsupported/ChattersList":307,"./Auth/RefreshableAuthProvider":310,"./Auth/StaticAuthProvider":311,"./Errors/ConfigError":312,"./Errors/HTTPStatusCodeError":314,"./Errors/HellFreezesOverError":315,"./Errors/InvalidTokenError":316,"./Errors/NoSubscriptionProgramError":317,"./Errors/StreamNotLiveError":318,"./Toolkit/UserTools":320,"./TwitchClient":321}],323:[function(require,module,exports){
'use strict';

module.exports = WebSocket;

},{}],324:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],325:[function(require,module,exports){

},{}],326:[function(require,module,exports){
arguments[4][325][0].apply(exports,arguments)
},{"dup":325}],327:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

}).call(this,require("buffer").Buffer)
},{"base64-js":324,"buffer":327,"ieee754":329}],328:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],329:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],330:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[1]);
